---
sidebar_position: 2
sidebar_label: '- ראיון עבודה'
---

# מה להגיד בראיון עבודה טכני

## **נושא 1: איך להציג את הידע שלי ב-frontend**

אני עובד עם ה-eco-system של ריאקט כבר 3 שנים. וכמו לכל framework, ל-react יש את עמודי התווך שלה.

### - עמוד תווך 1: אתחול פרויקט

אז פעם כולנו היינו מתאחלים פרויקטי דמו של react עם cra, וכשהיינו רוצים להעלות משהו שהוא יותר production ready היינו משתמשים בכלים כמו-webpack, או grunt, או gulp יש כל מיני. browserify.  
אני עבדתי עם webpack. ולקנפג webpack היה תורה מסיני, ללמוד אותו לקח די הרבה זמן, רק בגלל כל הפלאגינים שלו, ובגלל כל ה-options והטוויקים הקטנים שיכלת לתת לו, לתפור אותו למידות של הפרויקט שלך של מה שאתה צריך. אתה רוצה sever side rendering. אז תקנפג ככה, אתה רוצה רוצה client side rendering? אז תעשה ככה.  
אבל! עם השנים הגיעו שני כלים חזקים לשוק,  
שהם game-changers, אחד יותר מוכר אחד פחות.  
next.js עבור server side rendering ו-vite.  
אני היום עובד עם vite.  
מכיר vite?  
(אם לא): בגלל שה-browser׳ים התקדמו והשתפרו, הם היום יודעים לעבוד ישירות עם מודולים. webpack, ה-HMR שלו עדיין עובד עם common js, ולכן על כל שינוי שלך בזמן development, הוא מבנדלר מחדש את כל העץ, מה שלוקח יותר זמן, וגם כל הדף שלך מתרנדר מחדש. vite, לעומת זאת, עובד עם esm, עם מודולים ישירות, אז ה-HMR שלו לא מבנדלר מחדש, אלא מעדכן רק את הקומפוננטה שהשתנתה, והאפליקציה שלך לא מתרנדרת מחדש כולה, אלא רק מה שהשתנה. מהיר בטירוף.

### - עמוד תווך 2: ראוטינג - Routing

אני משתמש ב-React router 6, הייתה מיגרציה קשוחה מ-5.  
אני יודע שיש גם את Tan stack router שהוא יותר light weight אבל משתמשים בו פחות בקהילה.  
והוא גם רק בגרסת אלפא.  
אבל! שיחקתי איתו קצת והוא נחמד.

### - עמוד תווך 3: State Management

השתמשתי ב-redux כשאת ה-middlewares בניתי from scratch.  
יצא לי לעבוד גם עם redux sagas שהוא ממוש ע״י generator functions ויצא לי לעבוד גם עם redux thunk..... בסוף מה שהתגלה כהכי scalabiliy זה לבנות את המידלוורס בעצמך, שם יצא לי מימוש שעבד הכי טוב.  
לפני שנה גיליתי על redux toolkit, או RTK בקיצור, שמעת על המאבק שהיה שם?  
היה המון רעש סביב זה... בגלל מארק אריקסון, המתחזק של רידקס, עשה בלאגן, ורב עם ryan florence, המתחזק של react router.  
כתחליף לרידקס,  
יצא לי להכיר גם את zoostand, שהוא כלי ל-state management רק יותר פשוט ו-lightweight. שמתשמש בעקרונות של flux.

### - עמוד תווך 4: Http Requests

יש את axios, שהוא מדהים. וכבר די החליף את fetch ה-native׳י.  
אבל עכשיו יש את tan stack query, שנהיה מאוד פופולרי,  
והוא יכול לעבוד בצמוד ל-axios, ויש לו הרבה דברים יפייפיים שהוא מביא לשולחן.  
ואם משתמשים ב-redux, אז יש את redux toolkit query.

### - עמוד תווך 5: Form Handling

אז ל-form handling יש את formik, שיצא לי לעבוד איתו לא מעט,  
אבל בערך לפני כשנה עקף אותו react hook form, וזכה לבחירה המועדפת שלנת 2023,  
אבל בינינו? בסוף בסוף, אני כבר מימשתי גרסה שלי ל-formik, שעובדת עבורי נהדר. ואז לא צריך לתחזק את זה יותר מידי, כי זה פשוט עובד טוב, עם מעט שורות קוד, ויעיל, וקריא, ולא הייתי צריך יותר מזה. גם formik גם react hook form וגם מה שאני בסוף בניתי, יכולים לעבוד עם yup או joi מאחורי הקלעים, שתי ספריות נהדרות לולידציות של type ו-value.

### - עמוד תווך 6: Testing

עבור unit tests יש את jest ואת vitest.  
jest הוא היותר ותיק, ו-vitest הוא היורש המחליף. כי הוא יותר מהיר. וכי jest עובד עם common js, מה שמצריך שימוש ב-babel.  
אני עובד עם vitest בגלל vite.  
זה כאילו נשמע שהוא מתאים רק לפרויקטים של vite אבל עשו אותו standalone אז גם פרויקט שלא אותחל עם vite יכול להשתמש ב-vitest.  
עבור ui testing, יש את React Testing Library.  
ועבור e2e tests יש או את puppeteer שעבדתי איתו תקופה,  
ובחצי שנה האחרונה החלפתי אותו ב-paywright, שזכה לכותרות ועושה הרבה רעש. כי הוא פשוט יותר reliable, עם הדרך שבה הוא ממש user click, וכאלה.  
וגם יש לו אחלה דוקומנטיצה, סופר קריא, סופר מובן.

### - עמוד תווך 7: Styling

פעם עבדתי עם הספריות שמביאות לך קומפוננטות מוכנות כמו או MaterialUI Ant Design או אפילו raw css שזה בכלל זוועה אבל היום יש פתרונות כמו styled components emotion css ו-tailwindcss שמאפשרים לך לסגנן כל קומפוננטה בצורה אינדיבידואלית ומבחינת ניהול קוד ו-treeshaking עושים לנו המפתחים חיים קלים. אני היום עובד עם tailwindcss, שאני מאוד מרוצה מהם, ואני ממליץ לכולם לעבור אליו.

### - עמוד תווך 8: Animation

React-spring Frame Motion

### - עמוד תווך 9: Data Visualization

Victory  
React-chartjs2  
Recharts( preffered )

### - עמוד תווך 10: Data Tables

Tanstack Table ( popular )  
AG Grid (Community & Enterprize) Handsontable

### - עמוד תווך 11: Internalization

React-i18  
FormatJS

### - עמוד תווך 12: Mobile Apps

React Native  
Drag & drop functionality - dnd kit  
File uploads - react-dropzone

### - עמוד תווך 13: Drag & drop functionality

dnd kit

### - עמוד תווך 14: Authentication

FireBase SupaBase

---

## **נושא 2: איך להציג את הידע שלי ב-Backend**

אני התחלתי מ-Java למען האמת.  
והייתי... די הרבה זמן ב-java, ככה שאני בעצם בא משפה שהיא strongly typed.  
אז אני מבין קונספטים של OOP ככה עם כל העקרונות הנורא בסיסיים של Abstraction, Encapsulation, Polymorphism, ו.... לא עלינו... Inheritance.

מעבר לזה שיש גם עקרונות חשובים וטובים... כמו חמשת עקרונות SOLID, שזה אקרונים ל-5 עקרונות מפתח שונים. ועוד קונספט אחד שנקרא DbC,  
אה Design by Contract, שזה כל מה שקשור ל-interface׳ים. שהם די בבסיס של פיתוח OOP. ובפיתוח בכלל.

ואז לפני... 3 שנים בערך....  
עברתי ל-javascript. מעבר חד מ-java על כל המשתמע מכך.

- שפה שבה פונקציות הן first class citizens.
- שפה שאתה די בקלות יכול להעביר פונקציה כארגומנט לפונקציה אחרת, משהו שב-Java אין.
- JavaScript שפה שהיא loosely typed, ואז אתה עובר ל-type inference, כי אין לך הגדרה של type׳ים בעת ההכרזה.
- וכמובן, איך לא, אולי הדבר הראשון שהייתי צריך להגיד. javascript היא single threaded. שהרבה אנשים חושבים שזו קללה, אני מהאנשים שחושבים שזו דווקא ברכה. אני לא יודע מה איתך, אבל שנאתי את ההתעסקות עם thread׳ים, ו-dead locks, ולשים מנעול על פונקציה, ולעשות awake לכולם. זה יכול מהר מאוד, אם לא שומרים על Clean Code להגיע למצבים נוראיים. מעבר לזה שקשה לדבג את זה.
- וכשאני התחלתי, עם javascript שמעתי על פרדיגמה חדשה שכולם נורא התלהבו ממנה, של Functional Programming, עם כל מיני עקרונות של:
  - אימיוטביליות
  - Pure Functions
  - High Order Functions ועוד כל מיני דברים.

ואז יש את Node.js

- **Node is a runtime**. יNode זה runtime עבור javascript, שיש לו גישה לאופרציות של מערכת ההפעלה. ובעיקר בעיקר משמש אותנו לכתיבה של סרברים.
- **Express**. אז שם יש את הספרייה הפופולרית Express, שבאה עם העקרון של ה-middlewares, ואתה בונה לך ארכיטקטורת שרת.
- **ארכיטקטורת שרת**. מבחינת ארכיטקטורת שרת אני התמקדתי בשרת http שאני בונה אותו עם rest api, מחולק לסרביסים ראוטים וריפוסיטוריז. השלישייה הזאת. ואגב השלישייה הזאת תקפה לא משנה אם אני מפתח שרת שהוא מונולית׳, או שרת שהוא מיקרו-סרביסים, ההתיחסות שלי היא the same.
- **מונוריפו**. זה גם זמן טוב להגיד שאני רגיל לעבוד בסביבה שהיא מונו-ריפו. אני עובד עם ה-package manager שנקרא pnpm. שמשתמש ב-symbolic linking ו-hard linking מה שמאפשר לו להשתמש בהרבה הרבה פחות זכרון על הדיסק, וגם שומר על ה-node_modules נקי. ראיתי שיש טכנולוגיה חדשה לעבודה עם monorepo, נקרא NX. יש הרבה hype סביב זה לאחרונה. אני אולי אעבור לבדוק מה זה נותן.
- **סרבר זה גם התחברות לדאטה בייסים**. מונגו, mariaDB, רדיס קש, יצא לי לכתתוב להם מעין wrapper ל-client, שהוא חיצוני לפרויקט, ואני שם אותו כ-third party library שאני עושה לה import.
- **שרת שהוא Transformer**. מכיר את הרובוטריקים? אז יש לי שרת שהוא טרנספורמר. זה שרת... שבניתי אותו כמונולית׳, הדיפלוי שלו... הוא דיפלוי של מונולית׳. ומחר אם אני רוצה, טוויקים קטנים, וכל השרת עובר להיות מיקרו סרביסים. עם api-gateway, שמבצע את האות׳נטיקציה ליוזר, שמסיר header׳ים שהם בגדר secure, שמפנה את הבקשה למיקרו-סרביס הרצוי. שרת שמכיל את ה-networkBus שהוא האמצעי תקשורת בין המיקרו סרביסים. וכמובן שהדיפולי... מותאם להיות דיפולי של מיקרו-סרביסים.
- **חטאים**.
- **טסטים**. אז אני מאלה שכן מאמינים בטסטים. אנחנו מדברים על Unit tests כמובן, ו... אם עושים dependency injection כמו שצריך, אפשר גם לממש יופי של intergration tests.

לגבי deploy...

- יצא לי לעשות דיפלוי גם לפרויקט מונוריפו, שמן הסתם זה יותר קל, וגם דיפלוי ל-micro-service׳ים.
- שניהם כמובן עברו דרך CI/CD, שזה pipeline שבניתי עם CircleCI עם sequence שמתחיל בעת יצירה של pull request ואחד שמתחיל אחרי מירג׳וג׳ ל-master.
- דיפלוי של מונולית׳ יצא לי לעשות לענן של GCP
- דיפולוי של מיקרו סרביסים יצא לי לעשות ל-AWS ל-ECS. שאתה כבר לא יכול לעשות דיפולי ל-EC2 פשוט, ואתה צריך משהו קצת יותר מתקדם.
- גילוי נאות אני פחות התעסקתי בצד ה-AWS׳י. היו לנו אנשים שזה היה התפקיד שלהם, והם רק סיפקו לי את ה-credentials להשתמש בהם, ואמרו לי באיזה סוג מכונה להשתמש.

לפני שיוצרים את ה-tasks, לפני שמגדירים איך לעשות deploy ל-instance של מיקרו-סרביס, צריך להקים docker repository. שלשם אני דוחף את האימג׳ים של המיקרו סרביסים שלי.

Some Terms:  
Provisioning Model: On-Demand v.s. Spots  
EC2 Cluster  
Instance Type: m6ld.large, m6ld.xlarge, m6ld.2xlarge, m6ld.4xlarge, m6ld.8xlarge, metal, t2.micro  
Default image: Amazon Linux 2  
Cloud Formation  
Auto Scaler

---

## **נושא 3: איך לדבר על עקרונות של Web Security**

בעולם של היום אבטחה זה משהו שהוא לא נייס טו הב, אלא זה משהו שהוא מאסט הב. כי בסוף זה... האבטחה של הלקוחות שלנו. ואנחנו רוצים שיהיה להם אמון בנו, ובאיכות של המוצר שלנו, וחבל שבגלל דבר כזה כל המוצר שלנו, כל העבודה הקשה שלנו תרד לפח.  
אז יש חולשות שכיחות שמפתחי פרונט צריכים להתמודד איתן.  
מה זה CSP  
מה זה CORS  
מה זה Secure Storage, למשל cookies או localstorage או indexDB.  
ובסה״כ יש רק כמה צעדים שאני חושב שהם יחסית די פשוטים למימוש, אפשר להגיע לאיזושהי רמה של אבטחה התחלתית לאפליקציה שלנו.

### - חולשה 1: CSRF

חולשה ראשונה שאפשר לדבר עליה היא CSRF.  
או... Cross Site Request Forgery.  
בגדול מה שהחולשה הזאת אומרת היא שה... האקר יכול להתחזות אליי, כלומר לגנוב את הזהות שלי, ולבצע בקשות בשמי.  
אם נדמיין איזשהו API מרוחק, ועכשיו אותו האקר השיג איכשהו את ה-userID שלי, והוא שולח בקשות לשרת עם ה-userID שלי. והוא יכול לעשות פעולות.  
פתרונות לחולשה - איך אנחנו מונעים כזה דבר? מה המנגנון למניעה של דבר כזה?

**-- פתרון 1: לייצר טוקן ולשמור אותו ב-cookie**

השרת בעצם מייצר טוקן. יש כאלה שיקראו לזה csrf token, יש כאלה שעשו את זה דרך JWT, אבל העיקרון הוא the same, יש לך איזשהו טוקן שהוא ייחודי, והוא ייחודי גם ל-session שלי ול-authentication שביצעתי באותו session. למעשה, אחרי תהליך login פשוט ומוצלח, השרת מחזיר לי תשובה, בצירוף טוקן. את הטוקן הזה השרת מצפה שנחזיר אליו בכל קריאה, וזו הדרך שלו בעצם לאמת שאנחנו אותה ישות שביצעה גם את ה-אות׳נתיקציה מולו. את ההתחברות מולו. מעבר ליצירה של הטוקן הזה, יש דברים שאנחנו בצד של הפרונט יכולים לעשות כדי למנוע שימוש בחולשה הזאת. בעצם ההמלצה היא שכשאנחנו מקבלים את הטוקן הזה, שאותו אנחנו אמורים לשלוח בכל קריאה, היא לשמור אותו בתוך cookie. ה-cookies שלנו חוזרים בקריאות אל השרת, ויש דברים שאנחנו יכולים לעשות עליהם כדי שלא יחזרו לכל אחד שירצה בהם, וגם כמובן שלא תהיה גישה ל-script׳ים זדוניים שאולי יוזרקו לעמוד.  
בעת השמירה בתוך cookies אנחנו נרצה להגדיר עליו כמה דברים:

- **להגדיר פרמטר של sameSite=strict.** מה שזה אומר זה שרק אותו דומיין שיצר את ה-cookie זאת אומרת השרת, הוא זה שיש לו גישה אליו. יותר נכון להגיד ש... מראש, אם הדומיין שאליו נשלחת בקשת http, הוא מדומיין אחר מזה שרשום, שחתום על ה-cookie, מראש ה-cookie הזה בכלל לא נשלח. הוא לא מצורף לבקשה.
- **להגדיר פרמטר של httpOnly=true.** פרמטר זה בעצם מונע גישה מה-javascrip לגשת לתוכן של אותו cookie. מה שהופך את ה-cookie הזה לנגיש רק דרך קריאות http, ויכול להישלח רק דרך header׳ים שאנחנו מגדירים. ואז ככה, גם אם מוזרק קוד זדוני, אין לו גישה. בניגוד ל-localStorageאם בעצם היינו שומרים את הטוקן ב-localStorage, ואיכשהו נכנס לנו קוד זדוני, בין אם דרך איזשהו extension ב-browser, או דרך חולשת xss, אז אותו סקריפט יכול לגשת ל-localStorage, למשוך את הטוקן, ועדיין לעשות קריאות מרוחקות בשמנו, מתוך אותו session שעכשיו אנחנו נמצאים בו.אבל, אם הטוקן שמור בתוך cookie, שמוגדר עם httpOnly, אין גישה ל-javascript.

_**פתרונות פחות טובים**_

**-- פתרון 2: חסימת דומיינים לא מורשים**

אנחנו יכולים לחסום דומיינים לא מורשים. אנחנו יכולים להגיד שדומיינים מ... מאתר אחר אולי, לא יכול לבצע קריאות. ואז גם אם בוצעה קריאה ממקום לא מוזהה אז אנחנו חוסמים אותה. בעצם אני מייצר whitelist של דומיינים מורשים, וכל מי שלא נמצא ב-whitelist הוא לא מורשה.

**-- פתרון 3: content type json only**

שהשרת יצפה לקבל אך ורק content type מסוג json כי למשל form לא יכול לשלוח content type json, אלא הוא צריך קריאות ajax. זה עוד דרך טיפה לצמצם את זה, אבל... הכי טוב והכי מומלץ זה להשתמש בטוקן שחוזר מהשרת, לשמור את זה ב-cookie ולשים על זה flag של secure true ו-http only true, וכמובן same site strict.

### - חולשה 2: XSS

חולשה שנייה שיש לנו היא xss, שזה בעצם cross site scripting.  
בעצם ע״י inject, הזרקה של סקריפט לאתר, ניתן להכניס קוד שהוא זדוני ולפגוע במשתמש. שימושים שכיחים ל-xss הם:

- התחזות למשתמש מסוים, ניתן לבצע פעולות שהמשתמש רשאי להם.
- שינוי פני האתר, ע״י מניפולציה של ה-dom, להזריק תמונות, css, וכדומה.
- גישה להיסטוריית הדפדפן ול-clipboard, אם שמרתי דברים אצלי באותו session.
- סריקה וניצול של מכשירים או יישומים שמחוברים ב-bluetooth.

פתרונות לחולשה - איך אנחנו יכולים להתגונן מפני xss?  
יש כמה צעדים פשוטים שכדאי לממש.

**-- פתרון 1: סניטציה**

הצעד הראשון הוא סניטציה. אנחנו צריכים לרשום איזושהי פונקציה שעושה סניטציה ובעצם מוחקת תגיות html או attributes שאינם מורשים, ומשאירה לנו רק את ה-string הנקי.

**-- פתרון 2: שימוש ב-CSP**

ראשי תיבות של Content Security Policy  
בגדול? אנחנו יכולים להגדיר csp דרך header׳ים שחוזרים מהשרת, או דרך תגית מטא אפילו ב-html. מה המטרה? המטרה היא להגיד לדפדפן איזה assets הוא יכול לטעון בתוך האתר שלנו, זאת אומרת אילו assets הוא מורשה גם לפי הסוג, וגם לפי מאיזה מקור הם באים. זאת אומרת אני יכול להגיד לו שתמונות הוא יטען רק מה-domain שלי, וסקריפטים מרוחקים אני יכול להביא מ... גם משלי אבל גם מעוד דומיינים. סתם לדוגמא, לטעון את ה-google analytics בעמוד שלנו.  
אם יש לנו csp אנחנו נרצה להכניס את הדומיין של גוגל כחלק מהסקריפטים שהאתר שלנו יכול לטעון. למה אנחנו עושים את זה?  
אם במידה יש לנו איזה תוקף שרוצה להזריק לנו קוד זדוני או תמונות או וואטאבר, וזה ממקור מרוחק, או ממקור שהוא לא מורשה, אז בעצם הדפדפן יחסום את זה.  
וככה אנחנו מצמצמים אפשרות לנצל חולשת xss אצלנו באתר.

**-- פתרון 3: שימוש ב-document.createTextNode**

בעצם ברגע שאנחנו מגדירים ב-typescript או ב-javascript פונקציה שמחזירה כל אלמנט html׳י, כ-native text, למעשה אנחנו סוגרים את הנושא ומגינים עלינו מפני תקיפת xss. כי אם יש לנו תגית שמתחבאת בתוך ה-string, ברגע שנעביר אותה דרך פונקציה של createTextNode, זה יחזיר לנו משהו שאנחנו יכולים ב-100% ביטחון להכניס ל-dom, אבל זה יהיה טקסט פשוט, as-is.

**-- פתרון 4: שימוש בתגית ה-template**

תגית ה-template מונעת בעצם ריצה של חלק מהאלמנטים, ביניהן תגיות script ו-event attributes, למשל onclick, או onload או on error, וכך ניתן לדחוף קוד html מבלי בעצם לחשוש שאפשר לעשות inject לאיזשהו סקריפט זדוני.

**-- פתרון 5: שימוש ב-html entities**

יש אפשרות להפוך ערך סטרינג למה שנקרא html entities. מה זה html entities?  
זה כל הישויות שמתחילות ב-ampersand ונגמרות בנקודה פסיק.

דוגמאות:

| Entity | Typing  |
| ------ | ------- |
| &nbsp; | &nbsp ; |
| &lt;   | &lt ;   |
| &gt;   | &gt ;   |

עכשיו ספציפית הסימן של ה-less than (`<`) הוא אולי החשוב ביותר, כי הוא מייצג את ההתחלה של כל תגיות ה-html.  
למעשה הפתרון אומר, תעביר את הסקריפט דרך פונקציה, שכל מה שהיא עושה זה היא מזהה את הסימן הזה של קטן שווה, וממירה אותו ל-html entity המתאים, ואז ככה אנחנו בעצם מונעים מהסטרינג להיות html element, בכך שאתה הופך אותו לטקסט רגיל.  
עכשיו... לא הרבה יודעים, אבל ה-framework׳ים שאנחנו משתמשים בהם יום יום, עושים את זה עבורינו מה שנקרא on-the-fly. זה כבר קיים בתוך ה-react, ב-vue, ב-angular, וכ״ו.  
למשל, דוגמא קטנה, אם אתה רוצה לעקוף את זה ב-react, אתה תצטרך להשתמש באיזשהו prop שנקרא dangerouslySetInnerHtml או משהו כזה, לא זוכר בדיוק את השם, אבל הדגש הוא שיש שם את המילה dangerous.  
וזה לא סתם! זה כי ריאקט רוצים להזהיר אותך ״אתה בעצם עומד להכניס פה inner html, לתוך הקומפוננטת ריקאט שלך, ו-react לא הולכת להעביר עליו לא סניטציה, לא המרה ל-html entities, כלום. זה הולך להיכנס ל-dom... כאלמנט! היא בעצם מזהירה אותך מפני מצבים של xss. היא בעצם אומרת לך במילים אחרות: ״תקשיב... כשאתה עובד בגישה של inner html אתה עוקף את ה-framework, ועושה איזשהו סוג של vanilla javascript, אז שתדע שיש פה סכנה מבחינת web security, ושאתה חשוף פה לאיזושהי חולשה שהיא xss״.

### - חולשה 3: cors

ראשי תיבות של cross origin resources sharing  
זה cors זה איזשהו מכניזם של הדפדף שבעצם מונע קריאות מרוחקות שלא מהדומיין שלנו.  
הקונפיגורציה למעשה קורית בשרת, וצריך לוודא שה-access control על ה-origin הוא בלי ה-wild card של הכוכבית, שזה למעשה מאפשר קריאה מכל דומיין, ובעצם חושף אותנו לחולשות.  
במה זה עוזר? זה עוזר לנו בזה שזה מצמצם את האפשרות שמקומות... או דומיינים לא מורשים, בכלל יפנו אלינו. אז מספיק... עצם העובדה שלא יכולים לפנות אלינו ממקורות מסויימים, זה כבר מצמצם את האפשרות שינצלו איזושהי חולשה אצלנו.

### - חולשה 4: Web Storage Security

כיצד ניתן לאבטח את ה-web storage שלנו?  
ה-storage הכי שכיח בדפדפן הוא ה-localStorage, cookies, יש גם אפילו indexDB.  
ויש כמה טיפים שחשוב לשים על השולחן.  
אז כמובן, לא לשמור פרטים אישיים, סיסמאות, וואטאבר, בתוך ה-localStorage.  
כי בסופו של דבר ה-localStorage זמין לכל סקריפט שרץ בעמוד.  
אם האקר הצליח להזריק לנו סקריפט מרושע לאתר, אז יש לו גישה חופשית מה שנקרא ל-localStorage.  
אותו דבר דרך cookies. אבל העניין הוא... ש-cookies אנחנו כן יכולים להחיל עליהם איזשהם פרמטרים שיכולים לצמצם ואפילו ממש להגביל את הקריאה של התוכן שלהם.  
פרמטרים אלו הם:

- למשל same site: שיהיה שווה ל-strict ואז בעצם ה-cookie הזה לא עובר, לא נשלח בכלל, בקריאות שהם לא מהדומיין/מהשרת ששמר אותם.
- למשל secure: פלאג כזה שאומר שה-cookie הזה יכול לעבור רק דרך קריאות שהן https, ועל https אין צורך לדבר נכון? שזה פרוטוקול שמצפין את התקשורת שלנו עם השרת, ואז בעצם אין אפשרות לניצול של אה... חולשה שנקראת the man in the middle, שזה בעצם מישהו שעומד בתווך ויכול לקרוא את המידע שהעברנו.
- למשל httpOnly: עוד attribute שחוסם גישה ל-javascript לקרוא את התוכן של ה-cookie. אין, הוא חסום. לא ניתן למניפולציה.

וכמובןןןןן!

שמעל כל זה, חשוב שאם יש מידע מסווג, שמאיזושהי סיבה החלטנו לשמור אותו אצלנו בדפדפן, אז אולי אפילו להעביר אותו דרך איזשהו מנגנון של encryption, או hashing, ש... בסופו של דבר גם אם מישהו ישיג את ידיו על המידע הזה, הוא לא יצליח להבין בכלל מה יש בפנים.

### - חולשה 5: Secure Communication

http v.s. https  
חשוב גם שנציין את העניין של secure communication.  
נושא ה-https שהיום הוא כבר סטנדרט, כל עניין הפרוטקול http ו-https, היום הרוב המוחלט של האתרים יושבים על דומיינים מאובטחים של https, בעצם מונע ציתות למידע בדרך שעובר אל השרת.  
והיום אפילו רוב הדפדפנים באתרים שיש בהם סליקה, אשראי, payment והתחברות אות׳נטיקציה, מודיעים ליוזר ״תקשיב, האתר עובד בפרוטוקול http, הוא לא מאובטח, וקח את זה בחשבון, כי אתה חשוף והפרטים שלך חשופים״. עכשיו נכון, המילה ״חשופים״ פה היא קצת מטעה, זה פשוט יותר זה שהדפדפן מתריע ״שמע, יכול להיות לך פה אפשרות לניצול של חולשה, שנקראת man in the middle, שמישהו יכול להאזין בתווך, ולקרוא את הנתונים שאתה שולח״.

### - חולשה 6: אות'נטיקציה וסיסמאות

שהסיסמאות יהיו מורכבות מ-:

- כל מיני סוגים של תווים.
- שיהיו באורך יחסית גדול.
- ולידציה חייבת להיות בשני הצדדים, גם בפרונט גם בבק ובעיקר בבק.
- סיסמא בצד של השרת חייבת לעבור הצפנה, איזשהו hashing, כדי שגם אם התוקף יצליח לשים את ידיו על המידע בתוך הבסיס נתונים, הוא עדיין לא יוכל לפענח את המידע הרגיש הזה.
- במידה ואנו מרשים סיסמאות ״מקלות״ (למשל רק אותיות, ובכל אורך) ניתן ואף רצוי לעשות שימוש ב-salt, כדי להקשות על התוקף בפענוח סיסמאות, כי אנשים הם לא מתוחכמים, וכולים לשים סיסמא פשוטה ומטומטמת ונפוצה, ותוקף יוכל לגלות pattern׳ים של הצפנה בזכות זה. תוספת של salt תוסיף התמודדות לתוקף, ותקשה עליו לבצע משהו שנקרא rainbow pattern.

---

## **נושא 4: איך לדבר על רידאקס (Redux)**

- למה צריך ריאקס? מה היתרון הגדול שלו?  
  היתרון הגדול של רידאקס זה להבטיח קונסיסטנטיות.  
  רידאקס... צריך להבין קודם כל ש... רידאקס זאת לא ספרייה.  
  רידאקס זה Design Pattern.  
  יש לך actions, ויש לך dispatchers ואתה עושה dispatch ל-actions.  
  ויש לך store, ויש לך slice׳ים של אותו store, ויש לך את ה-reducer.  
  זה יותר pattern מאשר ספרייה.  
  ומה זה נותן? זה נותן ש....  
  כשיש לך code base גדול , והרבה הרבה אנשים עובדים עליו, אתה תהיה בטוח ב-100% שכולם עוקבים אחרי המתכון הזה, אחרי אותו סט חוקים, אפילו אם זה boiler plate׳י, פשוט מאוד כי זה מבטיח קונסיסטנטיות.
- בהשוואה של Redux מול Context  
  הרבה פעמים אוהבים להשוות ביניהם.  
  יש מאמר שלם על זה על בחור שמתעבצן על עצם ההשוואה בכלל.  
  והוא אומר:  
  !context הוא לא כלי לביצוע state management  
  הוא כלי לביצוע Dependency Injection!  
  שהמטרה שלו היא להפוך single value לנגיש, עבור nested tree של קומפוננטות ריקאט. ההחלטה היא שלך לגבי מהו אותו single value, ואיך לייצר אותו, ולרוב אתה כנראה תשמור אותו בתוך useState, כך שלמעשה... אתה מבצע את כללל ה-state management בעצמך, ו-context פשוט נותן לך דרך להעביר אותו במורד העץ ריאקט שלך.

---

## **נושא 5: איך לדבר על LuckyLove**

לאקי לאב זה אתר היכרויות שבניתי.  
לא במסגרת לימודים, לא במסגרת קורס.  
ואני בכוונה מדגיש, כי יש קורסים כאלה של ארבעה חמישה חודשים, שבסוף אומרים לך, ועכשיו בואו נבנה ביחד פרויקט, ואתם פשוט תעשו קופי פייסט בלי שתבינו כלום.  
אז זה לא כזה.

לאקי לאב הוא אתר היכרויות קלאסי, שבנוי על:

- react בפרונט
- node בבקאנד
- mongodb זה הדאטה בייס
- מאותחל עם vite
- pnpm זה ה-package manager
- כל הפרויקט הוא monorepo
- ספריית עיצוב היא tailwindcss
- יש התממשקות CI/CD עם circleCI
- unit tests עם vitest
- e2e tests עם playwright
- יש ללאקי לאב גרסה אחת שהיא מונולית׳, שהיא הגרסה המתוחזקת ביותר.
- יש גם גרסה פחות מתוחזקת נכון להיום שהיא ב-micro services, עם דוקר וקוברנטיס, ו-helm. אבל זה היה באמת יותר לצורך לימודי. יש המון אתגרים בעבודה עם מיקרו סרביסים.
- ואת הדיפלוי... אז... פעם כשהירוקו עוד היה בחינם, הייתה לי פריסה שם. אחר כך הייתה לי פריסה ב-GCP עד שנגמר לי ה-free lease איתם. ששם בעצם אתה מקבל מכונה לינוקסית, ריקה, תתקין עליה מה שאתה צריך ותחשוף את האפליקציה איך שאתה מכיר. אז אני בחרתי בכלי שאולי אתה מכיר, שנקרא pm2. היה לי קובץ קונפיגורציה שכתבתי עבור השרת. הייתה לי גם קונפיגורציית nginx בסיסית אך טובה, שגם תומכת ב-web sockets.

מה שחשוב להבין לגבי הפרויקט הזה זה שהוא.... פרויקט לימודי.

ברובו הגדול, פיתחתי דברים from scratch, ולא השתמשתי בעזרתם של ספריות.  
למשל:

- _**Internationalizaion**_: אז יש ספריות כמו react-intl ו-i18next שיצא לי להשתמש בהן במסגרת העבודה. ודווקא בפרויקט הזה בחרתי לממש בעצמי.
- _**Formik**_: ספרייה לניהול form׳ים. והרצת ולידציות על שדות. גם, מימשתי לזה גרסה משלי.
- _**Infinite Scroll**_: בעמוד הגלריה הראשי, פעם זה היה pagination, זה עבר להיות infinite scroll עם virtualized rows.
- _**Authentication**_: עזוב, אני מדבר איתך ברמה שאת האות׳נטקציה מימשתי בעצמי. שפה אם אתה מכיר, יצא לך לממש login ו-register? זה שאתה שולח, מעבר לכל מיני פרטים אישיים וכאלה, שם משתמש או אימייל, פלוס סיסמא, שולח בקשת http לשרת, ככל הנראה post, מוודא שאין אימייל כזה במערכת, במדיה ואנחנו מדברים על register, לוקח את הסיסמא, מייצר עבורה salt ייחודי, ככל הנראה באורך של 8 בתים או 10, בשביל שתהיה אבטחה סבירה, וביחד עם ה-salt משתמש ב-scrypt, פונקציה נטיבית של node מתוך המודול המובנה של crypto, כדי להצפין אותה, ואז את ה-hashed passward שומר ב-db, יחד עם ה-salt שעזר לייצר אותו. זה כדי שאם תוקף פוטנציאלי איכשהו קיבל גישה ל-db שלי, לכל הפחות הוא לא יידע מה הסיסמא ה-raw של היוזר שאותה בחר, וזה יקשה עליו. מהצד שלל ה-login, אתה כבר מבין לבד את המשמעות...... משתמש מזין אימייל וסיסמא, אני מחפש את היוזר, בהתחלה מבלי להתייחס לסיסמא, אני מחפש התאמה לפי אימייל, מוצא יוזר, שולף אותו, ומבקש ב... בשדות להחזרה, שיחזור גם השדה של ה-hashed password וגם השדה של ה-salt, כי אני צריך אותו, כי עכשיו אני הולך לעשות decrypt, ל-raw password פלוס ה-salt, וביחד אני אצפה לקבל כפלט את אותו hashed password שנשמר ב-db.

#############

עכשיו לא אמרתי, אבל גם אחרי login מוצלח, וגם אחרי register מוצלח, כלומר יצירה מוצלחת של יוזר חדש, השרת שולח חזרה ללקוח טוקן. ואת הטוקן הזה אני מצפה שתזחיר לי בכל בקשה שאתה מבצע, שדורשת אות׳נטיקציה, כדי שאני אוכל לדעת, שאתה באמת אותה ישות שעבורה יצרתי את הטוקן הזה. את הטוקן הזה אני שומר ב-WebStorage הכי מאובטח שאני יכול לחשוב עליו, והוא כמובן ה-cookie. ובוודאי שלא ב-localStorage. על ה-cookie אני מגדיר httpOnly, כדי למנוע מסקריפטים זדוניים לגשת לי ל-cookie, אין גישה! רק בהעברות http יש גישה לקרוא את התוכן של ה-cookie. בנוסף לזה אני מוסיף לו פרמטר של sme site ואומר לו אתה strict, זאת אומרת ש... רק הדומיין שיצר את ה-cookie הוא היחיד שמורשה לגשת אליו. הוא נשלח רק בבקשות שמכילות את הדומיין של השרת שיצר אותו. ועל זה תוסיף גם פרמטר של secure, שזה פלאג שאני שם אותו על true, כדי לוודא שה-cookie הזה נשלח רק כאשר החיבור, פרוטוקול החיבור הוא https ולא http.

- _**Responsiveness**_: האתר הוא רספונסיבי לחלוטין
- _**Code Splitting**_: יש לי שימוש די נרחב ב-code splitting, היום אני משתמש ב-react lazy loading . פעם השתמשתי ב-@loadable/Components. והייתה תקופה שקמה ספרייה שנקרא react-loadable של ג׳יימס קייל, שבסוף הפרויקט הזה ננטש, והיום הוא no longer maintained.
- _**Optimistic Updates**_: כשאני שולח הודעה למשתמש אחר, היא צריכה לעבור בשרת ולעבור כל מיני ולידציות, וזה לוקח זמן. בינתיים, ליוזר השולח, אני מציג כאילו בועת message רגילה, כאילו שההודעה לו כבר נשלחה, כדי ליצור לו את הרושם שהאתר שלי הוא blazing fast, וכשחוזרת הבקשה מהשרת, בין אם היא חיובית או שגיאה, אני עושה match עם אותה בועית פיקטיבית, ומחליט מה לעשות איתה. אם היא הייתה פיקטיבית אני עכשיו מעביר אותה להיות תמידית, ואם הבקשה נכשלה, אז אני מסמן אותה באדום, מרעיד אותה לאיזה שנייה וחצי, ורק אז אני מעלים אותה. אפקט נחמד כזה. קראתי לזה shake.

מה האתר מכיל: נכנסים אליו,

- יש דף נחיתה, קצת אנימציות,
- יש register, הרשמה של יוזר חדש,
- ונגזרת של זה, זה יש login,
- יש עמוד שמציג את כלל המשתמשים באתר,
- יש עמוד שמציג יוזר ספציפי,
- יש עמוד שהוא חיפוש משתמש לפי הגדרה של פרמטרים,
- יש עמוד שדרכו מתאפשר ליוזר לעדכן ולערוך פרטים אישיים, שגם העמוד הזה בעצמו מחולק ל-4 מיני עמודים:
  - מיני עמוד עם פרטים יבשים עליי (בן כמה אני, מאיפה אני, מה הגובה שלי)
  - מיני עמוד עם התמונות שלי, שם אני יכול להעלות עד 4 תמונות.
  - מיני עמוד עם ההעדפות שלי בבן/בת הזוג, (מהיכן בארץ, טווח גילאים, טווח גובה)
  - ומיני עמוד עם הגדרות חשבון (אל תשלח לי הודעות, כן תשלח לי הודעות, רכישה של מנוי)
- עמוד שמציג את כל האפשרויות למנוי: מנוי זהב, מנוי כסף מנוי ארד. (פרימיום)
- עמוד רכישה של מנוי, עם הכנסה של פרטי אשראי או אמצעי תשלום כזה או אחר.
- וכמובן עמוד היסטוריית הרכישות שלי.

יש עוד המון דברים לעבוד עליהם בלאקי לאב, אין סוף.

---

## **נושא 6: איך לדבר על SSR**

ב-expoint זאת הייתה אפליקציה למעסיקים למצוא עובדים,  
ולמחפשי עבודה למצוא מקום עבודה.

אתר כזה, שהוא לא אפליקציית sass שאתה מוכר לחברות,  
אלא הוא... אתר שאתה רוצה שיהיה נגיש, או שיהיה קל למצוא אותו אפילו כשאתה לא מחפש אותו מפורשות על פי השם שלו, אלא שאם נגיד אתה מחפש את צמד המילים ״עבודה בהייטק״, שהוא יופיע לך גבוה בתוצאות החיפוש. דבר כזה הוא אפשרי בגלל דירוג אתרים שנקרא דירוג page.  
שנותן לך ציון ע״פ אם עקבת אחרי כל מיני guide lines כאלה ואחרים, שחלקם ידועים, וחלקם זה פשוט ניחושים best guess, נותן לך ציון בסוף של מ-0 עד 10.  
איך הוא עושה את זה?  
איך גוגל מדרגים אותך?  
הם שולחים לאתר שלך crawler׳ים, שמבצעים בעצם סריקה על האתר, כדי לבדוק מה התוכן שהוא מכיל, והוא חוזר לגוגל, למאגרים של גוגל, ומעדכן מה הוא מצא באתר שלך.

אז בגלל האופי של אתר כזה, שמנו המון דגש על SEO, שזה search engine optimization.

עכשיו הבעיה עם react, היא ש...  
מצד היופי בריאקט זו גם הבעיה שלו.  
ריאקט שולח קובץ html ריק לאתר, טוען את מנוע הריאקט, מתרגם כל מיני jsx׳ים שכתבנו, ואז ממלא את קובץ ה-html.  
מה הבעיה בזה?  
שעד שהמנוע של ריאקט עולה, כבר ה-crawler הוא מזמן.... long gone.  
ומה שהוא מדווח חזרה למאגרים של גוגל, זה... מצאתי html ריק, אין באתר הזה כלום.  
דירוג 0.

ובגלל זה היה לנו צורך לממש את האתר ב-SSR, או בשם המלא server side rendering.  
ssr אומר, השרת יבצע את הרנדור הראשוני,  
ובמקום לשלוח html ריק, אני כבר שולח html מלא, מוכן, עם כל המידע שה-crawler רוצה, שהוא יהיה מרוצה, ואני עושה לזה ship חזרה לקליינט.  
העניין הוא ש-ssr מסבך מאוד את הפיתוח.  
באותה תקופה, nextjs היה בחיתולים,  
והדרך לממש ssr הייתה לממש בעצמך את כל הלוגיקה from scratch,  
תוך שימוש ב-webpack ובקובץ קונפיגורציה שתפרנו במיוחד לצרכי האתר,  
וכמובן היה חייב טרנספיילר של babel שיעשה את כל ההמרה מ-es6 ל-commonjs.  
והתקנו פלאגינים כאלה ואחרים, שוב, בהתאם לצורך שהיה לנו,  
אם זהס למשל css minification אז היה לזה פלאגין מאוד מפורסם שהיום אני כבר לא זוכרק את השם שלו. ופלאגין כזה שיודע לשתול את כל הטאגים ב-html, אפילו אחרי שהם עברו hashing.  
וכמובן, HMR, שהיה צריך לממש בעצמך, עד לרמה מסוימת, ששם אתה צריך להשתמש בכלי עזר ששוב, שכחתי את השם שלו, כי באמת עבר המון זמן מאז.  
בנוסף לזה, היה את כל העניין של איך קומפוננטה יודעת איפה היא מתרנדרת.  
האם עכשיו אתה מרנדר אותי אצל הקליינט, או עכשיו אתה מרנדר אותי בשרת.  
והיה צריך התייחסות מיוחדת לכל מקרה, מה שעוד יותר הקשה על הפיתוח.  
אבל שוב....  
כל האמצעים היו כשרים לצורך המטרה של - לממש server side rendering.  
ולמה?  
כי אנחנו רוצים שה-crawler׳ים של גוגל, שברגע שהם עושים סריקה על אתרים באינטרנט, שכשהם יגיעו לאתר שלנו, הם יקבלו ברנדר הראשון את כל המידע כבר מוכן

אם הייתי צריך לעשות פרויקט דומה היום? חד משמעית אני עובד עם nextjs, ובטח ובטח לא ממש את זה בעצמי. next השתכלל מאוד עם השנים, השנים עשו לו רק טוב.  
והם הכניסו react sever components, שזה בכלל אחלה פיצ׳ר.  
מה שכן? אמנם אני אשתמש ב-next, אבל כל אותם עקרונות שלמדתי אז, כנראה יעשו לי את המעבר ל-next הרבה הרבה יותר קל.  
לא יהיה צריך להסביר לי למשל, מה זה loader׳ים, ולמה אני צריך אותם כדי לטעון דאטה. וכולי וכולי.

הייתה לנו מערכת תשלומים  
חברה אחת ששילמנו לה, נתנו לנו רישיון, פלוס ספרייה להתקנה מקומית,  
שיש לה api שפונה לשרתים שלהם עם טוקן, ומבצעת תשלומים.  
אז לקחנו את ה-api שלהם, עטפנו אותו כאיזשהו קליינט שהאפליקציה מכירה,  
והאפליקציה מתקשרת עם הקליינט שאנחנו יצרנו, שכאמור עוטף את הספרייה שלהם.  
פשוט התאמנו את זה לצרכים שלנו.

ספריית עיצוב MaterialUI  
ספריית עיצוב לצערי עבדנו שם עם materialUI, באותם שנים זה היה חם חם, ואני שנאתי את זה מ-day one. וברוך השם, אחרי כמה שנים העולם הסכים איתי,  
ו-materialUI מתחיל במוות האיטי שלו, ולא רק הוא! כל החברים שלו, styled components, ואני כבר לא זוכר מי עוד שם ברשימה של הגרועים.  
והמחליף האולטימטיבי, איך לא - headless UI ! קונספט פרונטאנדי שאני אישית עף עליו.  
ואני כל כך אוהב לראות את התאוצה שזה תופס, עם ספרייה כמו radix, ו-react-table, שאומרים לך ״קח את הלוגיקה מאיתנו, העיצוב עליך!״  
אני חושב שזה חכם מאוד. אני גם מאוד מאמין בזה אישית, ומאוד מעודד לזה שככה דברים צריכים להיראות.

---

## **נושא 7: איך לדבר על Design Patterns**

- Strategy Pattern
- Bridge Pattern
- Dependency Injection

---

## **נושא 8: איך להגן על monolith מפני micro-services**

המאמר death by a 1000 micro-services הסרטון של the primegen
