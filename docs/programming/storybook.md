---
sidebar_label: '8. Storybook'
sidebar_position: 6
---

# Guide for Storybook

## 1. Getting started

### Introduction

Storybook scans your project and looks for files which end with .stories.js or .stories.ts. Notice how it has `stories` in it's path, in plural, to note that each file representing a component can export multiple stories. A \*.stories.js file defines all the stories for a component. Each story has a corresponding sidebar item in the Storybook app. When you click on a story, it renders in the Canvas an isolated preview iframe.

### A Component's Meta

Each `stories` file must have a Component's `Meta`, and export default it.  
The `meta` is simply a javascript object with properties.  
At the very least, the `meta` object must contain the `component` key, which points to the _actual_ component.

```js title="Button.stories.js"
import Button from './Button';

export default {
  component: Button
}
```

### Layout Centered

Another nice-to-have key inside meta is the `parameters.layout`, which tells Storybook where to render the component on the screen. By default, it renders it on the top-left, but it would be nice to have it centered, right?
To do so, simply add:

```js title="Button.stories.js"
import Button from './Button';

export default {
  component: Button,
  parameters: {
    // Optional parameter to center the component in the Canvas. More info: https://storybook.js.org/docs/react/configure/story-layout
    layout: 'centered',
  },
}
```

### A Story

```js title="YourComponent.stories.js"
import { YourComponent } from './YourComponent';

//ðŸ‘‡ This default export determines where your story goes in the story list
export default {
  component: YourComponent,
};

export const FirstStory = {
  args: {
    //ðŸ‘‡ The args you need here will depend on your component
  },
};
```

A `story` is merely a javascript object which hold an `args` key. combination of values for the component's props, which describes how to render the component.  
A `story` needs to be named-exported from the `*stories.js` file.  
A `story` with an empty as an object, will simply mean that all the component's props are undefined.  
The _variable name_ holding the `story` will be the name presented in the Storybook app, describing that `story`, so it's a good idea to have it uppercased.
If a stories.js file does not export a single story, no visuals of that component would appear in the Storybook app. It would be like the component doesn't even exist.

### Docs

The "Docs" page displays auto-generated documentation for components (inferred from the source code). Usage documentation is helpful when sharing reusable components with your team, for example, in an application.

### Storybook & Tailwind

To have Storybook and tailwind working together is rather simple.  
All Storybook needs is a css, generated by tailwind as an output, as its input.  
That same css file needs to be imported in the `preview.js` configuration file of Storybook:

```js title=".storybook/preview.js"
import '../styles/tailwind.css';

/** @type { import('@storybook/react').Preview } */
const preview = {
  parameters: {
    actions: { argTypesRegex: '^on[A-Z].*' },
    controls: {
      matchers: {
        color: /(background|color)$/i,
        date: /Date$/i,
      },
    },
  },
};

export default preview;
```

This will make Tailwindâ€™s style classes available to all of your stories.  
To generate that css file with tailwind, all you gotta do is wrote a script that does so:

```json title="package.json"
{
  "pre-storybook-prod": "npx tailwindcss -o ./styles/tailwind.css --minify"
}
```

This is for production.  
For development, you would most-likely want a `watch` version of that script, so that you could make changes to the source code, and see changes in real-time:

```json title="package.json"
{
  "pre-storybook-dev": "npx tailwindcss -i ./src/index.css -o ./styles/tailwind.css --watch"
}
```

### Storybook With Dark Mode

First of all, update your tailwind.config.js file to change themes based on a class or data-attribute. This example uses a data-attribute.

```js title="tailwind.config.js"
module.exports = {
  content: ['./src/**/*.{js,jsx,ts,tsx}'],
  // Toggle dark-mode based on .dark class or data-mode="dark"
  darkMode: ['class', '[data-theme="dark"]'],
  theme: {
    extend: {},
  },
  plugins: [],
};
```

Next, install the @storybook/addon-themes addon to provide the switcher tool.

```bash
npm i -D @storybook/addon-themes
```

Then, add following content to .storybook/main.js:

```js title=".storybook/main.js"
export default {
  addons: ['@storybook/addon-themes'],
};
```

**Toggle themes by class name**

Add the withThemeByClassName decorator to your Storybook from @storybook/addon-themes:

```js title=".storybook/preview.js"
import { withThemeByClassName } from '@storybook/addon-themes';

/* snipped for brevity */

export const decorators = [
  withThemeByClassName({
    themes: { light: 'light', dark: 'dark' },
    defaultTheme: 'light',
  }),
];
```

**Toggle themes by data-attribute**

Add the withThemeByDataAttribute decorator to your Storybook from @storybook/addon-themes:

```js title=".storybook/preview.js"
import { withThemeByDataAttribute } from '@storybook/addon-themes';

/* snipped for brevity */

export const decorators = [
  withThemeByDataAttribute({
    themes: {
      light: 'light',
      dark: 'dark',
    },
    defaultTheme: 'light',
    attributeName: 'data-mode',
  }),
];
```

### Override theme on the component level

```js title="Button.stories.js"
export default {
  parameters: {
    themes: {
      themeOverride: 'light', // component level override
    },
  },
}
```

### Context Providers

If a particular story has a problem rendering, often it means your component expects a specific environment is available to the component.

A common frontend pattern is for components to assume that they render in a specific "context" with parent components higher up the rendering hierarchy (for instance, theme providers).

Use decorators to â€œwrapâ€ every story in the necessary context providers. The .storybook/preview.js file allows you to customize how components render in Canvas, the preview iframe. See how you can wrap every component rendered in Storybook with Styled Components ThemeProvider, Vue's Fontawesome, or with an Angular theme provider component in the example below.

```js title=".storybook/preview.js"
import React from 'react';

import { ThemeProvider } from 'styled-components';

export default {
  decorators: [
    (Story) => (
      <ThemeProvider theme="default">
        {/* ðŸ‘‡ Decorators in Storybook also accept a function. Replace <Story/> with Story() to enable it  */}
        <Story />
      </ThemeProvider>
    ),
  ],
};
```

### Public - Static Serve

If you want to link to static files in your project or stories (e.g., /fonts/XYZ.woff), use the `-s path/to/folder` flag to specify a static folder to serve from when you start up Storybook. To do so, edit the storybook and build-storybook scripts in package.json.

We recommend serving external resources and assets requested in your components statically with Storybook. It ensures that assets are always available to your stories.

## 2. How to write Stories

### Meta

The default export metadata controls how Storybook lists your stories and provides information used by addons. For example, hereâ€™s the default export for a story file Button.stories.js|ts:

```js title="Button.stories.js"
import { Button } from './Button';

export default {
  component: Button,
};
```

:::info
Starting with Storybook version 7.0, story titles are analyzed statically as part of the build process. The **default** export must contain a _title_ property that can be read statically or a component property from which an automatic title can be computed. Using the id property to customize your story URL must also be statically readable.
:::

## Defining stories

Use the named exports of a file to define your componentâ€™s stories. We recommend you use UpperCamelCase for your story exports. Hereâ€™s how to render `Button` in the "primary" state and export a story called `Primary`.

```js title="Button.stories.js"
import { Button } from './Button';

export default {
  component: Button,
};

/*
 *ðŸ‘‡ Render functions are a framework specific feature to allow you control on how the component renders.
 * See https://storybook.js.org/docs/api/csf
 * to learn how to use render functions.
 */
export const Primary = {
  render: () => <Button primary label="Button" />,
};
```

## Rename stories

You can rename a story to give it a more accurate display name within the Storybook. Here's how you can change the display name of a story:

```js title="Button.stories.js"
import { Button } from './Button';

/*
 *ðŸ‘‡ Render functions are a framework specific feature to allow you control on how the component renders.
 * See https://storybook.js.org/docs/api/csf
 * to learn how to use render functions.
 */
const Primary = {
  name: 'I am the primary',
  render: () => <Button primary label="Button" />,
};

export { Primary }

export default {
  component: Button,
};
```

## Actions to enhance args

Addons can enhance args. For instance, [Actions](https://storybook.js.org/docs/essentials/actions) auto-detects which args are callbacks and appends a logging function to them. That way, interactions (like clicks) get logged in the actions panel.

## Using the play function

... complete this part...

Storybook's play function and the [@storybook/addon-interactions](https://storybook.js.org/addons/@storybook/addon-interactions) are convenient helper methods to test component scenarios that otherwise require user intervention. They're small code snippets that execute once your story renders. For example, suppose you wanted to validate a form component, you could write the following story using the play function to check how the component responds when filling in the inputs with information:

```js title="LoginForm.stories.js"
import { userEvent, within } from '@storybook/testing-library';

import { expect } from '@storybook/jest';

import { LoginForm } from './LoginForm';

export default {
  component: LoginForm,
};

export const EmptyForm = {};

/*
 * See https://storybook.js.org/docs/writing-stories/play-function#working-with-the-canvas
 * to learn more about using the canvasElement to query the DOM
 */
export const FilledForm = {
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);

    // ðŸ‘‡ Simulate interactions with the component
    await userEvent.type(canvas.getByTestId('email'), 'email@provider.com');

    await userEvent.type(canvas.getByTestId('password'), 'a-random-password');

    // See https://storybook.js.org/docs/essentials/actions#automatically-matching-args to learn how to setup logging in the Actions panel
    await userEvent.click(canvas.getByRole('button'));

    // ðŸ‘‡ Assert DOM structure
    await expect(
      canvas.getByText(
        'Everything is perfect. Your account is ready and we should probably get you started!'
      )
    ).toBeInTheDocument();
  },
};
```

Without the help of the play function and the @storybook/addon-interactions, you had to write your own stories and manually interact with the component to test out each use case scenario possible.

## Using parameters

Parameters are Storybookâ€™s method of defining static metadata for stories. A storyâ€™s parameters can be used to provide configuration to various addons at the level of a story or group of stories.

For instance, suppose you wanted to test your Button component against a different set of backgrounds than the other components in your app. You might add a component-level backgrounds parameter:

```js title="Button.stories.js"
import { Button } from './Button';

export default {
  component: Button,
  //ðŸ‘‡ Creates specific parameters for the story
  parameters: {
    backgrounds: {
      values: [
        { name: 'red', value: '#f00' },
        { name: 'green', value: '#0f0' },
        { name: 'blue', value: '#00f' },
      ],
    },
  },
};
```

## Using decorators

Decorators are a mechanism to wrap a component in arbitrary markup when rendering a story. Components are often created with assumptions about â€˜whereâ€™ they render. Your styles might expect a theme or layout wrapper, or your UI might expect specific context or data providers.

A simple example is adding padding to a componentâ€™s stories. Accomplish this using a decorator that wraps the stories in a `div` with padding, like so:

```js title="Button.stories.js"
import { Button } from './Button';

export default {
  component: Button,
  decorators: [
    (Story) => (
      <div style={{ margin: '3em' }}>
        {/* ðŸ‘‡ Decorators in Storybook also accept a function. Replace <Story/> with Story() to enable it  */}
        <Story />
      </div>
    ),
  ],
};
```

## Component level args

You can also define args at the component level; they will apply to all the component's stories unless you overwrite them. To do so, use the args key on the default export:

```js title="Button.stories.js"
import { Button } from './Button';

export default {
  component: Button,
  //ðŸ‘‡ Creates specific argTypes
  argTypes: {
    backgroundColor: { control: 'color' },
  },
  args: {
    //ðŸ‘‡ Now all Button stories will be primary.
    primary: true,
  },
};
```

## Global level args

You can also define args at the global level; they will apply to every component's stories unless you overwrite them. To do so, define the args property in the default export of preview.js:

```js title="Button.stories.js"
export default {
  // The default value of the theme arg for all stories
  args: { theme: 'light' },
};
```

:::tip
For most uses of global args, globals are a better tool for defining globally-applied settings, such as a theme. Using globals enables users to change the value with the toolbar menu.
:::
