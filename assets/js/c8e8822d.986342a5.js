"use strict";(self.webpackChunkdocusaurus_guides=self.webpackChunkdocusaurus_guides||[]).push([[4891],{6530:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>a,default:()=>c,frontMatter:()=>l,metadata:()=>o,toc:()=>h});var i=t(1527),s=t(7252);const l={sidebar_label:"20. CSS",sidebar_position:19},a="Guide For CSS",o={id:"programming/css",title:"Guide For CSS",description:"1. Flexbox",source:"@site/docs/programming/css.md",sourceDirName:"programming",slug:"/programming/css",permalink:"/guides/docs/programming/css",draft:!1,unlisted:!1,editUrl:"https://github.com/talkohavy/guides/docs/programming/css.md",tags:[],version:"current",sidebarPosition:19,frontMatter:{sidebar_label:"20. CSS",sidebar_position:19},sidebar:"tutorialSidebar",previous:{title:"19. ELK",permalink:"/guides/docs/programming/elk"},next:{title:"999. New guide template",permalink:"/guides/docs/programming/new-guide-template"}},r={},h=[{value:"<strong>1. Flexbox</strong>",id:"1-flexbox",level:2},{value:"- A. Defaults of Flexbox",id:"--a-defaults-of-flexbox",level:3},{value:"- B. Flex items Behavior",id:"--b-flex-items-behavior",level:3},{value:"- C. Flex Shrink",id:"--c-flex-shrink",level:3},{value:"- D. Flex Grow",id:"--d-flex-grow",level:3},{value:"- E. Flex Wrap",id:"--e-flex-wrap",level:3},{value:"- F. What is flex: 1?",id:"--f-what-is-flex-1",level:3},{value:"- G. align-self",id:"--g-align-self",level:3},{value:"- H. Flex Flow",id:"--h-flex-flow",level:3},{value:"- I. How is it calculated with padding &amp; margins?",id:"--i-how-is-it-calculated-with-padding--margins",level:3}];function d(e){const n={br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,s.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"guide-for-css",children:"Guide For CSS"}),"\n",(0,i.jsx)(n.h2,{id:"1-flexbox",children:(0,i.jsx)(n.strong,{children:"1. Flexbox"})}),"\n",(0,i.jsx)(n.h3,{id:"--a-defaults-of-flexbox",children:"- A. Defaults of Flexbox"}),"\n",(0,i.jsxs)(n.p,{children:["When giving an element a display of ",(0,i.jsx)(n.code,{children:"flex"})," there are some defaults given to that element."]}),"\n",(0,i.jsxs)(n.p,{children:["Here are the defaults of ",(0,i.jsx)(n.code,{children:"display: flex"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-css",children:".flexParent {\n  display: flex;\n  justify-content: flex-start;\n  align-items: stretch;\n  flex-direction: row;\n  gap: 0;\n  flex-wrap: nowrap;\n}\n\n.flexItem {\n  flex-shrink: 1;\n  flex-grow: 0;\n  flex-basis: auto;\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"--b-flex-items-behavior",children:"- B. Flex items Behavior"}),"\n",(0,i.jsxs)(n.p,{children:["As soon as you give an element a display of flex, all the ",(0,i.jsx)(n.code,{children:"display: block"})," stuff goes out the window. They are no longer display block/span, they are now what's called ",(0,i.jsx)(n.strong,{children:"flex items"}),", and they're behaving like flex items."]}),"\n",(0,i.jsx)(n.p,{children:"If you went to a flex item, and gave it a display block:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-css",children:".flexItem {\n  display: block; /* or inline */\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"absolutely nothing will happen! Of course, there's the exception of display none which would make them disappear."}),"\n",(0,i.jsxs)(n.p,{children:["One of the things that a flex item wants to do is it wants to be as small as it can be while maintaining everything in one line. There's a value known as ",(0,i.jsx)(n.code,{children:"max-content"}),", and what it does..."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-css",children:".someElement {\n  width: max-content;\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"is it tries to maintain text content in one line, and basically telling the element \"hey, you're not allowed to wrap\", and when all that text is in one line, then that's the element's width!"}),"\n",(0,i.jsxs)(n.p,{children:["There's another value known as ",(0,i.jsx)(n.code,{children:"min-content"}),", which allows for wrapping, and in this case the width of an element is determined by the longest single word."]}),"\n",(0,i.jsxs)(n.p,{children:["Both ",(0,i.jsx)(n.code,{children:"min-content"})," & ",(0,i.jsx)(n.code,{children:"max-content"})," play a role in flexbox, and so it's important to talk about them."]}),"\n",(0,i.jsxs)(n.p,{children:["When we do our display of ",(0,i.jsx)(n.code,{children:"flex"}),", each flex item is going to that ",(0,i.jsx)(n.code,{children:"max-content"})," size, and it's shrinking them down to the smallest size they can be, while maintaining ",(0,i.jsx)(n.code,{children:"max-content"})," - which means no wrapping allowed, no line-breaks. All that is true ",(0,i.jsx)(n.strong,{children:"if"})," all the flex items can fit the parent's size. When the parent runs out of room, flex items are allowed to create line-breaks, ",(0,i.jsx)(n.strong,{children:"until"}),"! until they can no longer shrink beyond their ",(0,i.jsx)(n.code,{children:"min-content"}),", and that's when we get a ",(0,i.jsx)(n.em,{children:"parent overflow"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"\u2022 Why do different children get different widths?"})}),"\n",(0,i.jsxs)(n.p,{children:["you might have come across it when you give a parent container element a display of ",(0,i.jsx)(n.code,{children:"flex"}),", and it has 3 children, and 2 of them get width X while the third one get a width of Y, and you're not sure why."]}),"\n",(0,i.jsxs)(n.p,{children:["To better understand this behavior try running a little experiment that mimics what flexbox is actually doing automatically behind the scenes. First, give all the flex items a ",(0,i.jsx)(n.code,{children:"flex-shrink"})," of 0, basically turning off the default behavior of 1. This is the first step flexbox is doing behind the scenes in order to calculate how big each flex item would be without the shrink on it. By giving each flex item a ",(0,i.jsx)(n.code,{children:"flex-shrink"})," of 0 you're essentially choosing by your own volition to overflow the parent element, providing each flex item a width of ",(0,i.jsx)(n.code,{children:"max-content"})," that disallows shrinking."]}),"\n",(0,i.jsxs)(n.p,{children:["The next step flexbox does is switch the value of ",(0,i.jsx)(n.code,{children:"flex-shrink"})," to 1. In this step, flexbox is taking the joint width of all the flex items combined, and by and fits it in the parent container, while shrinking each flex item relative to its ratio when it had ",(0,i.jsx)(n.code,{children:"flex-shrink"})," 1."]}),"\n",(0,i.jsx)(n.h3,{id:"--c-flex-shrink",children:"- C. Flex Shrink"}),"\n",(0,i.jsxs)(n.p,{children:["The default for ",(0,i.jsx)(n.code,{children:"flex-shrink"})," is 1.",(0,i.jsx)(n.br,{}),"\n","If we didn't have ",(0,i.jsx)(n.code,{children:"flex-shrink"})," enabled by default, and we were to turn it off:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-css",children:".flexItem {\n  flex-shrink: 0;\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["and now we tried shrinking the screen down, we immediately get a ",(0,i.jsx)(n.em,{children:"parent overflow"}),". Essentially, what this means is that flex item get their width set to ",(0,i.jsx)(n.code,{children:"max-content"})," size, and that's the size they are, and they are not allowed to shrink from that point on."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"flex-shrink"})," being set to 1 is a pretty good default, and if it were set to 0, we would have basically almost always turn it on manually."]}),"\n",(0,i.jsx)(n.h3,{id:"--d-flex-grow",children:"- D. Flex Grow"}),"\n",(0,i.jsxs)(n.p,{children:["The default for ",(0,i.jsx)(n.code,{children:"flex-grow"}),' is 0, which means "don\'t grow at all".',(0,i.jsx)(n.br,{}),"\n","The ",(0,i.jsx)(n.code,{children:"flex-grow"})," value can be more than 1, and starts this thing where there's a ratio on things are growing, but it's good practice that if you turn it one then simply put it to 1."]}),"\n",(0,i.jsxs)(n.p,{children:["So what does ",(0,i.jsx)(n.code,{children:"flex-grow"})," do?"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"flex-grow"})," takes all the leftover space that the parent has, and splits it evenly (if they're all set to 1) between the flex items."]}),"\n",(0,i.jsx)(n.p,{children:"Usually with navigation links bar we want that default behavior of grow being off."}),"\n",(0,i.jsx)(n.p,{children:"One important thing to note, the grows rate of each row is independent! What this means in simpler terms is that if there are 2 rows, and in one there's 6 items, and in the other there's 4 items, one split will be amongst the 6 (divide by 6), and one split will be among the 4 (divide by 4)."}),"\n",(0,i.jsxs)(n.p,{children:["But how can it be that we got more than 1 row in the first place? Meet ",(0,i.jsx)(n.code,{children:"flex-wrap"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"--e-flex-wrap",children:"- E. Flex Wrap"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"flex-wrap"})," is set to ",(0,i.jsx)(n.code,{children:"nowrap"})," by default.",(0,i.jsx)(n.br,{}),"\n","There's another value called ",(0,i.jsx)(n.code,{children:"wrap"}),", which allows flex items to wrap once they hit the parent's max width."]}),"\n",(0,i.jsxs)(n.p,{children:["So basically, instead of having a ",(0,i.jsx)(n.em,{children:"parent overflow"}),", you're getting a ",(0,i.jsx)(n.em,{children:"parent wrap"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"--f-what-is-flex-1",children:"- F. What is flex: 1?"}),"\n",(0,i.jsx)(n.p,{children:"A common thing you'll see in other people's project is the use of the shorthand write of:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-css",children:".flexItem {\n  flex: 1;\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"and you probably know that what this usually means is that the developer wanted every flexItem to be equally sized. But why is this happening?"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"flex"})," attribute actually accepts 3 things as its argument.",(0,i.jsx)(n.br,{}),"\n","The ",(0,i.jsx)(n.code,{children:"flex"})," attribute is like the ",(0,i.jsx)(n.code,{children:"border"})," attribute in the sense that they are a way to write many attributes in one line:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-css",children:".someItem {\n  border: 1px solid black;\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"is exactly the same as:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-css",children:".someItem {\n  border-width: 1px;\n  border-style: solid;\n  border-color: black;\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["What ",(0,i.jsx)(n.code,{children:"flex: 1"})," really means is this:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-css",children:".flexItem {\n  flex: 1;\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"is exactly the same as:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-css",children:".flexItem {\n  flex-shrink: 1;\n  flex-grow: 1;\n  flex-basis: 0;\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Let's analyze what we got here.",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.code,{children:"flex-shrink"})," is 1 by default, so ",(0,i.jsx)(n.code,{children:"flex: 1"})," did not touch that. cool.",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.code,{children:"flex-grow"})," is 0 by default, so we see that ",(0,i.jsx)(n.code,{children:"flex: 1"})," changed it to 1, and this is expected, since we want all flex items to be equally sized. Naturally this would mean that some of them would have to grow, and some of them would have to shrink."]}),"\n",(0,i.jsxs)(n.p,{children:["But what is this ",(0,i.jsx)(n.code,{children:"flex-basis"})," thingy?"]}),"\n",(0,i.jsx)(n.p,{children:"Imagine th following settings:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-css",children:".flexItem {\n  flex-shrink: 0;\n  flex-grow: 0;\n  flex-basis: 300px;\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"What this says it this: \"Hey, don't let flex items shrink, don't let them grow, but in fact - give each one a width of 300px\"."}),"\n",(0,i.jsxs)(n.p,{children:["Regardless of what the parent's width is, each child ",(0,i.jsx)(n.em,{children:"would"})," in fact get a width of a 300px. And if an overflow situation were to occur? Then so be it!",(0,i.jsx)(n.br,{}),"\n","You can think of ",(0,i.jsx)(n.code,{children:"flex-basis"})," a lot like width. It ",(0,i.jsx)(n.em,{children:"is"})," different from width, but it's very very similar, and often thinking about them in the same way is the easiest way to really understand what's happening."]}),"\n",(0,i.jsx)(n.p,{children:'That being said, we normally don\'t use "px" on it as values, rather we use percents.'}),"\n",(0,i.jsxs)(n.p,{children:["One of the differences between ",(0,i.jsx)(n.code,{children:"width"})," and ",(0,i.jsx)(n.code,{children:"flex-basis"})," is when you set ",(0,i.jsx)(n.code,{children:"flex-basis"})," to 0, the flex items don't actually become of 0 width. ",(0,i.jsx)(n.code,{children:"flex-basis"})," 0 actually means ",(0,i.jsx)(n.code,{children:"min-content"})," value."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Important thing to note!"})," You ",(0,i.jsx)(n.em,{children:"shouldn't"})," use ",(0,i.jsx)(n.code,{children:"width"})," AND ",(0,i.jsx)(n.code,{children:"flex-basis"})," together. ",(0,i.jsx)(n.code,{children:"width"})," wins the battle in case both are mentioned. In any case, you should use one or the other, not both."]}),"\n",(0,i.jsxs)(n.p,{children:["I usually like to give each flex-item a width of 100%, which is in the case the same as setting ",(0,i.jsx)(n.code,{children:"flex-basis"})," to 100%."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-css",children:".flexItem {\n  flex-shrink: 1;\n  flex-grow: 1;\n  flex-basis: auto;\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"\u2022 Edge Case 1:"})}),"\n",(0,i.jsx)(n.p,{children:"Consider the following case:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-css",children:".flexItem {\n  flex-shrink: 0;\n  flex-grow: 1;\n  flex-basis: 100%;\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"What would happen in the above scenario?"}),"\n",(0,i.jsx)(n.p,{children:"Because the shrink is off, and the basis is 100%, each child will have 100% of the parent's width, and an overflow is guaranteed to happen if there's more than 1 flex item."}),"\n",(0,i.jsx)(n.h3,{id:"--g-align-self",children:"- G. align-self"}),"\n",(0,i.jsxs)(n.p,{children:["Often time when working in a ",(0,i.jsx)(n.code,{children:"flex-direction: column"})," situation, you find yourself doing this:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-css",children:".flexParent {\n  display: flex;\n  flex-direction: column;\n  justify-content: space-between;\n  align-items: flex-start;\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"and you've seen this a million times. You want a column, you want the flex items to space evenly between, and you want each flex item to be aligned to the left."}),"\n",(0,i.jsxs)(n.p,{children:["However! Amongst the flex items, there's one child item which you want aligned differently than its brothers. Either to the right, or to the center. It could be that this flex item is a title, or maybe a button at the bottom.",(0,i.jsx)(n.br,{}),"\n","This can be done by using ",(0,i.jsx)(n.code,{children:"align-self"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-css",children:".specialFlexItem {\n  align-self: center;\n}\n``\n"})}),"\n",(0,i.jsx)(n.h3,{id:"--h-flex-flow",children:"- H. Flex Flow"}),"\n",(0,i.jsxs)(n.p,{children:["This is a shorthand for the flex-direction and flex-wrap properties, which together define the flex container\u2019s main and cross axes. The default value is ",(0,i.jsx)(n.code,{children:"row nowrap"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-css",children:".container {\n  flex-flow: column wrap;\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"--i-how-is-it-calculated-with-padding--margins",children:"- I. How is it calculated with padding & margins?"}),"\n",(0,i.jsxs)(n.p,{children:["When flexbox is doing its calculations, it's ",(0,i.jsx)(n.strong,{children:"NOT"})," taking into account each flex item's paddings & border widths."]}),"\n",(0,i.jsx)(n.p,{children:"Now what does that mean exactly? And why they decided it should behave like that?"}),"\n",(0,i.jsxs)(n.p,{children:["So, we know that flex items can either shrink or grow to fill the parent element's width. Think about it this way: do you really want the ",(0,i.jsx)(n.em,{children:"border width"})," to grow or shrink? Now that wouldn't make much sense, does it? So, what flexbox does it it deducts all those border widths up front, and hen proceeds to fit the flex items in the space that's left. For instance, if a parent element has a width of 600, and 1 flex item has a border width of 2, then flexbox takes the 600 and deducts 4 from it (because there's a border of each side), and proceed to divide 596 by 3."]})]})}function c(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},7252:(e,n,t)=>{t.d(n,{Z:()=>o,a:()=>a});var i=t(959);const s={},l=i.createContext(s);function a(e){const n=i.useContext(l);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(l.Provider,{value:n},e.children)}}}]);