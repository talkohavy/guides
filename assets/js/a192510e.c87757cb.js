"use strict";(self.webpackChunkdocusaurus_guides=self.webpackChunkdocusaurus_guides||[]).push([[5019],{7542:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>o,contentTitle:()=>d,default:()=>h,frontMatter:()=>r,metadata:()=>l,toc:()=>a});const l=JSON.parse('{"id":"programming/devops/helm/helm-install-deep-dive","title":"Helm Install - Deep Dive","description":"1. Installation Methods","source":"@site/docs/programming/devops/helm/helm-install-deep-dive.md","sourceDirName":"programming/devops/helm","slug":"/programming/devops/helm/helm-install-deep-dive","permalink":"/guides/docs/programming/devops/helm/helm-install-deep-dive","draft":false,"unlisted":false,"editUrl":"https://github.com/talkohavy/guides/docs/programming/devops/helm/helm-install-deep-dive.md","tags":[],"version":"current","frontMatter":{},"sidebar":"mySidebar","previous":{"title":"- Architecture & Concepts","permalink":"/guides/docs/programming/devops/helm/helm-architecture-and-concepts"},"next":{"title":"- Helm Upgrade: Deep Dive","permalink":"/guides/docs/programming/devops/helm/helm-upgrade-deep-dive"}}');var i=n(5813),t=n(3546);const r={},d="Helm Install - Deep Dive",o={},a=[{value:"1. Installation Methods",id:"1-installation-methods",level:2},{value:"2. Resources Order of Installation",id:"2-resources-order-of-installation",level:2},{value:"3. What does <code>helm install</code> do behind the scenes?",id:"3-what-does-helm-install-do-behind-the-scenes",level:2},{value:"- Step 1: Chart resolution",id:"--step-1-chart-resolution",level:3},{value:"- Step 2: Merge Values",id:"--step-2-merge-values",level:3},{value:"- Step 3: Render Templates into <code>manifests</code>",id:"--step-3-render-templates-into-manifests",level:3},{value:"- Step 4: Install Release to Kubernetes",id:"--step-4-install-release-to-kubernetes",level:3},{value:"- Step 5: Create Release Record (in Cluster)",id:"--step-5-create-release-record-in-cluster",level:3},{value:"- Step 6: Run Hooks (if any exists)",id:"--step-6-run-hooks-if-any-exists",level:3},{value:"- Step 7: Show Output",id:"--step-7-show-output",level:3},{value:"4. When does an installation considered successful?",id:"4-when-does-an-installation-considered-successful",level:2},{value:"5. Handling a failed installation",id:"5-handling-a-failed-installation",level:2},{value:"- Option 1: Do nothing",id:"--option-1-do-nothing",level:3},{value:"- Option 2: Go back to a previous successful release",id:"--option-2-go-back-to-a-previous-successful-release",level:3},{value:"- Option 3: cleanup on fail",id:"--option-3-cleanup-on-fail",level:3},{value:"6. A Forceful Upgrade (<em>discouraged!</em>)",id:"6-a-forceful-upgrade-discouraged",level:2}];function c(e){const s={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.header,{children:(0,i.jsx)(s.h1,{id:"helm-install---deep-dive",children:"Helm Install - Deep Dive"})}),"\n",(0,i.jsx)(s.h2,{id:"1-installation-methods",children:"1. Installation Methods"}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"helm install"})," command can install from several sources:"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["A chart repository (",(0,i.jsx)(s.code,{children:"helm install happy-panda bitnami/wordpress"}),")"]}),"\n",(0,i.jsxs)(s.li,{children:["A local chart archive (",(0,i.jsx)(s.code,{children:"helm install foo foo-0.1.1.tgz"}),")"]}),"\n",(0,i.jsxs)(s.li,{children:["An unpacked chart directory (",(0,i.jsx)(s.code,{children:"helm install foo path/to/foo"}),")"]}),"\n",(0,i.jsxs)(s.li,{children:["A full URL (",(0,i.jsx)(s.code,{children:"helm install foo https://example.com/charts/foo-1.2.3.tgz"}),")"]}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"2-resources-order-of-installation",children:"2. Resources Order of Installation"}),"\n",(0,i.jsx)(s.p,{children:"Helm installs resources in the following order:"}),"\n",(0,i.jsx)(s.p,{children:"(important parts)"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Namespace"}),"\n",(0,i.jsx)(s.li,{children:"ServiceAccount"}),"\n",(0,i.jsx)(s.li,{children:"Secret"}),"\n",(0,i.jsx)(s.li,{children:"ConfigMap"}),"\n",(0,i.jsx)(s.li,{children:"Role"}),"\n",(0,i.jsx)(s.li,{children:"RoleBinding"}),"\n",(0,i.jsx)(s.li,{children:"Service"}),"\n",(0,i.jsx)(s.li,{children:"Pod"}),"\n",(0,i.jsx)(s.li,{children:"ReplicaSet"}),"\n",(0,i.jsx)(s.li,{children:"Deployment"}),"\n",(0,i.jsx)(s.li,{children:"Ingress"}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"(full list)"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Namespace"}),"\n",(0,i.jsx)(s.li,{children:"NetworkPolicy"}),"\n",(0,i.jsx)(s.li,{children:"ResourceQuota"}),"\n",(0,i.jsx)(s.li,{children:"LimitRange"}),"\n",(0,i.jsx)(s.li,{children:"PodSecurityPolicy"}),"\n",(0,i.jsx)(s.li,{children:"PodDisruptionBudget"}),"\n",(0,i.jsx)(s.li,{children:"ServiceAccount"}),"\n",(0,i.jsx)(s.li,{children:"Secret"}),"\n",(0,i.jsx)(s.li,{children:"SecretList"}),"\n",(0,i.jsx)(s.li,{children:"ConfigMap"}),"\n",(0,i.jsx)(s.li,{children:"StorageClass"}),"\n",(0,i.jsx)(s.li,{children:"PersistentVolume"}),"\n",(0,i.jsx)(s.li,{children:"PersistentVolumeClaim"}),"\n",(0,i.jsx)(s.li,{children:"CustomResourceDefinition"}),"\n",(0,i.jsx)(s.li,{children:"ClusterRole"}),"\n",(0,i.jsx)(s.li,{children:"ClusterRoleList"}),"\n",(0,i.jsx)(s.li,{children:"ClusterRoleBinding"}),"\n",(0,i.jsx)(s.li,{children:"ClusterRoleBindingList"}),"\n",(0,i.jsx)(s.li,{children:"Role"}),"\n",(0,i.jsx)(s.li,{children:"RoleList"}),"\n",(0,i.jsx)(s.li,{children:"RoleBinding"}),"\n",(0,i.jsx)(s.li,{children:"RoleBindingList"}),"\n",(0,i.jsx)(s.li,{children:"Service"}),"\n",(0,i.jsx)(s.li,{children:"DaemonSet"}),"\n",(0,i.jsx)(s.li,{children:"Pod"}),"\n",(0,i.jsx)(s.li,{children:"ReplicationController"}),"\n",(0,i.jsx)(s.li,{children:"ReplicaSet"}),"\n",(0,i.jsx)(s.li,{children:"Deployment"}),"\n",(0,i.jsx)(s.li,{children:"HorizontalPodAutoscaler"}),"\n",(0,i.jsx)(s.li,{children:"StatefulSet"}),"\n",(0,i.jsx)(s.li,{children:"Job"}),"\n",(0,i.jsx)(s.li,{children:"CronJob"}),"\n",(0,i.jsx)(s.li,{children:"Ingress"}),"\n",(0,i.jsx)(s.li,{children:"APIService"}),"\n"]}),"\n",(0,i.jsxs)(s.h2,{id:"3-what-does-helm-install-do-behind-the-scenes",children:["3. What does ",(0,i.jsx)(s.code,{children:"helm install"})," do behind the scenes?"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-bash",children:"helm upgrade CHART_NAME CHART_LOCATION --install --values values.yaml -n NAMESPACE --create-namespace\n"})}),"\n",(0,i.jsx)(s.h3,{id:"--step-1-chart-resolution",children:"- Step 1: Chart resolution"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Helm looks for the chart (",(0,i.jsx)(s.code,{children:"CHART_LOCATION"}),") either locally using a path or from a remote chart repository (like ",(0,i.jsx)(s.code,{children:"https://charts.bitnami.com/bitnami"}),")."]}),"\n",(0,i.jsxs)(s.li,{children:["It loads the chart into memory, including:","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"Chart.yaml"}),": metadata"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"values.yaml"}),": default configuration values"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"templates/"}),": YAML templates with Go templating"]}),"\n",(0,i.jsxs)(s.li,{children:["Any other custom files like ",(0,i.jsx)(s.code,{children:"NOTES.txt"})]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["Helm parses the ",(0,i.jsx)(s.code,{children:"Chart.yaml"})," (chart metadata) and ",(0,i.jsx)(s.code,{children:"values.yaml"})," (default values) using a YAML parser. If you pass a custom values file (",(0,i.jsx)(s.code,{children:"-f my-values.yaml"}),") or ",(0,i.jsx)(s.code,{children:"--set"})," flags, those are also parsed."]}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"--step-2-merge-values",children:"- Step 2: Merge Values"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Helm merges configuration values:","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"values.yaml"})}),"\n",(0,i.jsxs)(s.li,{children:["Any ",(0,i.jsx)(s.code,{children:"--values"})," (",(0,i.jsx)(s.code,{children:"-f"}),") file provided"]}),"\n",(0,i.jsxs)(s.li,{children:["Any ",(0,i.jsx)(s.code,{children:"--set"})," CLI overrides"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["The result is a ",(0,i.jsx)(s.strong,{children:"single values map"})," used to render templates."]}),"\n"]}),"\n",(0,i.jsxs)(s.h3,{id:"--step-3-render-templates-into-manifests",children:["- Step 3: Render Templates into ",(0,i.jsx)(s.code,{children:"manifests"})]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Helm renders the Go templates inside ",(0,i.jsx)(s.code,{children:"templates/"})," directory using the merged values."]}),"\n",(0,i.jsxs)(s.li,{children:["This results in standard Kubernetes ",(0,i.jsx)(s.code,{children:"manifests"})," (YAML) \u2014 like ",(0,i.jsx)(s.code,{children:"Deployments"}),", ",(0,i.jsx)(s.code,{children:"Services"}),", ",(0,i.jsx)(s.code,{children:"Ingress"}),", ",(0,i.jsx)(s.code,{children:"ConfigMaps"}),", etc."]}),"\n",(0,i.jsxs)(s.li,{children:["The ",(0,i.jsx)(s.code,{children:"manifests"})," are YAML documents in ",(0,i.jsx)(s.strong,{children:"plain text"}),". These rendered YAMLs are still just strings at this point."]}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"--step-4-install-release-to-kubernetes",children:"- Step 4: Install Release to Kubernetes"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Before sending the ",(0,i.jsx)(s.code,{children:"manifests"})," to Kubernetes, ",(0,i.jsx)(s.strong,{children:"Helm parses these rendered YAMLs"})," to:","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Validate them structurally (to some degree)"}),"\n",(0,i.jsx)(s.li,{children:"Convert them to Kubernetes API-compatible JSON objects (Kubernetes API works with JSON under the hood)"}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Invalid YAMLs here will raise errors"})," (e.g. bad indentation, missing colons)."]}),"\n",(0,i.jsx)(s.li,{children:"Helm needs to convert YAML to internal objects to check for things like hooks, CRDs, kinds, etc."}),"\n",(0,i.jsx)(s.li,{children:"Kubernetes itself also validates these later, but Helm catches obvious issues first."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["Helm then ",(0,i.jsx)(s.strong,{children:"connects"})," to the Kubernetes cluster (via ",(0,i.jsx)(s.code,{children:"~/.kube/config"})," or ",(0,i.jsx)(s.code,{children:"context"}),")."]}),"\n",(0,i.jsxs)(s.li,{children:["It sends the rendered ",(0,i.jsx)(s.code,{children:"manifests"})," to the Kubernetes API server."]}),"\n",(0,i.jsxs)(s.li,{children:["The Kubernetes API server validates and stores the ",(0,i.jsx)(s.code,{children:"manifests"})," in ",(0,i.jsx)(s.code,{children:"etcd"}),"."]}),"\n",(0,i.jsxs)(s.li,{children:["Resources are then created by Kubernetes controllers (e.g., ",(0,i.jsx)(s.code,{children:"Deployment"})," creates ",(0,i.jsx)(s.code,{children:"Pods"}),")."]}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"--step-5-create-release-record-in-cluster",children:"- Step 5: Create Release Record (in Cluster)"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Helm stores a ",(0,i.jsx)(s.strong,{children:"release object"})," in the cluster using ",(0,i.jsx)(s.code,{children:"secrets"}),"/",(0,i.jsx)(s.code,{children:"configmaps"})," in the release's namespace. (in older versions, 2 and below, it would store them under the ",(0,i.jsx)(s.code,{children:"kube-system"})," namespace)."]}),"\n",(0,i.jsxs)(s.li,{children:["The release record includes:","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Rendered ",(0,i.jsx)(s.code,{children:"manifests"})]}),"\n",(0,i.jsx)(s.li,{children:"Chart metadata"}),"\n",(0,i.jsx)(s.li,{children:"Values used"}),"\n",(0,i.jsx)(s.li,{children:"Version info"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"--step-6-run-hooks-if-any-exists",children:"- Step 6: Run Hooks (if any exists)"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Helm checks for lifecycle hooks defined in templates (like pre-install, post-install)."}),"\n",(0,i.jsx)(s.li,{children:"These jobs/pods are created and monitored."}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"--step-7-show-output",children:"- Step 7: Show Output"}),"\n",(0,i.jsxs)(s.p,{children:["If successful, Helm outputs the status. Release name, namespace, resources created, and any messages from ",(0,i.jsx)(s.code,{children:"NOTES.txt"})," (templated and displayed)."]}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsx)(s.h2,{id:"4-when-does-an-installation-considered-successful",children:"4. When does an installation considered successful?"}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"helm"})," considers an installation (or an upgrade) successful as soon as the ",(0,i.jsx)(s.code,{children:"manifest"})," is received by the kubernetes API server. It doesn't wait for the pods to be up and running."]}),"\n",(0,i.jsxs)(s.p,{children:["If you want that to happen, you can use the ",(0,i.jsx)(s.code,{children:"--wait"})," flag. With it, ",(0,i.jsx)(s.code,{children:"helm"})," will wait for the ",(0,i.jsx)(s.code,{children:"services"})," and ",(0,i.jsx)(s.code,{children:"deployments"})," ",(0,i.jsx)(s.strong,{children:"to be created"}),", and for the ",(0,i.jsx)(s.code,{children:"pods"})," ",(0,i.jsx)(s.strong,{children:"to be up and running"}),". Only then the installation is considered successful."]}),"\n",(0,i.jsxs)(s.p,{children:["By default, ",(0,i.jsx)(s.code,{children:"helm"})," waits about 5 minutes (300 seconds), and if the installation doesn't complete by that time, the installation is marked as ",(0,i.jsx)(s.strong,{children:"failure"}),". If you want to override the default timeout, you can use the ",(0,i.jsx)(s.code,{children:"--timeout"})," flag, followed by the time. Examples of valid time values: ",(0,i.jsx)(s.code,{children:"5m"}),", ",(0,i.jsx)(s.code,{children:"10s"}),", ",(0,i.jsx)(s.code,{children:"5m10s"})," (without quotes!)."]}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsx)(s.h2,{id:"5-handling-a-failed-installation",children:"5. Handling a failed installation"}),"\n",(0,i.jsx)(s.p,{children:"By default, upon a failure, created resources remain created (i.e. secrets), and the pod is endlessly and desperately trying to live."}),"\n",(0,i.jsx)(s.p,{children:"In such case, you have a few options:"}),"\n",(0,i.jsx)(s.h3,{id:"--option-1-do-nothing",children:"- Option 1: Do nothing"}),"\n",(0,i.jsx)(s.p,{children:"Bad idea. You are leaving a dirty environment, and a pod that's endlessly and desperately trying to live takes up resources, which costs money."}),"\n",(0,i.jsx)(s.h3,{id:"--option-2-go-back-to-a-previous-successful-release",children:"- Option 2: Go back to a previous successful release"}),"\n",(0,i.jsxs)(s.p,{children:["If you want to go back to a previous successful release, and keep your deployment as clean as possible, use the ",(0,i.jsx)(s.code,{children:"--atomic"})," flag. If ",(0,i.jsx)(s.code,{children:"--atomic"})," is set, the upgrade process rolls back changes made in case of failed upgrade. The ",(0,i.jsx)(s.code,{children:"--wait"})," flag will be set automatically if ",(0,i.jsx)(s.code,{children:"--atomic"})," is used."]}),"\n",(0,i.jsxs)(s.p,{children:["If an installation has failed, and the ",(0,i.jsx)(s.code,{children:"--atomic"})," flag was set, it will:"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"remove secrets"}),"\n",(0,i.jsx)(s.li,{children:"kill the pod (euthanize)"}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"A full command would look like:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-bash",children:"helm upgrade RELEASE --values values.yaml --atomic --wait --timeout 7m\n"})}),"\n",(0,i.jsx)(s.h3,{id:"--option-3-cleanup-on-fail",children:"- Option 3: cleanup on fail"}),"\n",(0,i.jsx)(s.p,{children:"Cleanup on fail cleans up (i.e. deletes) any secrets and objects created due to the failed upgrade. It is different than go back to a previous release in 2 ways:"}),"\n",(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsx)(s.li,{children:"It doesn't create a new helm-history item (stored as a secret)"}),"\n",(0,i.jsx)(s.li,{children:"It doesn't kill the pod that's trying to live."}),"\n"]}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsxs)(s.h2,{id:"6-a-forceful-upgrade-discouraged",children:["6. A Forceful Upgrade (",(0,i.jsx)(s.em,{children:"discouraged!"}),")"]}),"\n",(0,i.jsxs)(s.p,{children:["What does it mean to use ",(0,i.jsx)(s.code,{children:"--force"})," with upgrade?"]}),"\n",(0,i.jsxs)(s.p,{children:["When we do a ",(0,i.jsx)(s.code,{children:"helm upgrade"}),", kubernetes receives a ",(0,i.jsx)(s.strong,{children:"request to modify the existing objects"}),". It will restart only the pods whose values have changed. It will NOT restart all the pods all the time. ",(0,i.jsx)(s.strong,{children:"It will only restart the pods if there are any values that have changed"})," for those pods. But if we have a requirement where you want to forcefully restart all pods, you can use the ",(0,i.jsx)(s.code,{children:"--force"})," option. Internally, ",(0,i.jsx)(s.code,{children:"helm"})," will delete the current deployment. Instead of modifying the deployment, it will delete the deployment, and it will recreate the deployment. As a result, k8s will delete the old pods and create new ones. ",(0,i.jsxs)(s.strong,{children:["So there will be some downtime when you use ",(0,i.jsx)(s.code,{children:"--force"})," option"]}),". This is a major risk of using ",(0,i.jsx)(s.code,{children:"--force"}),"flag."]})]})}function h(e={}){const{wrapper:s}={...(0,t.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},3546:(e,s,n)=>{n.d(s,{R:()=>r,x:()=>d});var l=n(9729);const i={},t=l.createContext(i);function r(e){const s=l.useContext(t);return l.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function d(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),l.createElement(t.Provider,{value:s},e.children)}}}]);