"use strict";(self.webpackChunkdocusaurus_guides=self.webpackChunkdocusaurus_guides||[]).push([[4445],{4574:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"knowledge/post-vs-get-login","title":"Why use POST and not GET for login requests?","description":"The reason is security, data size, and HTTP protocol semantics.","source":"@site/docs/knowledge/post-vs-get-login.md","sourceDirName":"knowledge","slug":"/knowledge/post-vs-get-login","permalink":"/guides/docs/knowledge/post-vs-get-login","draft":false,"unlisted":false,"editUrl":"https://github.com/talkohavy/guides/docs/knowledge/post-vs-get-login.md","tags":[],"version":"current","frontMatter":{},"sidebar":"mySidebar","previous":{"title":"- Offset and Cursor Pagination","permalink":"/guides/docs/knowledge/cursor-vs-offset-pagination"},"next":{"title":"- SOLID Principles","permalink":"/guides/docs/knowledge/solid"}}');var r=n(5813),i=n(3546);const o={},a="Why use POST and not GET for login requests?",d={},l=[{value:"1. <strong>Security Concerns (Sensitive Data in the Body vs. URL)</strong>",id:"1-security-concerns-sensitive-data-in-the-body-vs-url",level:2},{value:"2. <strong>Semantics of HTTP Methods</strong>",id:"2-semantics-of-http-methods",level:2},{value:"3. <strong>URL Length Limits</strong>",id:"3-url-length-limits",level:2},{value:"4. <strong>Caching and Bookmarking</strong>",id:"4-caching-and-bookmarking",level:2}];function c(e){const s={h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.header,{children:(0,r.jsx)(s.h1,{id:"why-use-post-and-not-get-for-login-requests",children:"Why use POST and not GET for login requests?"})}),"\n",(0,r.jsxs)(s.p,{children:["The reason is ",(0,r.jsx)(s.strong,{children:"security"}),", ",(0,r.jsx)(s.strong,{children:"data size"}),", and ",(0,r.jsx)(s.strong,{children:"HTTP protocol semantics"}),"."]}),"\n",(0,r.jsxs)(s.h2,{id:"1-security-concerns-sensitive-data-in-the-body-vs-url",children:["1. ",(0,r.jsx)(s.strong,{children:"Security Concerns (Sensitive Data in the Body vs. URL)"})]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Sensitive Data Exposure"}),": ",(0,r.jsx)(s.strong,{children:"GET"})," uses query params. Query params are part of the url. Urls are usually logged, wether it in browser history, server logs, or intermediary proxies. As a result, sensitive information like usernames and passwords could be exposed in these logs, which is a major security risk."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"POST"})," sends the data in the request body, which ",(0,r.jsx)(s.strong,{children:"does not get logged in URLs"})," or browser history. This makes it a safer way to transmit sensitive data like passwords."]}),"\n"]}),"\n",(0,r.jsxs)(s.h2,{id:"2-semantics-of-http-methods",children:["2. ",(0,r.jsx)(s.strong,{children:"Semantics of HTTP Methods"})]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"GET"}),": According to the HTTP specification, a ",(0,r.jsx)(s.strong,{children:"GET"})," request is used to ",(0,r.jsx)(s.strong,{children:"retrieve data"}),". It's ",(0,r.jsx)(s.strong,{children:"idempotent"}),", meaning that multiple requests should not have side effects (such as changing data on the server). When you log in, you're attempting to ",(0,r.jsx)(s.strong,{children:"authenticate"})," the user and ",(0,r.jsx)(s.strong,{children:"alter"})," their session state on the server, which is a state-changing operation."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"POST"}),": A ",(0,r.jsx)(s.strong,{children:"POST"})," request is used to ",(0,r.jsx)(s.strong,{children:"submit data"})," that ",(0,r.jsx)(s.strong,{children:"modifies"})," the state on the server (like creating a session or logging the user in). It's a more appropriate method for a log in action."]}),"\n"]}),"\n",(0,r.jsxs)(s.h2,{id:"3-url-length-limits",children:["3. ",(0,r.jsx)(s.strong,{children:"URL Length Limits"})]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"GET"})," requests have a ",(0,r.jsx)(s.strong,{children:"URL length limit"}),", which is typically around 2,000 characters in most browsers. ",(0,r.jsx)(s.strong,{children:"POST"})," does not have this limitation."]}),"\n"]}),"\n",(0,r.jsxs)(s.h2,{id:"4-caching-and-bookmarking",children:["4. ",(0,r.jsx)(s.strong,{children:"Caching and Bookmarking"})]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"GET"})," requests are ",(0,r.jsx)(s.strong,{children:"cacheable"})," and can be bookmarked. This could lead to unintended consequences if login requests were cached, as it would expose the login data in URLs that could be reused or shared accidentally. On the other hand, ",(0,r.jsx)(s.strong,{children:"POST"})," requests are ",(0,r.jsx)(s.strong,{children:"not cacheable"})," and cannot be bookmarked, which makes them more suitable for actions like logging in. Now before you say anything, Yes, it's technically possible to cache POST requests, you can write a server that caches POST requests. However, when I say that POST requests are not cacheable, I'm referring to the default behavior and conventions established by the HTTP/1.1 specs and typical web infrastructure, including caching mechanisms in browsers and CDNs."]}),"\n"]})]})}function h(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},3546:(e,s,n)=>{n.d(s,{R:()=>o,x:()=>a});var t=n(9729);const r={},i=t.createContext(r);function o(e){const s=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),t.createElement(i.Provider,{value:s},e.children)}}}]);