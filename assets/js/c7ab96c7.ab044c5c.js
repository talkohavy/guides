"use strict";(self.webpackChunkdocusaurus_guides=self.webpackChunkdocusaurus_guides||[]).push([[7371],{7488:(e,i,s)=>{s.r(i),s.d(i,{assets:()=>t,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"programming/devops/docker/how-to-create-a-docker-compose-file","title":"How to create a Docker-Compose file","description":"- Rule 1: services","source":"@site/docs/programming/devops/docker/how-to-create-a-docker-compose-file.md","sourceDirName":"programming/devops/docker","slug":"/programming/devops/docker/how-to-create-a-docker-compose-file","permalink":"/guides/docs/programming/devops/docker/how-to-create-a-docker-compose-file","draft":false,"unlisted":false,"editUrl":"https://github.com/talkohavy/guides/docs/programming/devops/docker/how-to-create-a-docker-compose-file.md","tags":[],"version":"current","frontMatter":{},"sidebar":"mySidebar","previous":{"title":"- Docker Compose Commands","permalink":"/guides/docs/programming/devops/docker/docker-compose-commands"},"next":{"title":"- Kubernetes","permalink":"/guides/docs/kubernetes"}}');var r=s(6070),l=s(7010);const o={},a="How to create a Docker-Compose file",t={},c=[{value:"- Rule 1: services",id:"--rule-1-services",level:2},{value:"- Rule 2: services.image",id:"--rule-2-servicesimage",level:2},{value:"- Rule 3: services.build",id:"--rule-3-servicesbuild",level:2},{value:"- Rule 4: services.build.context (REQUIRED)",id:"--rule-4-servicesbuildcontext-required",level:2},{value:"- Rule 5: services.build.dockerfile",id:"--rule-5-servicesbuilddockerfile",level:2},{value:"- Rule 6: services.build.dockerfile_inline",id:"--rule-6-servicesbuilddockerfile_inline",level:2},{value:"- Rule 7: services.build.args",id:"--rule-7-servicesbuildargs",level:2},{value:"- Rule 8: services.build.privileged",id:"--rule-8-servicesbuildprivileged",level:2},{value:"- Rule 9: services.build.labels",id:"--rule-9-servicesbuildlabels",level:2},{value:"- Rule 10: services.build.no_cache",id:"--rule-10-servicesbuildno_cache",level:2},{value:"- Rule 11: services.build.pull",id:"--rule-11-servicesbuildpull",level:2},{value:"- Rule 12: services.build.shm_size",id:"--rule-12-servicesbuildshm_size",level:2},{value:"- Rule 13: services.build.secrets",id:"--rule-13-servicesbuildsecrets",level:2},{value:"- Rule 14: services.build.tags",id:"--rule-14-servicesbuildtags",level:2},{value:"- Rule 15: services.env_file",id:"--rule-15-servicesenv_file",level:2}];function d(e){const i={a:"a",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(i.header,{children:(0,r.jsx)(i.h1,{id:"how-to-create-a-docker-compose-file",children:"How to create a Docker-Compose file"})}),"\n",(0,r.jsx)(i.h2,{id:"--rule-1-services",children:"- Rule 1: services"}),"\n",(0,r.jsxs)(i.p,{children:["A Compose file ",(0,r.jsx)(i.strong,{children:"MUST"})," declare a ",(0,r.jsx)(i.code,{children:"services"})," key in the root.",(0,r.jsx)(i.br,{}),"\n","The ",(0,r.jsx)(i.code,{children:"services"})," value is an object (a map) whose keys are string representations of ",(0,r.jsx)(i.em,{children:"service names"}),", and whose values are ",(0,r.jsx)(i.em,{children:"service definitions"}),".",(0,r.jsx)(i.br,{}),"\n","A ",(0,r.jsx)(i.em,{children:"service definition"})," contains the configuration that is applied to each container started for that service.",(0,r.jsx)(i.br,{}),"\n","Each service MAY also include a ",(0,r.jsx)(i.code,{children:"build"})," section, which defines how to create the Docker image for the service.",(0,r.jsx)(i.br,{}),"\n","Compose implementations ",(0,r.jsx)(i.em,{children:"may"})," support building docker images using this service definition.\nIf not implemented, the ",(0,r.jsx)(i.code,{children:"build"})," section ",(0,r.jsx)(i.em,{children:"should"})," be ignored and the Compose file ",(0,r.jsx)(i.strong,{children:"MUST"})," still be considered valid.",(0,r.jsx)(i.br,{}),"\n",(0,r.jsx)(i.code,{children:"build"})," support is an OPTIONAL aspect of the Compose specification, and is described in detail in the Build support documentation."]}),"\n",(0,r.jsxs)(i.p,{children:["Each Service defines runtime constraints and requirements to run its containers.\nThe ",(0,r.jsx)(i.code,{children:"deploy"})," section groups these constraints and allows the platform to adjust the deployment strategy to best match containers' needs with available resources. Deploy support is an OPTIONAL aspect of the Compose specification, and is described in detail in the Deployment support documentation. If not implemented the Deploy section SHOULD be ignored and the Compose file MUST still be considered valid."]}),"\n",(0,r.jsx)(i.hr,{}),"\n",(0,r.jsx)(i.h2,{id:"--rule-2-servicesimage",children:"- Rule 2: services.image"}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.code,{children:"image"})," specifies the image to start the container from.",(0,r.jsx)(i.br,{}),"\n",(0,r.jsx)(i.code,{children:"image"})," ",(0,r.jsx)(i.strong,{children:"MUST"})," follow the Open Container Specification\xa0addressable image format, as ",(0,r.jsx)(i.code,{children:"[%registry%/][%project%/]%image%[:%tag%|@%digest%]"}),"."]}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-yaml",children:"image: redis\nimage: redis:5\nimage: redis@sha256:0ed5d5928d4737458944eb604cc8509e245c3e19d02ad83935398bc4b991aac7\nimage: library/redis\nimage: docker.io/library/redis\nimage: my_private.registry:5000/redis\n"})}),"\n",(0,r.jsx)(i.hr,{}),"\n",(0,r.jsx)(i.h2,{id:"--rule-3-servicesbuild",children:"- Rule 3: services.build"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:["\n",(0,r.jsxs)(i.p,{children:["build\n",(0,r.jsx)(i.code,{children:"build"})," an OPTIONAL build subsection on services\n",(0,r.jsx)(i.code,{children:"build"})," specifies the build configuration for creating container image from source.\nWhen a Build subsection is present for a service, it is valid for a Compose file to miss an ",(0,r.jsx)(i.code,{children:"Image"})," attribute for corresponding service, as Compose implementation can build image from source."]}),"\n"]}),"\n",(0,r.jsxs)(i.li,{children:["\n",(0,r.jsx)(i.p,{children:"build.context v.s. build = context\nBuild can be either specified as a single string defining a context path, or as a detailed build definition.\nIn the former case, the whole path is used as a Docker context to execute a docker build, looking for a canonical Dockerfile at context root. Context path can be absolute or relative, and if so relative path MUST be resolved from Compose file parent folder. As an absolute path prevent the Compose file to be portable, Compose implementation SHOULD warn user accordingly."}),"\n"]}),"\n",(0,r.jsxs)(i.li,{children:["\n",(0,r.jsx)(i.p,{children:"build.dockerfile\nIn the later case, build arguments can be specified, including an alternate Dockerfile location. This one can be absolute or relative path. If Dockerfile path is relative, it MUST be resolved from context path. As an absolute path prevent the Compose file to be portable, Compose implementation SHOULD warn user if an absolute alternate Dockerfile path is used."}),"\n"]}),"\n",(0,r.jsxs)(i.li,{children:["\n",(0,r.jsxs)(i.p,{children:["Consistency with Image\nWhen service definition do include both ",(0,r.jsx)(i.code,{children:"Image"})," attribute and a ",(0,r.jsx)(i.code,{children:"Build"})," section, Compose implementation can't guarantee a pulled image is strictly equivalent to building the same image from sources. Without any explicit user directives, Compose implementation with Build support MUST first try to pull Image, then build from source if image was not found on registry. Compose implementation MAY offer options to customize this behavior by user request."]}),"\n"]}),"\n",(0,r.jsxs)(i.li,{children:["\n",(0,r.jsx)(i.p,{children:"Illustrative sample"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-yaml",children:"services:\nfrontend:\nimage: awesome/webapp\nbuild: ./webapp\n\nbackend:\nimage: awesome/database\nbuild:\ncontext: backend\ndockerfile: ../backend.Dockerfile\n\ncustom:\nbuild: ~/custom\n"})}),"\n",(0,r.jsx)(i.p,{children:"When used to build service images from source, such a Compose file will create three docker images:\n\u2022 awesome/webapp docker image is built using webapp sub-directory within Compose file parent folder as docker build context. Lack of a Dockerfile within this folder will throw an error.\n\u2022 awesome/database docker image is built using backend sub-directory within Compose file parent folder. backend.Dockerfile file is used to define build steps, this file is searched relative to context path, which means for this sample .. will resolve to Compose file parent folder, so backend.Dockerfile is a sibling file.\n\u2022 a docker image is built using custom directory within user's HOME as docker context. Compose implementation warn user about non-portable path used to build image."}),"\n"]}),"\n",(0,r.jsxs)(i.li,{children:["\n",(0,r.jsxs)(i.p,{children:["Build Definition\nThe ",(0,r.jsx)(i.code,{children:"build"})," element define configuration options that are applied by Compose implementations to build Docker image from source. ",(0,r.jsx)(i.code,{children:"build"})," can be specified either as a string containing a path to the build context or a detailed structure:\nUsing this string syntax, only the build context can be configured as either:\n\u2022 a relative path to the Compose file's parent folder. This path MUST be a directory and contain a Dockerfile"]}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-yaml",children:"services:\nwebapp:\nbuild: ./dir\n"})}),"\n",(0,r.jsxs)(i.p,{children:["\u2022 a git repository URL. Git URLs accept context configuration in their fragment section, separated by a colon (:). The first part represents the reference that Git\nwill check out, and can be either a branch, a tag, or a remote reference. The second part represents a subdirectory inside the repository that will be used as a\nbuild context.\nservices:\nwebapp:\nbuild: ",(0,r.jsx)(i.a,{href:"https://github.com/mycompany/example.git#branch_or_tag:subdirectory",children:"https://github.com/mycompany/example.git#branch_or_tag:subdirectory"})]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(i.hr,{}),"\n",(0,r.jsx)(i.h2,{id:"--rule-4-servicesbuildcontext-required",children:"- Rule 4: services.build.context (REQUIRED)"}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.code,{children:"context"})," defines either a path to a directory containing a Dockerfile, or a url to a git repository.\nWhen the value supplied is a relative path, it MUST be interpreted as relative to the location of the Compose file. Compose implementations MUST warn user about absolute path used to define build context as those prevent Compose file from being portable."]}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-yaml",children:"This:\nbuild:\ncontext: ./dir\nV.S. this:\nservices:\nwebapp:\nbuild: https://github.com/mycompany/webapp.git\n"})}),"\n",(0,r.jsx)(i.hr,{}),"\n",(0,r.jsx)(i.h2,{id:"--rule-5-servicesbuilddockerfile",children:"- Rule 5: services.build.dockerfile"}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.code,{children:"dockerfile"})," allows to set an alternate Dockerfile. A relative path MUST be resolved from the build context. Compose implementations MUST warn user about absolute path used to define Dockerfile as those prevent Compose file from being portable. When set, ",(0,r.jsx)(i.code,{children:"dockerfile_inline"})," attribute is not allowed and a Compose Implementation SHOULD reject any Compose file having both set."]}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-yaml",children:"build:\ncontext: .\ndockerfile: webapp.Dockerfile\n"})}),"\n",(0,r.jsx)(i.hr,{}),"\n",(0,r.jsx)(i.h2,{id:"--rule-6-servicesbuilddockerfile_inline",children:"- Rule 6: services.build.dockerfile_inline"}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.code,{children:"dockerfile_inline"})," allows to define Dockerfile content as inlined string in a Compose file. When set, ",(0,r.jsx)(i.code,{children:"dockerfile"})," attribute is not allowed and a Compose Implementation SHOULD reject any Compose file having both set.\nUse of YAML multi-line string syntax is recommended to define Dockerfile content:"]}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-dockerfile",children:"build:\ncontext: .\ndockerfile_inline: |\nFROM baseimage\nRUN some command\n"})}),"\n",(0,r.jsx)(i.hr,{}),"\n",(0,r.jsx)(i.h2,{id:"--rule-7-servicesbuildargs",children:"- Rule 7: services.build.args"}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.code,{children:"args"})," define build arguments, i.e. Dockerfile ",(0,r.jsx)(i.code,{children:"ARG"})," values.",(0,r.jsx)(i.br,{}),"\n",(0,r.jsx)(i.code,{children:"args"})," can be set in Compose file under the ",(0,r.jsx)(i.code,{children:"build"})," key to define some arguments.",(0,r.jsx)(i.br,{}),"\n",(0,r.jsx)(i.code,{children:"args"})," can be set a mapping or a list:"]}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-yaml",children:"// Way number 1:\nbuild:\ncontext: .\nargs:\nGIT_COMMIT: %some-value%\n// Way number 2:\nbuild:\ncontext: .\nargs: - GIT_COMMIT=%some-value%\n"})}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.strong,{children:"-- HARDCODED:"})}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.code,{children:"args"})," can be hardcoded:"]}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-yaml",children:"build:\ncontext: .\nargs: - VERDION=0.0.1\n"})}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.strong,{children:"-- PASSED FROM OUTSIDE:"})}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.code,{children:"args"})," can be passed from outside:"]}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-yaml",children:"build:\ncontext: .\nargs:\n  # The names do not need to match! First VERSION is the inner name, second VERSION is the outer name.\n  - VERSION=${VERSION:-0.0.1}\n"})}),"\n",(0,r.jsx)(i.p,{children:"In which, you would call the build sub-command like so:"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-bash",children:"VERSION=1.2.3 docker-compose build --no-cache\n"})}),"\n",(0,r.jsx)(i.hr,{}),"\n",(0,r.jsx)(i.h2,{id:"--rule-8-servicesbuildprivileged",children:"- Rule 8: services.build.privileged"}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.code,{children:"privileged"})," configures the service image to build with elevated privileges. Support and actual impacts are platform-specific.\nbuild:\ncontext: .\nprivileged: true"]}),"\n",(0,r.jsx)(i.hr,{}),"\n",(0,r.jsx)(i.h2,{id:"--rule-9-servicesbuildlabels",children:"- Rule 9: services.build.labels"}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.code,{children:"labels"})," add metadata to the resulting image. ",(0,r.jsx)(i.code,{children:"labels"})," can be set either as an array or a map.\nThis:"]}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-yaml",children:'build:\ncontext: .\nlabels:\ncom.example.description: "Accounting webapp"\ncom.example.department: "Finance"\ncom.example.label-with-empty-value: ""\n'})}),"\n",(0,r.jsx)(i.p,{children:"V.S. this:"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-yaml",children:'build:\ncontext: .\nlabels: - "com.example.description=Accounting webapp" - "com.example.department=Finance" - "com.example.label-with-empty-value"\n'})}),"\n",(0,r.jsx)(i.hr,{}),"\n",(0,r.jsx)(i.h2,{id:"--rule-10-servicesbuildno_cache",children:"- Rule 10: services.build.no_cache"}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.code,{children:"no_cache"})," disables image builder cache and enforce a full rebuild from source for all image layers. This only applies to layers declared in the Dockerfile, referenced images COULD be retrieved from local image store whenever tag has been updated on registry (see pull)."]}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-yaml",children:"services:\nusers-service:\nimage: users-service\nbuild:\nno_cache: true\n"})}),"\n",(0,r.jsx)(i.hr,{}),"\n",(0,r.jsx)(i.h2,{id:"--rule-11-servicesbuildpull",children:"- Rule 11: services.build.pull"}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.code,{children:"pull"})," require the image builder to pull referenced images (FROM Dockerfile directive), even if those are already available in the local image store."]}),"\n",(0,r.jsx)(i.hr,{}),"\n",(0,r.jsx)(i.h2,{id:"--rule-12-servicesbuildshm_size",children:"- Rule 12: services.build.shm_size"}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.code,{children:"shm_size"})," set the size of the shared memory (/dev/shm partition on Linux) allocated for building Docker image. Specify as an integer value representing the number of bytes or as a string expressing a byte value."]}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.strong,{children:"Byte values:"})}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"2b"}),"\n",(0,r.jsx)(i.li,{children:"1024kb"}),"\n",(0,r.jsx)(i.li,{children:"2048k"}),"\n",(0,r.jsx)(i.li,{children:"300m"}),"\n",(0,r.jsx)(i.li,{children:"1gb"}),"\n"]}),"\n",(0,r.jsx)(i.p,{children:"This:"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-yaml",children:"build:\ncontext: .\nshm_size: '2gb'\n"})}),"\n",(0,r.jsx)(i.p,{children:"V.S. this:"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-yaml",children:"build:\ncontext: .\nshm_size: 10000000\n"})}),"\n",(0,r.jsx)(i.hr,{}),"\n",(0,r.jsx)(i.h2,{id:"--rule-13-servicesbuildsecrets",children:"- Rule 13: services.build.secrets"}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.code,{children:"Docker Secrets"})," are only available in ",(0,r.jsx)(i.code,{children:"Swarm mode"}),", so standalone containers can not use this feature.\nA given secret is only accessible to those services which have been granted explicit access to it, and while they're running."]}),"\n",(0,r.jsx)(i.hr,{}),"\n",(0,r.jsx)(i.h2,{id:"--rule-14-servicesbuildtags",children:"- Rule 14: services.build.tags"}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.code,{children:"tags"})," defines a list of tag mappings that MUST be associated to the build image.\nThis list comes in addition of the ",(0,r.jsx)(i.code,{children:"image"})," property defined in the service section\ntags:"]}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:['"myimage',":mytag",'"']}),"\n",(0,r.jsxs)(i.li,{children:['"registry/username/myrepos',":my-other-tag",'"']}),"\n"]}),"\n",(0,r.jsx)(i.hr,{}),"\n",(0,r.jsx)(i.h2,{id:"--rule-15-servicesenv_file",children:"- Rule 15: services.env_file"}),"\n",(0,r.jsxs)(i.p,{children:["Defining an ",(0,r.jsx)(i.code,{children:"env_file"})," inside the yaml will take environment variables from the file and inject them into the container. That makes it visible to your application, but cannot be used for variables inside your yaml that you want docker-compose to expand since that variable expansion happens before the env_file contents are parsed."]}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-yaml",children:"services:\n  users-service:\n  env_file: .env\n"})}),"\n",(0,r.jsxs)(i.p,{children:["When both ",(0,r.jsx)(i.code,{children:"env_file"})," and ",(0,r.jsx)(i.code,{children:"environment"})," are set for a service, values set by ",(0,r.jsx)(i.code,{children:"environment"})," have precedence."]})]})}function h(e={}){const{wrapper:i}={...(0,l.R)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},7010:(e,i,s)=>{s.d(i,{R:()=>o,x:()=>a});var n=s(758);const r={},l=n.createContext(r);function o(e){const i=n.useContext(l);return n.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function a(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),n.createElement(l.Provider,{value:i},e.children)}}}]);