"use strict";(self.webpackChunkdocusaurus_guides=self.webpackChunkdocusaurus_guides||[]).push([[1167],{549:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>a,contentTitle:()=>i,default:()=>p,frontMatter:()=>c,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"programming/javascript/prototype","title":"Prototype","description":"tldr;","source":"@site/docs/programming/javascript/prototype.md","sourceDirName":"programming/javascript","slug":"/programming/javascript/prototype","permalink":"/guides/docs/programming/javascript/prototype","draft":false,"unlisted":false,"editUrl":"https://github.com/talkohavy/guides/docs/programming/javascript/prototype.md","tags":[],"version":"current","frontMatter":{},"sidebar":"mySidebar","previous":{"title":"- Strict Mode","permalink":"/guides/docs/programming/javascript/strict-mode"},"next":{"title":"- valueOf","permalink":"/guides/docs/programming/javascript/valueOf"}}');var r=o(6070),s=o(7010);const c={},i="Prototype",a={},d=[{value:"tldr;",id:"tldr",level:2},{value:"1. Inheritance and the prototype chain",id:"1-inheritance-and-the-prototype-chain",level:2},{value:"2. Own properties &amp; Inherited properties",id:"2-own-properties--inherited-properties",level:2},{value:"3. Getting/Viewing an object&#39;s prototype",id:"3-gettingviewing-an-objects-prototype",level:2},{value:"4. Constructors",id:"4-constructors",level:2},{value:"5. Do not re-assign prototype",id:"5-do-not-re-assign-prototype",level:2},{value:"6. Implicit constructors of literals",id:"6-implicit-constructors-of-literals",level:2},{value:"7. Default <code>prototype</code> instances",id:"7-default-prototype-instances",level:2},{value:"8. <code>prototype</code>&#39;s version of <code>extends</code>",id:"8-prototypes-version-of-extends",level:2},{value:"9. <code>prototype</code> of arrow functions",id:"9-prototype-of-arrow-functions",level:2},{value:"1. Object.create",id:"1-objectcreate",level:2}];function l(e){const t={admonition:"admonition",blockquote:"blockquote",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"prototype",children:"Prototype"})}),"\n",(0,r.jsx)(t.h2,{id:"tldr",children:"tldr;"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["A ",(0,r.jsx)(t.code,{children:"prototype"}),' is an object\'s internal "bag" of properties.']}),"\n",(0,r.jsxs)(t.li,{children:["Each object has an ",(0,r.jsx)(t.strong,{children:"internal link"})," to another object called its ",(0,r.jsx)(t.code,{children:"prototype"}),"."]}),"\n",(0,r.jsxs)(t.li,{children:["That ",(0,r.jsx)(t.code,{children:"prototype"})," object has a ",(0,r.jsx)(t.code,{children:"prototype"})," of its own, and so on until an object is reached with ",(0,r.jsx)(t.code,{children:"null"})," as its ",(0,r.jsx)(t.code,{children:"prototype"}),", marking the final link in the ",(0,r.jsx)(t.code,{children:"prototype"})," chain."]}),"\n",(0,r.jsxs)(t.li,{children:["When trying to access a property of an object, the property will not only be sought on the object but on the ",(0,r.jsx)(t.code,{children:"prototype"})," of the object, the ",(0,r.jsx)(t.code,{children:"prototype"})," of the ",(0,r.jsx)(t.code,{children:"prototype"}),", and so on until either a property with a matching name is found or the end of the ",(0,r.jsx)(t.code,{children:"prototype"})," chain is reached."]}),"\n",(0,r.jsxs)(t.li,{children:["While called ",(0,r.jsx)(t.code,{children:"prototype"}),", the ",(0,r.jsx)(t.strong,{children:"ACTUAL"})," key on the object is named ",(0,r.jsx)(t.code,{children:"__proto__"}),". So ",(0,r.jsx)(t.code,{children:"prototype"})," IS the bag of properties, and ",(0,r.jsx)(t.code,{children:"__proto__"})," is the NAME of the key on the object that POINTS to the ",(0,r.jsx)(t.code,{children:"prototype"}),"."]}),"\n",(0,r.jsxs)(t.li,{children:["Wanting to create multiple objects leads us to creating a ",(0,r.jsx)(t.strong,{children:"constructor"})," function."]}),"\n",(0,r.jsxs)(t.li,{children:["Every function has a ",(0,r.jsx)(t.code,{children:"key"})," called ",(0,r.jsx)(t.code,{children:"prototype"})," (",(0,r.jsx)(t.code,{children:"funcName.prototype"}),"), which points to an object."]}),"\n",(0,r.jsxs)(t.li,{children:["When using a function as a ",(0,r.jsx)(t.strong,{children:"constructor"}),", the returned object gets as ",(0,r.jsx)(t.code,{children:"prototype"})," (stored under ",(0,r.jsx)(t.code,{children:"__proto__"}),") the object that is stored under ",(0,r.jsx)(t.code,{children:"funcName.prototype"}),"."]}),"\n",(0,r.jsxs)(t.li,{children:["Do not confuse ",(0,r.jsx)(t.code,{children:"funcName.prototype"})," with ",(0,r.jsx)(t.code,{children:"funcName.__proto__"}),". The latter is the constructor function's own prototype, which is ",(0,r.jsx)(t.code,{children:"Function.prototype"}),"."]}),"\n",(0,r.jsxs)(t.li,{children:["You can mutate a ",(0,r.jsx)(t.strong,{children:"constructor"})," function's prototype ",(0,r.jsx)(t.em,{children:"AFTER"})," creating many instances, and those instances would instantly get that mutated object as ",(0,r.jsx)(t.code,{children:"prototype"}),"."]}),"\n",(0,r.jsxs)(t.li,{children:["Do not reassign an object to a ",(0,r.jsx)(t.strong,{children:"constructor"})," function's ",(0,r.jsx)(t.em,{children:"entire"})," prototype, since that would only affect future instances being created. Previously created instances would have their ties to the most updated prototype severed."]}),"\n"]}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"1-inheritance-and-the-prototype-chain",children:"1. Inheritance and the prototype chain"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"JavaScript implements inheritance by using objects."}),"\n",(0,r.jsxs)(t.li,{children:["Each object has an internal link to another object called its ",(0,r.jsx)(t.code,{children:"prototype"}),"."]}),"\n",(0,r.jsxs)(t.li,{children:["That ",(0,r.jsx)(t.code,{children:"prototype"})," object has a ",(0,r.jsx)(t.code,{children:"prototype"})," of its own, and so on until an object is reached with null as its ",(0,r.jsx)(t.code,{children:"prototype"}),"."]}),"\n",(0,r.jsxs)(t.li,{children:["By definition, ",(0,r.jsx)(t.code,{children:"null"})," has no ",(0,r.jsx)(t.code,{children:"prototype"})," and acts as the final link in this ",(0,r.jsx)(t.code,{children:"prototype"})," chain."]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"2-own-properties--inherited-properties",children:"2. Own properties & Inherited properties"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:'JavaScript objects are dynamic "bags" of properties.'}),"\n",(0,r.jsxs)(t.li,{children:["An object's direct properties are often referred to as ",(0,r.jsx)(t.strong,{children:"own properties"}),"."]}),"\n",(0,r.jsxs)(t.li,{children:["When trying to access a property of an object, the property will not only be sought on the object but on the ",(0,r.jsx)(t.code,{children:"prototype"})," of the object, the ",(0,r.jsx)(t.code,{children:"prototype"})," of the ",(0,r.jsx)(t.code,{children:"prototype"}),", and so on until either a property with a matching name is found or the end of the ",(0,r.jsx)(t.code,{children:"prototype"})," chain is reached."]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"3-gettingviewing-an-objects-prototype",children:"3. Getting/Viewing an object's prototype"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"When viewing an object in debug mode, or when printing an object in the browser's console, you can see its prototype under: [[Prototype]]"}),"\n",(0,r.jsxs)(t.li,{children:["Using code, this internal prototype can be accessed and modified using ",(0,r.jsx)(t.code,{children:"Object.getPrototypeOf()"})," and ",(0,r.jsx)(t.code,{children:"Object.setPrototypeOf()"})," functions respectively."]}),"\n",(0,r.jsxs)(t.li,{children:["Using ",(0,r.jsx)(t.code,{children:"Object.getPrototypeOf()"})," is equivalent to ",(0,r.jsx)(t.code,{children:"obj.__proto__"})," which is non-standard but de-facto implemented by many JavaScript engines."]}),"\n"]}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"4-constructors",children:"4. Constructors"}),"\n",(0,r.jsxs)(t.p,{children:["Constructors are functions called with the ",(0,r.jsx)(t.code,{children:"new"})," keyword."]}),"\n",(0,r.jsxs)(t.p,{children:["Although we can, We want to avoid manually binding the ",(0,r.jsx)(t.strong,{children:"__proto__"})," for every object creation, since it is very inconvenient. We should instead use a constructor function, which automatically sets the [[Prototype]] for every object manufactured. We call those ",(0,r.jsx)(t.strong,{children:"Constructor functions"}),", and they are functions called with the ",(0,r.jsx)(t.code,{children:"new"})," keyword."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"// A constructor function\nfunction Box(value) {\n  this.value = value;\n}\n\n// Properties all boxes created from the Box() constructor\n// will have\nBox.prototype.getValue = function () {\n  return this.value;\n};\n\nconst boxes = [new Box(1), new Box(2), new Box(3)];\n"})}),"\n",(0,r.jsx)(t.p,{children:"We phrase it like that:"}),"\n",(0,r.jsxs)(t.blockquote,{children:["\n",(0,r.jsx)(t.p,{children:(0,r.jsxs)(t.em,{children:["calling ",(0,r.jsx)(t.code,{children:"new Box(1)"})," returns an instance created from the ",(0,r.jsx)(t.strong,{children:"Box"})," ",(0,r.jsx)(t.code,{children:"constructor"})," function."]})}),"\n"]}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"5-do-not-re-assign-prototype",children:"5. Do not re-assign prototype"}),"\n",(0,r.jsxs)(t.p,{children:["Because ",(0,r.jsx)(t.code,{children:"Box.prototype"})," references the same object as the [[Prototype]] of all instances, we can change the behavior of all instances by mutating ",(0,r.jsx)(t.code,{children:"Box.prototype"}),"."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"function Box(value) {\n  this.value = value;\n}\nBox.prototype.getValue = function () {\n  return this.value;\n};\nconst box = new Box(1);\n\n// Mutate Box.prototype after an instance has already been created\nBox.prototype.getValue = function () {\n  return this.value + 1;\n};\nbox.getValue(); // 2\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Re-assigning ",(0,r.jsx)(t.code,{children:"Constructor.prototype"})," (",(0,r.jsx)(t.code,{children:"Constructor.prototype = ..."}),") is a bad idea for two reasons:"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["The ",(0,r.jsx)(t.code,{children:"[[Prototype]]"})," of instances created before the reassignment is now referencing a different object from the ",(0,r.jsx)(t.code,{children:"[[Prototype]]"})," of instances created after the reassignment \u2014 mutating one's ",(0,r.jsx)(t.code,{children:"[[Prototype]]"})," no longer mutates the other."]}),"\n",(0,r.jsxs)(t.li,{children:["Unless you manually re-set the ",(0,r.jsx)(t.code,{children:"constructor"})," property, the constructor function can no longer be traced from ",(0,r.jsx)(t.code,{children:"instance.constructor"}),", which may break user expectation. Some built-in operations will read the ",(0,r.jsx)(t.code,{children:"constructor"})," property as well, and if it is not set, they may not work as expected."]}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"Constructor.prototype"})," is only useful when constructing instances. It has nothing to do with ",(0,r.jsx)(t.code,{children:"Constructor.[[Prototype]]"}),", which is the constructor function's own prototype, which is ",(0,r.jsx)(t.code,{children:"Function.prototype"})," \u2014 that is, ",(0,r.jsx)(t.code,{children:"Object.getPrototypeOf(Constructor) === Function.prototype"}),"."]}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"6-implicit-constructors-of-literals",children:"6. Implicit constructors of literals"}),"\n",(0,r.jsx)(t.p,{children:"Some literal syntaxes in JavaScript create instances that implicitly set the [[Prototype]]. For example:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"Object.getPrototypeOf('hello') === String.prototype; // true\n\nObject.getPrototypeOf(14) === Number.prototype; // true\n\nObject.getPrototypeOf(true) === Boolean.prototype'; // true\n\nObject.getPrototypeOf({ a: 1 }) === Object.prototype; // true\n\nObject.getPrototypeOf(new Error) === Error.prototype; // true\n\nconst array = [1, 2, 3];\nObject.getPrototypeOf(array) === Array.prototype; // true\n\nconst regexp = /abc/;\nObject.getPrototypeOf(regexp) === RegExp.prototype; // true\n"})}),"\n",(0,r.jsx)(t.p,{children:'We can "de-sugar" them into their constructor form.'}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:'const array = new Array(1, 2, 3);\nconst regexp = new RegExp("abc");\n'})}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsxs)(t.h2,{id:"7-default-prototype-instances",children:["7. Default ",(0,r.jsx)(t.code,{children:"prototype"})," instances"]}),"\n",(0,r.jsxs)(t.p,{children:["It may be interesting to note that due to historical reasons, some built-in constructors' ",(0,r.jsx)(t.code,{children:"prototype"})," property are instances themselves.",(0,r.jsx)(t.br,{}),"\n","For example:"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"Number.prototype"})," is a number 0"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"String.prototype"})," is an empty string ''"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"Array.prototype"})," is an empty array"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"RegExp.prototype"})," is /(?:)/"]}),"\n"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:'Number.prototype + 1; // 1\nArray.prototype.map((x) => x + 1); // []\nString.prototype + "a"; // "a"\nRegExp.prototype.source; // "(?:)"\nFunction.prototype(); // Function.prototype is a no-op function by itself\n'})}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsxs)(t.h2,{id:"8-prototypes-version-of-extends",children:["8. ",(0,r.jsx)(t.code,{children:"prototype"}),"'s version of ",(0,r.jsx)(t.code,{children:"extends"})]}),"\n",(0,r.jsxs)(t.p,{children:["We can set the ",(0,r.jsx)(t.code,{children:"[[Prototype]]"})," of ",(0,r.jsx)(t.code,{children:"Constructor.prototype"})," via the ",(0,r.jsx)(t.code,{children:"Object.setPrototypeOf()"})," function:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"function Base() {}\nfunction Derived() {}\n// Set the `[[Prototype]]` of `Derived.prototype`\n// to `Base.prototype`\nObject.setPrototypeOf(Derived.prototype, Base.prototype);\n\nconst obj = new Derived();\n// obj ---\x3e Derived.prototype ---\x3e Base.prototype ---\x3e Object.prototype ---\x3e null\n"})}),"\n",(0,r.jsxs)(t.p,{children:["In class terms, this is equivalent to using the ",(0,r.jsx)(t.code,{children:"extends"})," syntax:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"class Base {}\nclass Derived extends Base {}\n\nconst obj = new Derived();\n// obj ---\x3e Derived.prototype ---\x3e Base.prototype ---\x3e Object.prototype ---\x3e null\n"})}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsxs)(t.h2,{id:"9-prototype-of-arrow-functions",children:["9. ",(0,r.jsx)(t.code,{children:"prototype"})," of arrow functions"]}),"\n",(0,r.jsxs)(t.p,{children:["All functions have a default ",(0,r.jsx)(t.code,{children:"prototype"}),", with one exception: an arrow function doesn't have a default prototype property:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"function doSomething() {}\nconsole.log(doSomething.prototype); // {}\n\nconst doSomethingFromArrowFunction = () => {};\nconsole.log(doSomethingFromArrowFunction.prototype); // undefined\n"})}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"1-objectcreate",children:"1. Object.create"}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.code,{children:"Object.create()"})," is a static method which creates a new empty object."]}),"\n",(0,r.jsxs)(t.admonition,{type:"warning",children:[(0,r.jsx)(t.p,{children:"You may also see some legacy code using Object.create() to build the inheritance chain. However, because this reassigns the prototype property and removes the constructor property, it can be more error-prone, while performance gains may not be apparent if the constructors haven't created any instances yet."}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"function Base() {}\nfunction Derived() {}\n// Re-assigns `Derived.prototype` to a new object\n// with `Base.prototype` as its `[[Prototype]]`\n// DON'T DO THIS \u2014 use Object.setPrototypeOf to mutate it instead\nDerived.prototype = Object.create(Base.prototype);\n"})})]}),"\n",(0,r.jsxs)(t.p,{children:["Its first parameter is an optional ",(0,r.jsx)(t.code,{children:"proto"}),". By passing in ",(0,r.jsx)(t.code,{children:"proto"}),", .... an object as the prototype of the newly created object."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"const map = Object.create(Map.prototype);\nmap.set('key1', 'value1');\nmap.set('key2', 'value2');\nconsole.log(map instanceof Map); // true\nconsole.log(map.get('key1'));    // \"value1\"\n"})})]})}function p(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},7010:(e,t,o)=>{o.d(t,{R:()=>c,x:()=>i});var n=o(758);const r={},s=n.createContext(r);function c(e){const t=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:c(e.components),n.createElement(s.Provider,{value:t},e.children)}}}]);