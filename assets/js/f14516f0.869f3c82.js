"use strict";(self.webpackChunkdocusaurus_guides=self.webpackChunkdocusaurus_guides||[]).push([[98],{5638:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"programming/socket-io/handle-disconnects","title":"Handle Disconnects","description":"1. Introduction","source":"@site/docs/programming/socket-io/handle-disconnects.md","sourceDirName":"programming/socket-io","slug":"/programming/socket-io/handle-disconnects","permalink":"/guides/docs/programming/socket-io/handle-disconnects","draft":false,"unlisted":false,"editUrl":"https://github.com/talkohavy/guides/docs/programming/socket-io/handle-disconnects.md","tags":[],"version":"current","frontMatter":{},"sidebar":"mySidebar","previous":{"title":"- Acknowledgements","permalink":"/guides/docs/programming/socket-io/acknowledgements"},"next":{"title":"- Connection State Recovery","permalink":"/guides/docs/programming/socket-io/connection-state-recovery"}}');var i=t(5813),o=t(3546);const r={},a="Handle Disconnects",c={},l=[{value:"1. Introduction",id:"1-introduction",level:2},{value:"2. Connection state recovery",id:"2-connection-state-recovery",level:2},{value:"3. Server delivery",id:"3-server-delivery",level:2},{value:"4. Client Delivery",id:"4-client-delivery",level:2},{value:"A. Buffered events",id:"a-buffered-events",level:3},{value:"B. At most once",id:"b-at-most-once",level:3},{value:"C. At least once",id:"c-at-least-once",level:3},{value:"D. Exactly once",id:"d-exactly-once",level:3}];function d(e){const n={admonition:"admonition",blockquote:"blockquote",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"handle-disconnects",children:"Handle Disconnects"})}),"\n",(0,i.jsx)(n.h2,{id:"1-introduction",children:"1. Introduction"}),"\n",(0,i.jsx)(n.p,{children:"Now, let's highlight two really important properties of Socket.IO:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"a Socket.IO client is not always connected"}),"\n",(0,i.jsx)(n.li,{children:"a Socket.IO server does not store any event"}),"\n"]}),"\n",(0,i.jsx)(n.admonition,{type:"caution",children:(0,i.jsx)(n.p,{children:"Even over a stable network, it is not possible to maintain a connection alive forever."})}),"\n",(0,i.jsxs)(n.p,{children:["Which means that your application needs to be able to ",(0,i.jsx)(n.strong,{children:"synchronize the local state"})," of the client with the ",(0,i.jsx)(n.strong,{children:"global state on the server"})," after a temporary disconnection."]}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsx)(n.p,{children:"The Socket.IO client will automatically try to reconnect after a small delay. However, any missed event during the disconnection period will effectively be lost for this client."})}),"\n",(0,i.jsx)(n.p,{children:"In the context of our chat application, this implies that a disconnected client might miss some messages:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"response headers",src:t(3523).A+"",width:"662",height:"359"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"2-connection-state-recovery",children:"2. Connection state recovery"}),"\n",(0,i.jsx)(n.p,{children:'First, let\'s handle disconnections by pretending that there was no disconnection: this feature is called "Connection state recovery".'}),"\n",(0,i.jsx)(n.p,{children:"This feature will temporarily store all the events that are sent by the server and will try to restore the state of a client when it reconnects:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"restore its rooms"}),"\n",(0,i.jsx)(n.li,{children:"send any missed events"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"It must be enabled on the server side:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"const io = new Server(server, {\n  // diff-add-start\n  connectionStateRecovery: {}\n  // diff-add-end\n});\n"})}),"\n",(0,i.jsx)(n.p,{children:"Now, you may ask:"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"But this is an awesome feature, why isn't this enabled by default?"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"There are several reasons for this:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"it doesn't always work, for example if the server abruptly crashes or gets restarted, then the client state might not be saved"}),"\n",(0,i.jsx)(n.li,{children:"it is not always possible to enable this feature when scaling up"}),"\n"]}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsx)(n.p,{children:"That being said, it is indeed a great feature since you don't have to synchronize the state of the client after a temporary disconnection (for example, when the user switches from WiFi to 4G)."})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"3-server-delivery",children:"3. Server delivery"}),"\n",(0,i.jsxs)(n.p,{children:['"Server delivery" is all ',(0,i.jsx)(n.em,{children:"about what to do when the client reconnects"}),".",(0,i.jsx)(n.br,{}),"\n","More specifically, ",(0,i.jsx)(n.strong,{children:"how to resume client state after a reconnection"}),'. We use the term "Server delivery" as a context of "the server ',(0,i.jsx)(n.strong,{children:"delivers the state"}),' to the client".']}),"\n",(0,i.jsx)(n.p,{children:"The most common case is:"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["The server was about to send some update/messages to the client, but the client was temporarily disconnected, and is soon to be reconnected with the ",(0,i.jsx)(n.code,{children:"socket.recovered"})," set to true."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"There are two common ways to synchronize the state of the client upon reconnection:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"either the server sends the whole state"}),"\n",(0,i.jsx)(n.li,{children:"or the client keeps track of the last event it has processed and the server sends the missing pieces"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Both are totally valid solutions and choosing one will depend on your use case. In this tutorial, we will go with the latter."}),"\n",(0,i.jsx)(n.p,{children:"First, let's persist the messages of our chat application. We will store each message in a database."}),"\n",(0,i.jsx)(n.p,{children:"In our implementation example, we will use SQLite:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"import express from 'express';\nimport { createServer } from 'node:http';\nimport { fileURLToPath } from 'node:url';\nimport { dirname, join } from 'node:path';\nimport { Server } from 'socket.io';\n// diff-add-start\nimport sqlite3 from 'sqlite3';\nimport { open } from 'sqlite';\n\n// open the database file\nconst db = await open({\n  filename: 'chat.db',\n  driver: sqlite3.Database\n});\n\n// create our 'messages' table (you can ignore the 'client_offset' column for now)\nawait db.exec(`\n  CREATE TABLE IF NOT EXISTS messages (\n      id INTEGER PRIMARY KEY AUTOINCREMENT,\n      client_offset TEXT UNIQUE,\n      content TEXT\n  );\n`);\n// diff-add-end\n\nconst app = express();\nconst server = createServer(app);\nconst io = new Server(server, {\n  connectionStateRecovery: {}\n});\n\nconst __dirname = dirname(fileURLToPath(import.meta.url));\n\napp.get('/', (req, res) => {\n  res.sendFile(join(__dirname, 'index.html'));\n});\n\nio.on('connection', (socket) => {\n  socket.on('chat message', async (msg) => {\n    // diff-add-start\n    let result;\n    try {\n      // store the message in the database\n      result = await db.run('INSERT INTO messages (content) VALUES (?)', msg);\n    } catch (e) {\n      // TODO handle the failure\n      return;\n    }\n    // include the offset with the message\n    io.emit('chat message', msg, result.lastID);\n    // diff-add-end\n  });\n});\n\nserver.listen(3000, () => {\n  console.log('server running at http://localhost:3000');\n});\n"})}),"\n",(0,i.jsx)(n.p,{children:"The client will then keep track of the offset:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-html",children:"<script>\n  // diff-add-start\n  const socket = io({\n    auth: {\n      serverOffset: 0\n    }\n  });\n  // diff-add-end\n\n  const form = document.getElementById('form');\n  const input = document.getElementById('input');\n  const messages = document.getElementById('messages');\n\n  form.addEventListener('submit', (e) => {\n    e.preventDefault();\n    if (input.value) {\n      socket.emit('chat message', input.value);\n      input.value = '';\n    }\n  });\n\n  // diff-add-start\n  socket.on('chat message', (msg, serverOffset) => {\n  // diff-add-end\n    const item = document.createElement('li');\n    item.textContent = msg;\n    messages.appendChild(item);\n    window.scrollTo(0, document.body.scrollHeight);\n    // diff-add-start\n    socket.auth.serverOffset = serverOffset;\n    // diff-add-end\n  });\n<\/script>\n"})}),"\n",(0,i.jsx)(n.p,{children:"And finally the server will send the missing messages upon (re)connection:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"// [...]\n\nio.on('connection', async (socket) => {\n  socket.on('chat message', async (msg) => {\n    let result;\n    try {\n      result = await db.run('INSERT INTO messages (content) VALUES (?)', msg);\n    } catch (e) {\n      // TODO handle the failure\n      return;\n    }\n    io.emit('chat message', msg, result.lastID);\n  });\n\n  // diff-add-start\n  if (!socket.recovered) {\n    // if the connection state recovery was not successful\n    try {\n      await db.each('SELECT id, content FROM messages WHERE id > ?',\n        [socket.handshake.auth.serverOffset || 0],\n        (_err, row) => {\n          socket.emit('chat message', row.content, row.id);\n        }\n      )\n    } catch (e) {\n      // something went wrong\n    }\n  }\n  // diff-add-end\n});\n\n// [...]\n"})}),"\n",(0,i.jsx)(n.p,{children:"As you will notice, it works:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"after a temporary disconnection (of the client)"}),"\n",(0,i.jsx)(n.li,{children:"and after a full page refresh"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"OK, now let's talk about the client delivery."}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"4-client-delivery",children:"4. Client Delivery"}),"\n",(0,i.jsx)(n.p,{children:'"Client delivery" is all about making sure the the server gets our messages sent from the client.'}),"\n",(0,i.jsx)(n.p,{children:"Let's see how we can make sure that the server always receives those messages."}),"\n",(0,i.jsx)(n.h3,{id:"a-buffered-events",children:"A. Buffered events"}),"\n",(0,i.jsxs)(n.p,{children:["When a client gets disconnected, any call to ",(0,i.jsx)(n.code,{children:"socket.emit()"})," is buffered until reconnection:"]}),"\n",(0,i.jsx)(n.p,{children:'When the sender gets disconnected, and is trying to send messages while offline, the "realtime" message is buffered until the connection is reestablished.'}),"\n",(0,i.jsx)(n.p,{children:"This behavior might be totally sufficient for your application. However, there are a few cases where a message could be lost:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Client: the connection is severed while the event is being sent (like a page refresh or tab close)"}),"\n",(0,i.jsx)(n.li,{children:"Server: the server crashes or get restarted while processing the event"}),"\n",(0,i.jsx)(n.li,{children:"Database: the database is temporarily not available"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"b-at-most-once",children:"B. At most once"}),"\n",(0,i.jsx)(n.p,{children:'By default, Socket.IO provides an "at most once" guarantee of delivery (also known as "fire and forget"), which means that there will be no retry in case the message does not reach the server.'}),"\n",(0,i.jsx)(n.h3,{id:"c-at-least-once",children:"C. At least once"}),"\n",(0,i.jsx)(n.p,{children:'We can implement an "at least once" guarantee. using 2 of Socket.IO features:'}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"acknowledgements"}),"\n",(0,i.jsx)(n.li,{children:"ack timeout"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["When opening a connection, one of the options is ",(0,i.jsx)(n.code,{children:"ackTimeout"}),". By default, ",(0,i.jsx)(n.code,{children:"ackTimeout"})," is not set, which means there's no timeout. You can override an ack timeout on a specific ",(0,i.jsx)(n.code,{children:"emit()"})," by using ",(0,i.jsx)(n.code,{children:"socket.timeout(5000).emit(...)"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Implementing ",(0,i.jsx)(n.code,{children:"at least once"})," using manual acknowledgement & an override timeout:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",metastring:'title="frontend"',children:"function emit(socket, event, arg) {\n  socket.timeout(5000).emit(event, arg, (err) => {\n    if (err) {\n      // no ack from the server, let's retry\n      emit(socket, event, arg);\n    }\n  });\n}\n\nemit(socket, 'hello', 'world');\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Implementing ",(0,i.jsx)(n.code,{children:"at least once"})," using automatic acknowledgement of ",(0,i.jsx)(n.code,{children:"retries"})," & an ",(0,i.jsx)(n.code,{children:"ackTimeout"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:["or with the ",(0,i.jsx)(n.code,{children:"retries"})," option:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",metastring:'title="frontend"',children:"const socket = io({\n  ackTimeout: 10000,\n  retries: 3\n});\n\nsocket.emit('hello', 'world');\n"})}),"\n",(0,i.jsx)(n.p,{children:"In both cases, the client will retry to send the message until it gets an acknowledgement from the server:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",metastring:'title="backend"',children:"io.on('connection', (socket) => {\n  socket.on('hello', (value, callback) => {\n    // once the event is successfully handled\n    callback();\n  });\n})\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["With the ",(0,i.jsx)(n.code,{children:"retries"})," option, the order of the messages is guaranteed, as the messages are queued and sent one by one. This is not the case with the first option."]})}),"\n",(0,i.jsx)(n.h3,{id:"d-exactly-once",children:"D. Exactly once"}),"\n",(0,i.jsxs)(n.p,{children:["The problem with ",(0,i.jsx)(n.code,{children:"retries"})," is that the server might now receive the same message multiple times, so it needs a way to uniquely identify each message, and only store it once in the database."]}),"\n",(0,i.jsx)(n.p,{children:'Let\'s see how we can implement an "exactly once" guarantee in our chat application.'}),"\n",(0,i.jsx)(n.p,{children:"We will start by assigning a unique identifier to each message on the client side:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-html",children:"<script>\n  // diff-add-start\n  let counter = 0;\n  // diff-add-end\n\n  const socket = io({\n    auth: {\n      serverOffset: 0\n    },\n    // diff-add-start\n    // enable retries\n    ackTimeout: 10000,\n    retries: 3,\n    // diff-add-end\n  });\n\n  const form = document.getElementById('form');\n  const input = document.getElementById('input');\n  const messages = document.getElementById('messages');\n\n  form.addEventListener('submit', (e) => {\n    e.preventDefault();\n    if (input.value) {\n      // diff-add-start\n      // compute a unique offset\n      const clientOffset = `${socket.id}-${counter++}`;\n      socket.emit('chat message', input.value, clientOffset);\n      // diff-add-end\n      input.value = '';\n    }\n  });\n\n  socket.on('chat message', (msg, serverOffset) => {\n    const item = document.createElement('li');\n    item.textContent = msg;\n    messages.appendChild(item);\n    window.scrollTo(0, document.body.scrollHeight);\n    socket.auth.serverOffset = serverOffset;\n  });\n<\/script>\n"})}),"\n",(0,i.jsxs)(n.admonition,{type:"note",children:[(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"socket.id"})," attribute is a random 20-characters identifier which is assigned to each connection."]}),(0,i.jsxs)(n.p,{children:["We could also have used ",(0,i.jsx)(n.code,{children:"getRandomValues()"})," to generate a unique offset."]})]}),"\n",(0,i.jsx)(n.p,{children:"And then we store this offset alongside the message on the server side:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",metastring:'title="index.ts"',children:"// [...]\n\nio.on('connection', async (socket) => {\n  // diff-add-start\n  socket.on('chat message', async (msg, clientOffset, callback) => {\n  // diff-add-end\n    let result;\n    try {\n      // diff-add-start\n      result = await db.run('INSERT INTO messages (content, client_offset) VALUES (?, ?)', msg, clientOffset);\n      // diff-add-end\n    } catch (e) {\n      // diff-add-start\n      if (e.errno === 19 /* SQLITE_CONSTRAINT */ ) {\n        // the message was already inserted, so we notify the client\n        callback();\n      } else {\n        // nothing to do, just let the client retry\n      }\n      return;\n      // diff-add-end\n    }\n    io.emit('chat message', msg, result.lastID);\n    // diff-add-start\n    // acknowledge the event\n    callback();\n    // diff-add-end\n  });\n\n  if (!socket.recovered) {\n    try {\n      await db.each('SELECT id, content FROM messages WHERE id > ?',\n        [socket.handshake.auth.serverOffset || 0],\n        (_err, row) => {\n          socket.emit('chat message', row.content, row.id);\n        }\n      )\n    } catch (e) {\n      // something went wrong\n    }\n  }\n});\n\n// [...]\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This way, the UNIQUE constraint on the ",(0,i.jsx)(n.code,{children:"client_offset"})," column prevents the duplication of the message."]}),"\n",(0,i.jsxs)(n.admonition,{type:"caution",children:[(0,i.jsxs)(n.p,{children:["Do not forget to acknowledge the event, or else the client will keep retrying (up to ",(0,i.jsx)(n.code,{children:"retries"})," times)."]}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"socket.on('chat message', async (msg, clientOffset, callback) => {\n  // ... and finally\n  callback();\n});\n"})})]}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsx)(n.p,{children:'Again, the default guarantee ("at most once") might be sufficient for your application, but now you know how it can be made more reliable.'})}),"\n",(0,i.jsx)(n.p,{children:"In the next step, we will see how we can scale our application horizontally."})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},3523:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/disconnected-dark-3487a372bd9ee6be4a1c6618d93a53cf.png"},3546:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var s=t(9729);const i={},o=s.createContext(i);function r(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);