"use strict";(self.webpackChunkdocusaurus_guides=self.webpackChunkdocusaurus_guides||[]).push([[2975],{1927:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>h,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"programming/saml","title":"Guide on SAML","description":"1. SAML: The Good Parts","source":"@site/docs/programming/saml.md","sourceDirName":"programming","slug":"/programming/saml","permalink":"/guides/docs/programming/saml","draft":false,"unlisted":false,"editUrl":"https://github.com/talkohavy/guides/docs/programming/saml.md","tags":[],"version":"current","frontMatter":{},"sidebar":"mySidebar","previous":{"title":"- Regex","permalink":"/guides/docs/programming/regex"},"next":{"title":"- Socket IO","permalink":"/guides/docs/socket-io"}}');var i=n(5813),a=n(3546);const r={},o="Guide on SAML",h={},l=[{value:"1. SAML: The Good Parts",id:"1-saml-the-good-parts",level:2},{value:"2. SAML Flow",id:"2-saml-flow",level:2},{value:"3. SAML V.S. OpenID Connect",id:"3-saml-vs-openid-connect",level:2},{value:"4. The SAML Authentication Request",id:"4-the-saml-authentication-request",level:2},{value:"- The Required Fields",id:"--the-required-fields",level:3},{value:"\u2022 Namespace",id:"-namespace",level:4},{value:"\u2022 ID, Version, IssueInstant",id:"-id-version-issueinstant",level:4},{value:"\u2022 Destination",id:"-destination",level:4},{value:"\u2022 AssertionConsumerServiceURL &amp; ProtocolBinding",id:"-assertionconsumerserviceurl--protocolbinding",level:4},{value:"\u2022 Issuer",id:"-issuer",level:4},{value:"- The Optional Fields",id:"--the-optional-fields",level:3},{value:"\u2022 ForceAuthn",id:"-forceauthn",level:4},{value:"\u2022 RequestedAuthnContext",id:"-requestedauthncontext",level:4},{value:"\u2022 IDPList",id:"-idplist",level:4},{value:"5. The SAML Response &amp; Assertion",id:"5-the-saml-response--assertion",level:2},{value:"\u2022 Subject",id:"-subject",level:4},{value:"\u2022 AuthnStatement",id:"-authnstatement",level:4},{value:"\u2022 NameID",id:"-nameid",level:4},{value:"6. SAML Signing",id:"6-saml-signing",level:2},{value:"- A. What Signing give you",id:"--a-what-signing-give-you",level:3},{value:"- B. Signing a SAML Authentication Request",id:"--b-signing-a-saml-authentication-request",level:3},{value:"- C. Signing a SAML Response",id:"--c-signing-a-saml-response",level:3},{value:"7. Quick Summary",id:"7-quick-summary",level:2}];function c(e){const t={a:"a",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"guide-on-saml",children:"Guide on SAML"})}),"\n",(0,i.jsx)(t.h2,{id:"1-saml-the-good-parts",children:"1. SAML: The Good Parts"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Web SSO"}),"\n",(0,i.jsx)(t.li,{children:"SLO (Single-Log-Out)"}),"\n",(0,i.jsx)(t.li,{children:"Artifact Binding"}),"\n"]}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"2-saml-flow",children:"2. SAML Flow"}),"\n",(0,i.jsx)(t.p,{children:'The user access an application in the browser, and says "hey i would like to use this website". He now needs to authenticate. The service provider then generates a SAML AuthenticationRequest, and sends it to the IdP. Upon successful authentication, the IdP sends back a SAML Response, containing an Assertion that describes the user.'}),"\n",(0,i.jsxs)(t.p,{children:["For Web SSO, the SAML AuthenticationRequest is sent directly to the IdP\u2019s Single-Sign-On endpoint, and the response is sent to the service provider\u2019s ",(0,i.jsx)(t.strong,{children:"Assertion Consumer Service Endpoint"}),', otherwise known as the ACS Endpoint. You can also send a RelayState, which gets round-tripped between the SP and the IdP. This is like a State parameter, which was initially designed for remembering information about the initial request that the user made. For instance, it could say "Hey, before the user sent the authentication request, he was trying to access the /accounts page".']}),"\n",(0,i.jsx)(t.p,{children:"This is a full browser redirect, where the user finds himself meeting a login page. Once they authenticate themselves, the IdP will generate a SAML response, that will contain what\u2019s known as a SAML assertion. The assertion will contain details about how the user authenticated, and the user\u2019s identity. Again, this is a redirect where the service provider finds itself with both the SAML response and the user themselves. If everything checks out, the service provider can start a session for the user, provide them with a cookie, and let them in."}),"\n",(0,i.jsx)(t.p,{children:"The next service provider that the user attempts to use will again create a SAML authentication request, and redirect to the identity provider. However, this time the identity provider already knows who the user is. The user has their own single-sign-on session with the identity provider. As a result, the identity provider will automatically create a response and assertion without the need for user interaction."}),"\n",(0,i.jsx)(t.h2,{id:"3-saml-vs-openid-connect",children:"3. SAML V.S. OpenID Connect"}),"\n",(0,i.jsx)(t.p,{children:"..."}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"4-the-saml-authentication-request",children:"4. The SAML Authentication Request"}),"\n",(0,i.jsx)(t.h3,{id:"--the-required-fields",children:"- The Required Fields"}),"\n",(0,i.jsx)(t.p,{children:"The attribute & elements mentioned below are the bare minimum of what a SAML AuthenticationRequest should include:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-xml",children:'<saml2p:AuthnRequest\n  xmlns:saml2p="urn:oasis:names:tc:SAML:2.0:protocol"\n  xmlns:saml2p="urn:oasis:names:tc:SAML:2.0:assertion"\n  ID="_e3jyf1c2"\n  Version="2.0"\n  IssueInstant="2020-08-21T09:24:16Z"\n  Destination="https://idp.local/saml/sso"\n  AssertionConsumerServiceURL="https://idp.local/saml/acs"\n  ProtocolBinding="urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST"\n>\n    <saml2:Issuer>https://sp.local</saml2:Issuer>\n</saml2p:AuthnRequest>\n'})}),"\n",(0,i.jsx)(t.h4,{id:"-namespace",children:"\u2022 Namespace"}),"\n",(0,i.jsxs)(t.p,{children:["Since this is our first SAML message, let's take note of the 2 xml namespaces of ",(0,i.jsx)(t.code,{children:"SAML protocol"})," and ",(0,i.jsx)(t.code,{children:"SAML assertion"}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'xmlns:saml2p="urn:oasis:names:tc:SAML:2.0:protocol"\nxmlns:saml2p="urn:oasis:names:tc:SAML:2.0:assertion"\n'})}),"\n",(0,i.jsxs)(t.p,{children:["Typically, the outer elements describe the ",(0,i.jsx)(t.strong,{children:"protocol message"})," fall under the ",(0,i.jsx)(t.code,{children:"protocol namespace"})," (saml2p), where-as the inner elements that describe ",(0,i.jsx)(t.strong,{children:"the issuer/user"})," fall under the ",(0,i.jsx)(t.code,{children:"assertion namespace"})," (saml2)."]}),"\n",(0,i.jsx)(t.p,{children:"The namespace prefix can be anything you want within reason. There are some outdated integration documents out there that will require you to to use specific prefixes they came up with."}),"\n",(0,i.jsx)(t.h4,{id:"-id-version-issueinstant",children:"\u2022 ID, Version, IssueInstant"}),"\n",(0,i.jsx)(t.p,{children:"Now for the first 3 attributes on the SAML protocol message:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'ID="_e3jyf1c2"\nVersion="2.0"\nIssueInstant="2020-08-21T09:24:16Z"\n'})}),"\n",(0,i.jsxs)(t.p,{children:["This 3 attributes are required for every single SAML message type, from ",(0,i.jsx)(t.strong,{children:"AuthenticationRequests"})," to ",(0,i.jsx)(t.strong,{children:"LogoutResponses"}),"."]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"ID"})," = An id for the specific request. A request id."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Version"})," = The version of the SAML protocol."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"IssueInstant"})," = The UTC datetime for when the message was created."]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["While some SAML messages allow you to include an explicit expiry, it's good practice to evaluate the ",(0,i.jsx)(t.code,{children:"IssueInstant"})," independently. For instance, if you received a request that is over 30 minutes old, then it's a good signal that something is amiss and that you should no longer trust the request."]}),"\n",(0,i.jsx)(t.h4,{id:"-destination",children:"\u2022 Destination"}),"\n",(0,i.jsxs)(t.p,{children:["Another value present on all SAML messages is the ",(0,i.jsx)(t.code,{children:"Destination"})," attribute."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'Destination="https://idp.local/saml/sso"\n'})}),"\n",(0,i.jsxs)(t.p,{children:["This attribute's value should be ",(0,i.jsx)(t.em,{children:"the URL to which this message was sent to"}),". Officially? This attribute is optional, but without it, the message contains no indication of who it is intended for. If this value is not what you'd expect, that's another signal that something is wrong, and that you should stop processing the request. Unfortunately, ",(0,i.jsx)(t.em,{children:"because"})," this is optional within the SAML specification, not everyone support this attribute. For a modern SAML implementation, I would recommend requiring the ",(0,i.jsx)(t.code,{children:"Destination"})," attribute when validating SAML messages, and merely ",(0,i.jsx)(t.em,{children:"disable"})," the validation step for those providers that do not support it."]}),"\n",(0,i.jsx)(t.h4,{id:"-assertionconsumerserviceurl--protocolbinding",children:"\u2022 AssertionConsumerServiceURL & ProtocolBinding"}),"\n",(0,i.jsxs)(t.p,{children:["Now let's move on to ",(0,i.jsx)(t.strong,{children:"attributes"})," specific to ",(0,i.jsx)(t.strong,{children:"authentication requests"}),", which are the ",(0,i.jsx)(t.code,{children:"AssertionConsumerServiceURL"})," & the ",(0,i.jsx)(t.code,{children:"ProtocolBinding"}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'AssertionConsumerServiceURL="https://idp.local/saml/acs"\nProtocolBinding="urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST"\n'})}),"\n",(0,i.jsxs)(t.p,{children:["These are two things which the ",(0,i.jsx)(t.strong,{children:"Service Provider"})," describes to the ",(0,i.jsx)(t.strong,{children:"Identity Provider"}),", about where it wants the response to be sent to, and how it wants the response to be sent. This is using one of the ",(0,i.jsx)(t.code,{children:"ProtocolBinding"})," types we saw earlier. An ",(0,i.jsx)(t.code,{children:"AssertionConsumerServiceURL"})," (ACS) and its associating binding types, must be known to the ",(0,i.jsx)(t.strong,{children:"Identity Provider"})," ahead of time. These cannot be arbitrary URLs that you want the user to be redirected to after login, but rather an endpoint dedicated to handling SAML responses and assertions. These do not always need to be sent together. Only one can be present, at which point the identity provider is expected to figure out the missing piece.That being said, you typically see these sent together.",(0,i.jsx)(t.br,{}),"\n","An alternative to the ACS URL and ",(0,i.jsx)(t.code,{children:"ProtocolBinding"}),", is the ",(0,i.jsx)(t.code,{children:"AssertionConsumerServiceIndex"}),". This references a URL and binding pair by its index, by it's unique identifier. This approach is not as common as the explicit URL and binding type. If none of these 3 are present in an authentication request, the identity provider will use the default ACS url and binding type, that has been configured for that service provider."]}),"\n",(0,i.jsx)(t.h4,{id:"-issuer",children:"\u2022 Issuer"}),"\n",(0,i.jsxs)(t.p,{children:["And finally, for a standard authentication request, you have the ",(0,i.jsx)(t.strong,{children:"Issuer"})," element:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-xml",children:"<saml2:Issuer>https://sp.local</saml2:Issuer>\n"})}),"\n",(0,i.jsx)(t.p,{children:"This value contains the SP's ID, not the user ID! It's the ID of the service provided which created the SAML authentication request. This ID is, of course, known to the IDP ahead of time. Without this, the Identity Provider won't understand who is making the request, or how to validate it."}),"\n",(0,i.jsx)(t.h3,{id:"--the-optional-fields",children:"- The Optional Fields"}),"\n",(0,i.jsx)(t.p,{children:"Now that we've seen how a standard request looks like, let's take a quick look at some of the popular optional extras that can be used to override the default behavior of an identity provider."}),"\n",(0,i.jsx)(t.h4,{id:"-forceauthn",children:"\u2022 ForceAuthn"}),"\n",(0,i.jsxs)(t.p,{children:["This is a boolean value. As its name suggests, ",(0,i.jsx)(t.strong,{children:"ForceAuthn"})," is where the service provider's ",(0,i.jsx)(t.em,{children:"asking the identity provider to force authentication, even if the user has a an active single-sign-on session"}),", ignore that, and ask to re-authenticate. Forcing the user to re-identify themselves again can be really useful, when the service provider is authorizing access to a particularly sensitive data. For example, let's say the user is trying to access the service provider's admin area, but they haven't proven their identity in the last 6 hours. As a result, the SP is dubious that the original user is still using their application, and issues a SAML authentication request containing the ",(0,i.jsx)(t.strong,{children:"ForceAuthn"})," attribute."]}),"\n",(0,i.jsx)(t.h4,{id:"-requestedauthncontext",children:"\u2022 RequestedAuthnContext"}),"\n",(0,i.jsxs)(t.p,{children:["A similar concept to the ",(0,i.jsx)(t.strong,{children:"ForceAuthn"})," is the ",(0,i.jsx)(t.strong,{children:"RequestedAuthnContext"}),". Whereas ",(0,i.jsx)(t.strong,{children:"ForceAuthn"})," asks the user to re-authenticate, the ",(0,i.jsx)(t.strong,{children:"RequestedAuthnContext"})," ensuures that the user authenticates in a particular way. For instance, that they use a second factor. By default, the user must have authenticated using at least one of the requested methods. This can be overridden using the ",(0,i.jsx)(t.strong,{children:"Comparison"})," attribute, where alternative values are ",(0,i.jsx)(t.code,{children:"minimum"}),", ",(0,i.jsx)(t.code,{children:"better"}),", or the slightly bizarre ",(0,i.jsx)(t.code,{children:"maximum"}),"."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"Comparison (`minimum`, `better`, `maximum`)\n"})}),"\n",(0,i.jsx)(t.p,{children:"Typically, you only see exact."}),"\n",(0,i.jsx)(t.h4,{id:"-idplist",children:"\u2022 IDPList"}),"\n",(0,i.jsxs)(t.p,{children:["This IDPList allows for home realm discovery. A technique where the service provider can ask the identity provider to authenticate the user using a specific upstream identify provider. For example, let's say that the SP wants its identity provider to authenticate the user using Google's social authentication. By specifying this in the IDPList, the service provider let's the identity provider know that it can skip the login screen, where the user ",(0,i.jsx)(t.em,{children:"could"})," authenticate using local credentials, or... let's say Facebook, and instead send them directly to Google. In the same was as ",(0,i.jsx)(t.strong,{children:"ForceAuthn"}),", this can also be useful for security decisions. Let's examine the Admin portal example once again. This is somewhere that wouldn't trust users who authenticated using their social media account. It might require that users authenticate using their corporate Active Directory credentials. This is where defining an IDPList comes in handy, by, again, ignoring the current SSO session, and ensuring that a specific identity provider re-authenticates the user."]}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"5-the-saml-response--assertion",children:"5. The SAML Response & Assertion"}),"\n",(0,i.jsx)(t.p,{children:"Let's take a look at a typical SAML response & assertion:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-xml",children:'<saml2p:Response\n    xmlns:saml2p="urn:oasis:names:tc:SAML:2.0:protocol"\n    xmlns:saml2="urn:oasis:names:tc:SAML:2.0:protocol"\n    ID="3Dg45X1H"\n    Version="2.0"\n    IssueInstant="2020-08-21T09:24:16Z"\n    Destination="https://localhost:5001/saml/acs"\n    InResponseTo="_e3jyf1c2"\n>\n    \x3c!-- The Issuer: --\x3e\n    <saml2:Issuer>https://localhost:5000</saml2:Issuer>\n\n    \x3c!-- The Status: --\x3e\n    <saml2p:Status>\n        <saml2p:StatusCode Value="urn:oasis:names:tc:SAML:2.0:status:Success" />\n    </saml2p:Status>\n\n    \x3c!-- The Assertion: --\x3e\n    <saml2p:Assertion\n        ID="_e3jyf1c2"\n        Version="2.0"\n        IssueInstant="2020-08-21T09:24:16Z"\n    >\n\n        \x3c!-- The Issuer: --\x3e\n        <saml2:Issuer>https://localhost:5000</saml2:Issuer>\n\n        \x3c!-- The Subject (a.k.a. the user): --\x3e\n        <saml2:Subject>\n\n            \x3c!-- The user\'s name id --\x3e\n            <saml2:NameID Format="urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified">\n                4732361818\n            </saml2:NameID>\n\n            \x3c!-- The user\'s name id --\x3e\n            <saml2:SubjectConfirmation Method="urn:oasis:names:tc:SAML:2.0:cm:bearer">\n\n                \x3c!-- The user\'s confirmation data --\x3e\n                <saml2:SubjectConfirmationData\n                    NotOnOrAfter="2020-08-21T09:24:16Z"\n                    InResponseTo="_e3jyf1c2"\n                    Recipient="https://localhost:5001/saml/acs"\n                />\n\n            </saml2:SubjectConfirmation>\n\n        </saml2:Subject>\n\n        \x3c!-- Conditions --\x3e\n        <saml2:Conditions\n            NotBefore="2020-08-21T09:24:16Z"\n            NotOnOrAfter="2020-08-21T09:24:16Z"\n        >\n\n            \x3c!-- AudienceRestriction --\x3e\n            <saml2:AudienceRestriction\n                NotBefore="2020-08-21T09:24:16Z"\n                NotOnOrAfter="2020-08-21T09:24:16Z"\n            >\n\n                \x3c!-- Audience --\x3e\n                <saml2:Audience>https://localhost:5001</saml2:Audience>\n\n            </saml2:AudienceRestriction>\n\n        </saml2:Conditions>\n\n        \x3c!-- Attribute Statement --\x3e\n        <saml2:AttributeStatement>\n\n            \x3c!-- Attribute Value 1 --\x3e\n            <saml2:Attribute Name="urn:oasis:names:tc:SAML:attribute:pairwise-id">\n                <saml2:AttributeValue>c8b7bc2981d</saml2:AttributeValue>\n            </saml2:Attribute>\n\n            \x3c!-- Attribute Value 2 --\x3e\n            <saml2:Attribute Name="https://...">\n                <saml2:AttributeValue>Scott Johnson</saml2:AttributeValue>\n            </saml2:Attribute>\n\n        </saml2:AttributeStatement>\n\n        \x3c!-- Authentication Statement --\x3e\n        <saml2:AuthnStatement\n            AuthnInstant="2020-10-21-T13:13:13Z"\n            SessionIndex="_af123"\n        >\n\n            \x3c!-- Authentication Context --\x3e\n            <saml2:AuthnContext>\n\n                \x3c!-- Authentication Context Class Ref --\x3e\n                <saml2:AuthnContextClassRef>\n                    "urn:oasis:names:tc:SAML:2.0:ac:classes:Password"\n                </saml2:AuthnContextClassRef>\n\n            </saml2:AuthnContext>\n\n        </saml2:AuthnStatement>\n\n\n\n    </saml2p:Assertion>\n\n\n</saml2p:Response>\n'})}),"\n",(0,i.jsxs)(t.p,{children:["The outer element is the SAML response.",(0,i.jsx)(t.br,{}),"\n","This is always the protocol message type returned to a service provider when responding to an AuthenticationRequest. This is true for both success and failure. By now you should be able to recognize most of the initial attributes from the authentication request that you saw before."]}),"\n",(0,i.jsxs)(t.p,{children:["Just like the ",(0,i.jsx)(t.code,{children:"request"}),", the ",(0,i.jsx)(t.code,{children:"response"})," uses the SAML ",(0,i.jsx)(t.code,{children:"protocol"})," and ",(0,i.jsx)(t.code,{children:"assertion"})," namespaces. It has ",(0,i.jsx)(t.strong,{children:"ID"}),", ",(0,i.jsx)(t.strong,{children:"Version"}),", and ",(0,i.jsx)(t.strong,{children:"IssueInstant"})," attributes, and an optional ",(0,i.jsx)(t.strong,{children:"Destination"})," attribute, which this time points at an assertion consumer service endpoint (ACS) on the service provider."]}),"\n",(0,i.jsxs)(t.p,{children:["A ",(0,i.jsx)(t.code,{children:"response"})," also contains the ",(0,i.jsx)(t.strong,{children:"InResponseTo"})," value. When responding to an authentication request, this attributes must be present, and must match the ID of the original authentication request. The ",(0,i.jsx)(t.strong,{children:"InResponseTo"})," value is essential to validation. By linking a response to an individual request, you prevent the injection of stolen responses. This would involve a similar process to the RelayState we saw earlier, but unlike the RelayState, ",(0,i.jsx)(t.strong,{children:"InResponseTo"})," is always included in the SAML messages themselves."]}),"\n",(0,i.jsxs)(t.p,{children:["A SAML response also contains an ",(0,i.jsx)(t.strong,{children:"Issuer"})," element, however this time it is the entity ID of the identity provider, because that is who is generating the SAML message."]}),"\n",(0,i.jsxs)(t.p,{children:["SAML authentication doesn't always go to plan, which is why SAML responses also contain a ",(0,i.jsx)(t.strong,{children:"Status"})," element. This itself contains a ",(0,i.jsx)(t.strong,{children:"StatusCode"}),", an optional ",(0,i.jsx)(t.strong,{children:"StatusMessage"}),", which can often be displayed to the user, and an optional ",(0,i.jsx)(t.strong,{children:"StatusDetails"}),". If this a success response, then we have a success ",(0,i.jsx)(t.strong,{children:"StatusCode"}),". And if things go wrong, you can send back one of the many error ",(0,i.jsx)(t.strong,{children:"StatusCode"}),"s, a ",(0,i.jsx)(t.strong,{children:"StatusMessage"}),", and a ",(0,i.jsx)(t.strong,{children:"StatusDetails"}),".",(0,i.jsx)(t.br,{}),"\n","In my experience, while there may be many ErrorStatus in the SAML specification, what mainly matters to the SP is whether or not the response was a success. ",(0,i.jsx)(t.em,{children:"In order to be a valid response, the response MUST contains an assertion"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["An ",(0,i.jsx)(t.strong,{children:"assertion"})," is yet another XML construct. The assertion has its own ",(0,i.jsx)(t.strong,{children:"ID"}),", ",(0,i.jsx)(t.strong,{children:"IssueInstant"}),", and ",(0,i.jsx)(t.strong,{children:"Issuer"}),". This is because a SAML response can contain many assertions, and not all necessarily from the same place."]}),"\n",(0,i.jsxs)(t.p,{children:["At the beginning of this course, we said that we would only talk about modern SAML implementations, focusing on Single-Sign-On use cases. As a result, we're going to move forward with the assumption that ",(0,i.jsx)(t.strong,{children:"a SAML response will only ever contain a single SAML assertion, and that it represents a user"}),"."]}),"\n",(0,i.jsx)(t.p,{children:"This covers our SSO scenario."}),"\n",(0,i.jsxs)(t.p,{children:["A SAML assertion contains a ",(0,i.jsx)(t.strong,{children:"Subject"}),", ",(0,i.jsx)(t.strong,{children:"Conditions"}),", an ",(0,i.jsx)(t.strong,{children:"AttributeStatement"}),", and an ",(0,i.jsx)(t.strong,{children:"AuthnStatement"}),"."]}),"\n",(0,i.jsx)(t.h4,{id:"-subject",children:"\u2022 Subject"}),"\n",(0,i.jsxs)(t.p,{children:["The Subject contains the ID of the principal. Our user. The one which our assertion describes. It also contains some details about how you should verify that Subject. Then there's the NameID, which contains a value that represents the user, and the format that value is in. You can then confirm the subject by using the method specified in the ",(0,i.jsx)(t.strong,{children:"SubjectConfirmation"}),". In this case it uses the ",(0,i.jsx)(t.code,{children:"Bearer"})," method, which means that possession of the assertion and the subject is enough to verify the assertion, and that you don't need to perform any further actions other than some basic data validation here. An alternative might be to use some sort of proof-of-possession technique, where an assertion and its subject could be further verified to ensure that it was not injected into the browser session in some way."]}),"\n",(0,i.jsx)(t.h4,{id:"-authnstatement",children:"\u2022 AuthnStatement"}),"\n",(0,i.jsx)(t.p,{children:"Describe the authentication event itself. The AuthnInstant value tells you when the user last authenticated themselves. This can be useful for long-lived Single-Sign-On sessions, where the user only authenticates once a day. If you think back to our admin portal use-case, where the service provider decided to force re-authentication this is the value that informed that decision."}),"\n",(0,i.jsxs)(t.p,{children:["We then have a ",(0,i.jsx)(t.strong,{children:"SessionIndex"}),", which is the ID of the user's Single-Sign-On session at the identity provider. And we'll see this again when we'll discuss ",(0,i.jsx)(t.strong,{children:"Single-Log-Out"}),". This may often times be accompanied by a session ",(0,i.jsx)(t.code,{children:"NotOnOrAfter"})," attribute, which is when the user session will end within the identity provider. The service provider could end their session at the same time, but it is not mandatory."]}),"\n",(0,i.jsxs)(t.p,{children:["Another useful bit of data is the ",(0,i.jsx)(t.strong,{children:"AuthnContext"}),". This describes how the user authenticated using the same values as we saw in the authentication request's requested AuthnContext. If your service provider asks for a specific kind of an authentication mechanism, then this is the value it will need to check to ensure that the identity provider did what it asked."]}),"\n",(0,i.jsxs)(t.p,{children:["Last but not least we have the identity data itself in the form of an ",(0,i.jsx)(t.strong,{children:"AttributeStatement"}),". This contains many attributes that describe the user's identity. If you come from an OpenID Connect background, these are pretty much ",(0,i.jsx)(t.strong,{children:"claims"}),". Name-value pairs where the name is the type. With SAML you can add more context to the attribute name with an optional NameID format, and a friendly name."]}),"\n",(0,i.jsx)(t.h4,{id:"-nameid",children:"\u2022 NameID"}),"\n",(0,i.jsx)(t.p,{children:"SAML name identifiers are another large part of the SAML specification, that has changed over time to be a lot simpler. In the original specification, SAML defines many different NameID formats and ways to resolve or manage to NameID. However, many SAML implementation take a similar approach to modern protocols, such as OpenID Connect. Rather than support many different formats, the identity provider simply uses the unique ID they hold for that user. This ID should not contain personal information, such as the user's name or email address, and it should not be changeable. As a result, you can get away with using the unspecified NameID format, which leaves it to the recipient to decide how to handle it and any account linking or creation processes. For large-scale identity providers who have concerns about users being tracked across service providers, you can use a pair-wise identifier. This is defined be newer SAML specifications, and allows you to issue a user a unique identifier per service provider. This means that a service provider will always receive the same ID for a specific user, but the same user in another service provider would be represented by a different ID."}),"\n",(0,i.jsxs)(t.p,{children:["Some systems require the ",(0,i.jsx)(t.strong,{children:"Email Address"})," as the ",(0,i.jsx)(t.strong,{children:"NameID"}),". This can be supported using the email address NameID format, but be aware that you are now using a personal insformation as a unique identifier, and that email addresses can be changed. I recommend avoiding the email address as the NameID wherever possible, and only using an email address as the NameID when dealing with SAML implementations that require it."]}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"6-saml-signing",children:"6. SAML Signing"}),"\n",(0,i.jsx)(t.h3,{id:"--a-what-signing-give-you",children:"- A. What Signing give you"}),"\n",(0,i.jsx)(t.p,{children:"As an extra measure of security, the SP and the IDP exchange public keys, and sign messages going back and forth from one another. Yes, you could and should implement the transport layer security, (TLS = Transport Layer Security), but that will only protect the payload while it is in transit. It also doesn't help when you have multiple third parties, who could potentially impersonate one another. This all means that you need some sort of message-level protection, which your applications can verify using provider-specific data, long after transport security has been terminated. SAML achieves this using XML digital signatures and public key cryptography. To create a signature the issuer of the message first runs the message through a hash function, and uses that to create a signature, generated using a private key, that only they know. It then embeds that signature within the message it signed:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-xml",children:"<message>\n    <Signature />\n</message>\n"})}),"\n",(0,i.jsx)(t.p,{children:"When the recipient receives the signed message, it runs it through the same hashing algorithm as the issuer, and uses the issuer's public key to verify the signature. If it validates, this proves that the data was not tempered with, and that it was issued by the known trusted party. An XML signature element typically looks like this:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-xml",children:'<Signature xmlns="http://www.w3.org/2000/09/xmldsig#">\n    <signedInfo>\n        \x3c!-- Canonicalization Method --\x3e\n        <CanonicalizationMethod Algorithm="http://..." />\n\n        \x3c!-- Signature Method --\x3e\n        <SignatureMethod Algorithm="http://..." />\n\n        \x3c!-- Reference --\x3e\n        <Reference URI="#_af23e-7f08-e3bg">\n\n            \x3c!-- Transformation Algorithms --\x3e\n            <Transforms>\n\n                \x3c!-- Algorithm 1 --\x3e\n                <Transform Algorithm="http://..." />\n\n                \x3c!-- Algorithm 2 --\x3e\n                <Transform Algorithm="http://..." />\n\n            </Transforms>\n\n            <DigestMethod Algorithm="http://...#sha256" />\n\n            <DigestValue>mo4/6DT2mT5...KLi=</DigestValue>\n        </Reference>\n    </signedInfo>\n\n    \x3c!-- Signature Value --\x3e\n    <SignatureValue>xmY0cs3gglPjjETZ...fVQ</SignatureValue>\n</Signature>\n'})}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.strong,{children:"SignedInfo"})," element describing how the signature was created, and the ",(0,i.jsx)(t.strong,{children:"SignatureValue"})," containing the signature itself."]}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.strong,{children:"Canonicalization"})," & ",(0,i.jsx)(t.strong,{children:"Transforms"})," tell you how to encode the XML, so that you can generate the exact same value to pass into that hashing algorithm, as the issuer did. In SAML, canonicalization is always exclusive, with or without comments. Transforms are always envelope signatures, and/or exclusive canonicalization. SAML XML signatures must also have a ",(0,i.jsx)(t.strong,{children:"Reference"})," value (the URI above) that contains the ID of the element that the signature is for. This MUST reference the parent element of the signature."]}),"\n",(0,i.jsxs)(t.p,{children:["We also have the signing algorithm (",(0,i.jsx)(t.strong,{children:"SignatureMethod"}),") that was used to generate the signature. In this case we have rsa-sha256, which means that we used the sha256 hashing algorithm to generate the hash, and RSA for signature generation and validation."]}),"\n",(0,i.jsxs)(t.p,{children:["Signature elements can also contain a ",(0,i.jsx)(t.strong,{children:"KeyInfo"})," element, which describes the public key the recipient should use to validate the signature. This can contain hints like a key name, but if it contains an actual key, you should only use it as a hint or for debugging. You MUST NOT use it to verify the signature. Keys embedded in the payload itself could have been placed there by an attacker. Only ever trust keys that were provided to you ahead of time."]}),"\n",(0,i.jsx)(t.h3,{id:"--b-signing-a-saml-authentication-request",children:"- B. Signing a SAML Authentication Request"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Should I sign everything?"})}),"\n",(0,i.jsx)(t.p,{children:"So digital signatures offer a major benefit to the overall security of SAML, but does that mean you need to sign everything?"}),"\n",(0,i.jsx)(t.p,{children:"Let's start with a SAML authentication request:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-xml",children:'\x3c!-- I copy-pasted this from above! --\x3e\n<saml2p:AuthnRequest\n  xmlns:saml2p="urn:oasis:names:tc:SAML:2.0:protocol"\n  xmlns:saml2p="urn:oasis:names:tc:SAML:2.0:assertion"\n  ID="_e3jyf1c2"\n  Version="2.0"\n  IssueInstant="2020-08-21T09:24:16Z"\n  Destination="https://idp.local/saml/sso"\n  AssertionConsumerServiceURL="https://idp.local/saml/acs"\n  ProtocolBinding="urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST"\n>\n    <saml2:Issuer>https://sp.local</saml2:Issuer>\n</saml2p:AuthnRequest>\n'})}),"\n",(0,i.jsxs)(t.p,{children:["If this was unsigned, what could and attacker do with it?",(0,i.jsx)(t.br,{}),"\n","To be fair? There isn't that much of an attack vector here. The urls of the request (Destination, AssertionConsumerServiceURL, and saml2",":Issuer",") are not arbitrary values. They're all agreed upon ahead of time. If the service provider implemented the cross-site request forgery countermeasures we saw earlier then it is unlikely that modifying the request ID to perform any injection attacks would be possible."]}),"\n",(0,i.jsx)(t.p,{children:"The benefits to signing authentication requests are:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"Prevent service provider impersonation. It is ensuring that only the service provider can request SAML assertions, and that a malicious third-party cannot."}),"\n",(0,i.jsx)(t.li,{children:"User data leakage. This keeps user data out of the hands of an attacker. However you could argue that assertion encryption would also give you this protection, albeit after user authentication."}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"In my experience i've seen a 50-50 split in variations in integrations that require SAML request signing. Personally, I recommend enabling it by default, and only ever disabling it for those providers who cannot support it."}),"\n",(0,i.jsx)(t.h3,{id:"--c-signing-a-saml-response",children:"- C. Signing a SAML Response"}),"\n",(0,i.jsxs)(t.p,{children:["This one is a lot more obvious. If you don't sign this, the attacker could modify the NameID, and attributes, to impersonate any user, but which part do you sign? The response? Just the assertion? Or both? ",(0,i.jsx)(t.a,{href:"#5-the-saml-response--assertion",children:"Recall the SAML Response format here"})]}),"\n",(0,i.jsxs)(t.p,{children:["If you sign the ",(0,i.jsx)(t.strong,{children:"entire response message"}),", then you are inherently also protecting the ",(0,i.jsx)(t.strong,{children:"assertion"}),". But what if the ",(0,i.jsx)(t.strong,{children:"assertion"})," needs to be refused at some point? After all, it is designed for that, with its own set of timings, validation, and confirmation conditions. In this case you would end up with some unsigned XML, where those values and the user data can start being modified again."]}),"\n",(0,i.jsxs)(t.p,{children:["But if you only sign the ",(0,i.jsx)(t.strong,{children:"assertion"}),", how do you trust the outer response?"]}),"\n",(0,i.jsxs)(t.p,{children:["My advice is to always sign the ",(0,i.jsx)(t.strong,{children:"assertion"})," itself, and the ",(0,i.jsx)(t.strong,{children:"outer most element"})," that contains the assertion."]}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"7-quick-summary",children:"7. Quick Summary"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"AssertionConsumerServiceUrl"})," = Where they want the response to be returned to."]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["When someone asks you what protocols you support, you can confidently say:",(0,i.jsx)(t.br,{}),"\n",(0,i.jsx)(t.em,{children:'"I support/implemented SAML 2.0 Web SSO Profile"'})]})]})}function d(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},3546:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>o});var s=n(9729);const i={},a=s.createContext(i);function r(e){const t=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(a.Provider,{value:t},e.children)}}}]);