"use strict";(self.webpackChunkdocusaurus_guides=self.webpackChunkdocusaurus_guides||[]).push([[8842],{9408:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"programming/socket-io/scaling-horizontally","title":"Scaling horizontally","description":"Now that our application is resilient to temporary network interruptions, let\'s see how we can horizontally scale it in order to be able to support thousands of concurrent clients.","source":"@site/docs/programming/socket-io/scaling-horizontally.md","sourceDirName":"programming/socket-io","slug":"/programming/socket-io/scaling-horizontally","permalink":"/guides/docs/programming/socket-io/scaling-horizontally","draft":false,"unlisted":false,"editUrl":"https://github.com/talkohavy/guides/docs/programming/socket-io/scaling-horizontally.md","tags":[],"version":"current","frontMatter":{},"sidebar":"mySidebar","previous":{"title":"- Handle Disconnects","permalink":"/guides/docs/programming/socket-io/handle-disconnects"},"next":{"title":"- Software Concepts","permalink":"/guides/docs/software-concepts"}}');var o=t(6070),s=t(7010);const i={},a="Scaling horizontally",l={},c=[];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",header:"header",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"scaling-horizontally",children:"Scaling horizontally"})}),"\n",(0,o.jsx)(n.p,{children:"Now that our application is resilient to temporary network interruptions, let's see how we can horizontally scale it in order to be able to support thousands of concurrent clients."}),"\n",(0,o.jsx)(n.admonition,{type:"note",children:(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:'Horizontal scaling (also known as "scaling out") means adding new servers to your infrastructure to cope with new demands'}),"\n",(0,o.jsx)(n.li,{children:'Vertical scaling (also known as "scaling up") means adding more resources (processing power, memory, storage, ...) to your existing infrastructure'}),"\n"]})}),"\n",(0,o.jsxs)(n.p,{children:["First step: let's use all the available cores of the host. By default, Node.js runs your Javascript code in a single thread, which means that even with a 32-core CPU, only one core will be used. Fortunately, the Node.js ",(0,o.jsx)(n.code,{children:"cluster"})," module provides a convenient way to create one worker thread per core."]}),"\n",(0,o.jsx)(n.p,{children:'We will also need a way to forward events between the Socket.IO servers. We call this component an "Adapter".'}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{alt:"Adapter",src:t(1735).A+"",width:"680",height:"712"})}),"\n",(0,o.jsx)(n.p,{children:"So let's install the cluster adapter:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"pnpm add @socket.io/cluster-adapter\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import express from 'express';\nimport { createServer } from 'node:http';\nimport { Server } from 'socket.io';\nimport sqlite3 from 'sqlite3';\nimport { open } from 'sqlite';\n// diff-add-start\nimport { availableParallelism } from 'node:os';\nimport cluster from 'node:cluster';\nimport { createAdapter, setupPrimary } from '@socket.io/cluster-adapter';\n// diff-add-end\n\nif (cluster.isPrimary) {\n  // diff-add-start\n  const numCPUs = availableParallelism();\n  // create one worker per available core\n  for (let i = 0; i < numCPUs; i++) {\n    cluster.fork({\n      PORT: 3000 + i\n    });\n  }\n\n  // set up the adapter on the primary thread\n  setupPrimary();\n  // diff-add-end\n} else {\n  const app = express();\n  const server = createServer(app);\n  const io = new Server(server, {\n    connectionStateRecovery: {},\n    // set up the adapter on each worker thread\n    adapter: createAdapter()\n  });\n\n  // [...]\n\n  // diff-add-start\n  // each worker will listen on a distinct port\n  const port = process.env.PORT;\n\n  server.listen(port, () => {\n    console.log(`server running at http://localhost:${port}`);\n  });\n  // diff-add-end\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"That's it! This will spawn one worker thread per CPU available on your machine. Let's see it in action:"}),"\n",(0,o.jsx)(n.p,{children:"With the implementation above, we can ,for example, have 4 browsers:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"http://localhost:3000"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"http://localhost:3001"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"http://localhost:3002"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"http://localhost:3003"})}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"and have each browser tab connected to a different Socket.IO server, and the adapter is simply forwarding the chat message events between them."}),"\n",(0,o.jsxs)(n.admonition,{type:"tip",children:[(0,o.jsx)(n.p,{children:"There are currently 5 official adapter implementations:"}),(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"the Redis adapter"}),"\n",(0,o.jsx)(n.li,{children:"the Redis Streams adapter"}),"\n",(0,o.jsx)(n.li,{children:"the MongoDB adapter"}),"\n",(0,o.jsx)(n.li,{children:"the Postgres adapter"}),"\n",(0,o.jsx)(n.li,{children:"the Cluster adapter"}),"\n"]}),(0,o.jsxs)(n.p,{children:["So you can choose the one that best suits your needs. However, please note that some implementations do not support the ",(0,o.jsx)(n.strong,{children:"Connection state recovery"})," feature, you can find the compatibility matrix ",(0,o.jsx)(n.a,{href:"https://socket.io/docs/v4/connection-state-recovery#compatibility-with-existing-adapters",children:"here"}),"."]})]}),"\n",(0,o.jsxs)(n.admonition,{type:"note",children:[(0,o.jsx)(n.p,{children:'In most cases, you would also need to ensure that all the HTTP requests of a Socket.IO session reach the same server (also known as "sticky session"). This was not needed in the simple example above though, as each Socket.IO server has its own port.'}),(0,o.jsxs)(n.p,{children:["More information ",(0,o.jsx)(n.a,{href:"https://socket.io/docs/v4/using-multiple-nodes/",children:"here"}),"."]})]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},1735:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/adapter-dark-6c92b997aa1f881ad1ed868eed33a468.png"},7010:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>a});var r=t(758);const o={},s=r.createContext(o);function i(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);