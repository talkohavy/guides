"use strict";(self.webpackChunkdocusaurus_guides=self.webpackChunkdocusaurus_guides||[]).push([[3111],{3365:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>i,default:()=>h,frontMatter:()=>c,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"programming/devops/kubernetes/architecture-and-concepts","title":"Kubernetes Architecture & Concepts","description":"- Concept 1: A Kubernetes Cluster & node","source":"@site/docs/programming/devops/kubernetes/architecture-and-concepts.md","sourceDirName":"programming/devops/kubernetes","slug":"/programming/devops/kubernetes/architecture-and-concepts","permalink":"/guides/he/docs/programming/devops/kubernetes/architecture-and-concepts","draft":false,"unlisted":false,"editUrl":"https://github.com/talkohavy/guides/docs/programming/devops/kubernetes/architecture-and-concepts.md","tags":[],"version":"current","frontMatter":{},"sidebar":"mySidebar","previous":{"title":"- kube-apiserver","permalink":"/guides/he/docs/programming/devops/kubernetes/kubernetes-api-server"},"next":{"title":"- RBAC","permalink":"/guides/he/docs/programming/devops/kubernetes/kubernetes-rbac"}}');var o=t(5813),s=t(3546);const c={},i="Kubernetes Architecture & Concepts",a={},l=[{value:"- Concept 1: A Kubernetes Cluster &amp; node",id:"--concept-1-a-kubernetes-cluster--node",level:2},{value:"- Concept 2: Using Service Name for internal communication",id:"--concept-2-using-service-name-for-internal-communication",level:2},{value:"- Concept 3: Node Communication",id:"--concept-3-node-communication",level:2},{value:"- Concept 4: DNS service",id:"--concept-4-dns-service",level:2},{value:"- Concept 5: API Server",id:"--concept-5-api-server",level:2},{value:"- Concept 6: kubectl",id:"--concept-6-kubectl",level:2},{value:"- Concept 7: kubelet",id:"--concept-7-kubelet",level:2},{value:"- Concept 8: kube-Proxy",id:"--concept-8-kube-proxy",level:2},{value:"- Concept 9: Scheduler",id:"--concept-9-scheduler",level:2},{value:"- Concept 10: Kube Controller Manager",id:"--concept-10-kube-controller-manager",level:2},{value:"- Concept 11: Cloud Controller Manager",id:"--concept-11-cloud-controller-manager",level:2},{value:"- Concept 12: etcd",id:"--concept-12-etcd",level:2},{value:"- Concept 13: Imperative Vs. Declarative",id:"--concept-13-imperative-vs-declarative",level:2}];function d(e){const n={a:"a",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",hr:"hr",li:"li",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"kubernetes-architecture--concepts",children:"Kubernetes Architecture & Concepts"})}),"\n",(0,o.jsx)(n.h2,{id:"--concept-1-a-kubernetes-cluster--node",children:"- Concept 1: A Kubernetes Cluster & node"}),"\n",(0,o.jsxs)(n.p,{children:["A kubernetes ",(0,o.jsx)(n.strong,{children:"cluster"})," consists of ",(0,o.jsx)(n.strong,{children:"nodes"}),".",(0,o.jsx)(n.br,{}),"\n","A ",(0,o.jsx)(n.strong,{children:"node"})," is actually a server."]}),"\n",(0,o.jsxs)(n.p,{children:["You can include multiple ",(0,o.jsx)(n.strong,{children:"nodes"})," (servers) inside a kubernetes ",(0,o.jsx)(n.strong,{children:"cluster"}),", and they could be located in different data-centers in different parts of the world. But usually, nodes which belong to the same kubernetes cluster are located close to each other. This is in order to perform tasks more efficiently."]}),"\n",(0,o.jsxs)(n.p,{children:["Inside each ",(0,o.jsx)(n.strong,{children:"node"}),", there are ",(0,o.jsx)(n.strong,{children:"pods"}),", and inside of each ",(0,o.jsx)(n.strong,{children:"pod"})," there are ",(0,o.jsx)(n.strong,{children:"containers"})," (usually just 1). Each ",(0,o.jsx)(n.strong,{children:"pod"})," can have a ",(0,o.jsx)(n.em,{children:"pod sibling"}),", meaning that they're both living under the same ",(0,o.jsx)(n.strong,{children:"deployment"}),", or a ",(0,o.jsx)(n.em,{children:"pod cousin"}),", meaning that they're both living under different ",(0,o.jsx)(n.strong,{children:"deployments"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"Nodes will not automatically form a cluster without your intervention! But after such initial configuration, everything will be automated. And kubernetes will automatically deploy pods on different nodes."}),"\n",(0,o.jsx)(n.h2,{id:"--concept-2-using-service-name-for-internal-communication",children:"- Concept 2: Using Service Name for internal communication"}),"\n",(0,o.jsxs)(n.p,{children:["Any resource in a Kubernetes cluster, like a ",(0,o.jsx)(n.strong,{children:"service"})," or ",(0,o.jsx)(n.strong,{children:"deployment"}),", can communicate with others. To let one deployment talk to another, we expose it through a service, which provides a virtual IP. But this IP is dynamic and is only known ",(0,o.jsx)(n.em,{children:"after"})," creation. So instead, we use the ",(0,o.jsx)(n.strong,{children:"service name"}),", which is static and acts as a ",(0,o.jsx)(n.strong,{children:"stable hostname"}),". Kubernetes DNS handles the name-to-IP resolution, making it easy for deployments to connect."]}),"\n",(0,o.jsx)(n.h2,{id:"--concept-3-node-communication",children:"- Concept 3: Node Communication"}),"\n",(0,o.jsxs)(n.p,{children:["In ",(0,o.jsx)(n.a,{href:"#--concept-5-using-service-name-for-internal-communication",children:"Concept 5"}),", We talked about internal communication between ",(0,o.jsx)(n.strong,{children:"Services"}),", but what about ",(0,o.jsx)(n.strong,{children:"node"})," communication? How do those nodes actually communicate with each other? How are they managed?"]}),"\n",(0,o.jsx)(n.p,{children:"In this case, you do not need to do anything. It is done for you automatically. How?"}),"\n",(0,o.jsxs)(n.p,{children:["Well, in a kubernetes cluster there is what's known as a ",(0,o.jsx)(n.code,{children:"master node"}),". The rest of the nodes in the cluster are called ",(0,o.jsx)(n.code,{children:"worker nodes"}),". It's the ",(0,o.jsx)(n.code,{children:"master node"})," job to manage communication between ",(0,o.jsx)(n.code,{children:"worker nodes"}),". It is also the ",(0,o.jsx)(n.code,{children:"master node"}),"'s job to distribute load across ",(0,o.jsx)(n.code,{children:"worker nodes"}),". All ",(0,o.jsx)(n.code,{children:"pods"})," related to your application are deployed on ",(0,o.jsx)(n.code,{children:"worker node"}),"'s. The ",(0,o.jsx)(n.code,{children:"master node"})," runs in what is known as ",(0,o.jsx)(n.code,{children:"system pods"}),', which are responsible for the actual work of the kubernetes cluster in general. Basically, we could say that a master node in a kubernetes cluster is more like "the control plane", and it does not run your client applications.']}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Q"}),": So, what services actually run on different nodes?"]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"A"}),": Let's have a look at the following diagram..."]}),"\n",(0,o.jsxs)(n.p,{children:["There are services such as ",(0,o.jsx)(n.em,{children:"kubelet"}),", ",(0,o.jsx)(n.em,{children:"kube-proxy"}),", and a ",(0,o.jsx)(n.em,{children:"container runtime"}),". Those services are present ON EACH NODE in the kubernetes cluster. A container runtime is the mechanism where your containers actually run. We mentioned 3: docker, containerd, CRI-O."]}),"\n",(0,o.jsx)(n.h2,{id:"--concept-4-dns-service",children:"- Concept 4: DNS service"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.strong,{children:"DNS service"})," is a service which runs on the master node, and is ",(0,o.jsx)(n.strong,{children:"responsible for names resolution"})," in the entire kubernetes cluster."]}),"\n",(0,o.jsx)(n.h2,{id:"--concept-5-api-server",children:"- Concept 5: API Server"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"API server"})," service is the main point of communication between nodes inside the kubernetes world. The ",(0,o.jsx)(n.strong,{children:"API server"})," is the main service inside the ",(0,o.jsx)(n.code,{children:"master node"}),".\nUsing this ",(0,o.jsx)(n.strong,{children:"API server"})," service, you could actually manage the entire kubernetes cluster. It is done by using ",(0,o.jsx)(n.code,{children:"kubectl"}),". Or, ",(0,o.jsx)(n.code,{children:"kube-control"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"--concept-6-kubectl",children:"- Concept 6: kubectl"}),"\n",(0,o.jsxs)(n.p,{children:["Kubectl is a separate command-line tool, which allows you to connect with a specific kubernetes cluster, and manage it remotely.",(0,o.jsx)(n.br,{}),"\n","kubectl could even be ran on your local machine.",(0,o.jsx)(n.br,{}),"\n","Using kubectl, you could manage a remote kubernetes cluster.",(0,o.jsx)(n.br,{}),"\n","It connects using REST API to the API Server service on the master node. This communication happens, of course, over https. By the way, other nodes on the cluster (i.e. worker nodes) communicate with the master node in the same fashion. What that means is that by using the kubectl tool, you could manage any remote kubernetes cluster."]}),"\n",(0,o.jsxs)(n.p,{children:["That's it for the kubernetes architecture overview, and you know that:",(0,o.jsx)(n.br,{}),"\n","A kubernetes cluster consists of nodes.",(0,o.jsx)(n.br,{}),"\n","One of the nodes is a master node.",(0,o.jsx)(n.br,{}),"\n","The master node manages the rest of the nodes, which are called worker nodes.",(0,o.jsx)(n.br,{}),"\n","On each node there are pods.",(0,o.jsx)(n.br,{}),"\n","Pods are created automatically by kubernetes.",(0,o.jsx)(n.br,{}),"\n","Inside each pod there are containers. Usually just single container per pod.",(0,o.jsx)(n.br,{}),"\n","All containers inside of a pod share same namespace of that pod (IP address, etc).",(0,o.jsx)(n.br,{}),"\n","Pod are the smallest unit in kubernetes.",(0,o.jsx)(n.br,{}),"\n","Pods could be created, removed, moved from one node to another, and all this happens automatically without your intervention.",(0,o.jsx)(n.br,{}),"\n","API Server service is the center main point of communication between master node and other worker nodes.",(0,o.jsx)(n.br,{}),"\n","Using the API Server service, you could manage the kubernetes cluster by using the kubectl tool, which has to be installed on your computer, if you perform management from your computer."]}),"\n",(0,o.jsx)(n.h2,{id:"--concept-7-kubelet",children:"- Concept 7: kubelet"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.strong,{children:"kubelet"})," is the ",(0,o.jsx)(n.strong,{children:'primary "node agent"'})," that runs on each ",(0,o.jsx)(n.strong,{children:"node"}),". It can register the node with the apiserver using one of:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"the hostname"}),"\n",(0,o.jsx)(n.li,{children:"a flag to override the hostname"}),"\n",(0,o.jsx)(n.li,{children:"or specific logic for a cloud provider."}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.strong,{children:"kubelet"})," works in terms of a ",(0,o.jsx)(n.em,{children:"PodSpec"}),". A ",(0,o.jsx)(n.em,{children:"PodSpec"})," is a YAML or JSON object that describes a pod. ",(0,o.jsx)(n.strong,{children:"The kubelet ensures that the containers described in those PodSpecs are running and healthy"}),". The kubelet doesn't manage containers which were not created by Kubernetes."]}),"\n",(0,o.jsxs)(n.p,{children:["Each worker node has 1 ",(0,o.jsx)(n.strong,{children:"kubelet"})," service on it, which communicates with an API server service on the master node."]}),"\n",(0,o.jsx)(n.h2,{id:"--concept-8-kube-proxy",children:"- Concept 8: kube-Proxy"}),"\n",(0,o.jsxs)(n.p,{children:["A ",(0,o.jsx)(n.strong,{children:"kube-proxy"})," service is found on each of the worker nodes, and is responsible for network communication within the node, and between nodes."]}),"\n",(0,o.jsx)(n.h2,{id:"--concept-9-scheduler",children:"- Concept 9: Scheduler"}),"\n",(0,o.jsxs)(n.p,{children:["There are services that are present ONLY on the master node.",(0,o.jsx)(n.br,{}),"\n","One of them is the ",(0,o.jsx)(n.strong,{children:"scheduler"}),".",(0,o.jsx)(n.br,{}),"\n","The ",(0,o.jsx)(n.strong,{children:"scheduler"})," is responsible for planning and distributing of the workload inside the cluster."]}),"\n",(0,o.jsx)(n.h2,{id:"--concept-10-kube-controller-manager",children:"- Concept 10: Kube Controller Manager"}),"\n",(0,o.jsx)(n.p,{children:"Kube Controller Manager is a single point which controls everything inside the kubernetes cluster, and it controls what happens on each of the nodes in the cluster."}),"\n",(0,o.jsx)(n.h2,{id:"--concept-11-cloud-controller-manager",children:"- Concept 11: Cloud Controller Manager"}),"\n",(0,o.jsxs)(n.p,{children:["Its job is to ",(0,o.jsx)(n.strong,{children:"interact with your cloud service provider"}),", where you actually run your kubernetes cluster. Because usually you don't create these clusters to run on your own servers, instead you usually choose to run them on one of the cloud providers.",(0,o.jsx)(n.br,{}),"\n","which actually performs almost automated creation of all nodes, and the connection between such nodes. And for that, you have to run Cloud Controller Manager service on the master node. Also for example if you want to create deployment of your application inside of the kubernetes cluster, which will be opened to the outside world, and allow connection from outside, you could create a load-balancer IP addresses, and those load-balancer IP addresses are usually provided by those specific cloud providers."]}),"\n",(0,o.jsx)(n.h2,{id:"--concept-12-etcd",children:"- Concept 12: etcd"}),"\n",(0,o.jsx)(n.p,{children:"Also on master node, there's such a thing called etcd.\nEtcd is a service which actually stores all logs related to the operation of the entire kubernetes cluster, and such logs are stored inside of it as key-value pairs."}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"--concept-13-imperative-vs-declarative",children:"- Concept 13: Imperative Vs. Declarative"}),"\n",(0,o.jsx)(n.p,{children:"Up until now, we've used the imperative approach to create deployments & services.\nWe did so by using kubectl CLI commands. But usually, that's not the way experienced developers use to create all the different objects and resources in kubernetes. In most cases, a declarative approach is used.\nIn the declarative approach, you create a yaml configuration file or files, which describe a full recipe of how to build and create your entire cluster, all the deployments, all the services, and describes in full what should be done and in what order. After having such yaml files, we would use kubectl's apply command.\nLet's do an example right now."})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},3546:(e,n,t)=>{t.d(n,{R:()=>c,x:()=>i});var r=t(9729);const o={},s=r.createContext(o);function c(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:c(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);