"use strict";(self.webpackChunkdocusaurus_guides=self.webpackChunkdocusaurus_guides||[]).push([[8842],{8088:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"programming/socket-io/scaling-horizontally","title":"Scaling horizontally","description":"Now that our application is resilient to temporary network interruptions, let\'s see how we can horizontally scale it in order to be able to support thousands of concurrent clients.","source":"@site/docs/programming/socket-io/scaling-horizontally.md","sourceDirName":"programming/socket-io","slug":"/programming/socket-io/scaling-horizontally","permalink":"/guides/he/docs/programming/socket-io/scaling-horizontally","draft":false,"unlisted":false,"editUrl":"https://github.com/talkohavy/guides/docs/programming/socket-io/scaling-horizontally.md","tags":[],"version":"current","frontMatter":{},"sidebar":"mySidebar","previous":{"title":"- Rooms","permalink":"/guides/he/docs/programming/socket-io/rooms"},"next":{"title":"- SocketIO vs WebSockets","permalink":"/guides/he/docs/programming/socket-io/socketio-vs-websockets"}}');var r=n(5813),s=n(3546);const i={},a="Scaling horizontally",l={},c=[];function d(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",header:"header",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"scaling-horizontally",children:"Scaling horizontally"})}),"\n",(0,r.jsx)(t.p,{children:"Now that our application is resilient to temporary network interruptions, let's see how we can horizontally scale it in order to be able to support thousands of concurrent clients."}),"\n",(0,r.jsx)(t.admonition,{type:"note",children:(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:'Horizontal scaling (also known as "scaling out") means adding new servers to your infrastructure to cope with new demands'}),"\n",(0,r.jsx)(t.li,{children:'Vertical scaling (also known as "scaling up") means adding more resources (processing power, memory, storage, ...) to your existing infrastructure'}),"\n"]})}),"\n",(0,r.jsxs)(t.p,{children:["First step: let's use all the available cores of the host. By default, Node.js runs your Javascript code in a single thread, which means that even with a 32-core CPU, only one core will be used. Fortunately, the Node.js ",(0,r.jsx)(t.code,{children:"cluster"})," module provides a convenient way to create one worker thread per core."]}),"\n",(0,r.jsx)(t.p,{children:'We will also need a way to forward events between the Socket.IO servers. We call this component an "Adapter".'}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{alt:"Adapter",src:n(5227).A+"",width:"680",height:"712"})}),"\n",(0,r.jsx)(t.p,{children:"So let's install the cluster adapter:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-bash",children:"pnpm add @socket.io/cluster-adapter\n"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"import express from 'express';\nimport { createServer } from 'node:http';\nimport { Server } from 'socket.io';\nimport sqlite3 from 'sqlite3';\nimport { open } from 'sqlite';\n// diff-add-start\nimport { availableParallelism } from 'node:os';\nimport cluster from 'node:cluster';\nimport { createAdapter, setupPrimary } from '@socket.io/cluster-adapter';\n// diff-add-end\n\nif (cluster.isPrimary) {\n  // diff-add-start\n  const numCPUs = availableParallelism();\n  // create one worker per available core\n  for (let i = 0; i < numCPUs; i++) {\n    cluster.fork({\n      PORT: 3000 + i\n    });\n  }\n\n  // set up the adapter on the primary thread\n  setupPrimary();\n  // diff-add-end\n} else {\n  const app = express();\n  const server = createServer(app);\n  const io = new Server(server, {\n    connectionStateRecovery: {},\n    // set up the adapter on each worker thread\n    adapter: createAdapter()\n  });\n\n  // [...]\n\n  // diff-add-start\n  // each worker will listen on a distinct port\n  const port = process.env.PORT;\n\n  server.listen(port, () => {\n    console.log(`server running at http://localhost:${port}`);\n  });\n  // diff-add-end\n}\n"})}),"\n",(0,r.jsx)(t.p,{children:"That's it! This will spawn one worker thread per CPU available on your machine. Let's see it in action:"}),"\n",(0,r.jsx)(t.p,{children:"With the implementation above, we can ,for example, have 4 browsers:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"http://localhost:3000"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"http://localhost:3001"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"http://localhost:3002"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"http://localhost:3003"})}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"and have each browser tab connected to a different Socket.IO server, and the adapter is simply forwarding the chat message events between them."}),"\n",(0,r.jsxs)(t.admonition,{type:"tip",children:[(0,r.jsx)(t.p,{children:"There are currently 5 official adapter implementations:"}),(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"the Redis adapter"}),"\n",(0,r.jsx)(t.li,{children:"the Redis Streams adapter"}),"\n",(0,r.jsx)(t.li,{children:"the MongoDB adapter"}),"\n",(0,r.jsx)(t.li,{children:"the Postgres adapter"}),"\n",(0,r.jsx)(t.li,{children:"the Cluster adapter"}),"\n"]}),(0,r.jsxs)(t.p,{children:["So you can choose the one that best suits your needs. However, please note that some implementations do not support the ",(0,r.jsx)(t.strong,{children:"Connection state recovery"})," feature, you can find the compatibility matrix ",(0,r.jsx)(t.a,{href:"https://socket.io/docs/v4/connection-state-recovery#compatibility-with-existing-adapters",children:"here"}),"."]})]}),"\n",(0,r.jsxs)(t.admonition,{type:"note",children:[(0,r.jsx)(t.p,{children:'In most cases, you would also need to ensure that all the HTTP requests of a Socket.IO session reach the same server (also known as "sticky session"). This was not needed in the simple example above though, as each Socket.IO server has its own port.'}),(0,r.jsxs)(t.p,{children:["More information ",(0,r.jsx)(t.a,{href:"https://socket.io/docs/v4/using-multiple-nodes/",children:"here"}),"."]})]})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},5227:(e,t,n)=>{n.d(t,{A:()=>o});const o=n.p+"assets/images/adapter-dark-6c92b997aa1f881ad1ed868eed33a468.png"},3546:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>a});var o=n(9729);const r={},s=o.createContext(r);function i(e){const t=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),o.createElement(s.Provider,{value:t},e.children)}}}]);