"use strict";(self.webpackChunkdocusaurus_guides=self.webpackChunkdocusaurus_guides||[]).push([[4184],{4093:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"programming/devops/kubernetes/resources","title":"Kubernetes Resources","description":"Let\'s start with some terminology and talk about the architecture of kubernetes:","source":"@site/docs/programming/devops/kubernetes/resources.md","sourceDirName":"programming/devops/kubernetes","slug":"/programming/devops/kubernetes/resources","permalink":"/guides/he/docs/programming/devops/kubernetes/resources","draft":false,"unlisted":false,"editUrl":"https://github.com/talkohavy/guides/docs/programming/devops/kubernetes/resources.md","tags":[],"version":"current","frontMatter":{},"sidebar":"mySidebar","previous":{"title":"- All Kubectl Commands","permalink":"/guides/he/docs/programming/devops/kubernetes/kubectl-commands"},"next":{"title":"- kube-apiserver","permalink":"/guides/he/docs/programming/devops/kubernetes/kubernetes-api-server"}}');var t=s(6070),i=s(7010);const a={},l="Kubernetes Resources",o={},c=[{value:"Resource 1: A Pod",id:"resource-1-a-pod",level:2},{value:"Resource 2: Deployment",id:"resource-2-deployment",level:2},{value:"- A. What is a Deployment?",id:"--a-what-is-a-deployment",level:3},{value:"- B. Why Do We Need It?",id:"--b-why-do-we-need-it",level:3},{value:"- C. What a Deployment Does Internally",id:"--c-what-a-deployment-does-internally",level:3},{value:"- D. Anatomy of a Deployment",id:"--d-anatomy-of-a-deployment",level:3},{value:"- E. Rolling Updates &amp; Rollbacks",id:"--e-rolling-updates--rollbacks",level:3},{value:"- F. Behind the Scenes: ReplicaSets",id:"--f-behind-the-scenes-replicasets",level:3},{value:"- G. How to Scale",id:"--g-how-to-scale",level:3},{value:"- H. Monitoring Deployment State",id:"--h-monitoring-deployment-state",level:3},{value:"- I. Deployment Strategies",id:"--i-deployment-strategies",level:3},{value:"-- 1. RollingUpdate (default)",id:"---1-rollingupdate-default",level:4},{value:"-- 2. Recreate",id:"---2-recreate",level:4},{value:"- J. Best Practices",id:"--j-best-practices",level:3},{value:"Resource 3: Service",id:"resource-3-service",level:2},{value:"-- A. What is a Service?",id:"---a-what-is-a-service",level:3},{value:"-- B. Why do we need a <strong>Service</strong>?",id:"---b-why-do-we-need-a-service",level:3},{value:"- C. How to create a Service",id:"--c-how-to-create-a-service",level:3},{value:"- D. Service Types",id:"--d-service-types",level:3},{value:"Type 1: ClusterIP (the default)",id:"type-1-clusterip-the-default",level:4},{value:"Type 2: NodePort",id:"type-2-nodeport",level:4},{value:"Type 3: LoadBalancer",id:"type-3-loadbalancer",level:4},{value:"Type 4: ExternalName",id:"type-4-externalname",level:4},{value:"Resource 4: Secret",id:"resource-4-secret",level:2},{value:"- A. What is a ConfigMap",id:"--a-what-is-a-configmap",level:3},{value:"- B. How to create a ConfigMap",id:"--b-how-to-create-a-configmap",level:3},{value:"- C. How to Attach a ConfigMap to a Deployment",id:"--c-how-to-attach-a-configmap-to-a-deployment",level:3},{value:"- D. Additional Notes",id:"--d-additional-notes",level:3},{value:"Resource 5: Secret",id:"resource-5-secret",level:2},{value:"- A. What is a Secret",id:"--a-what-is-a-secret",level:3},{value:"- B. Common Use Cases",id:"--b-common-use-cases",level:3},{value:"- C. How to create a Secret",id:"--c-how-to-create-a-secret",level:3},{value:"- D. How to Attach a Secret to a Deployment",id:"--d-how-to-attach-a-secret-to-a-deployment",level:3},{value:"- E. Additional Notes",id:"--e-additional-notes",level:3},{value:"- F. Best Practices",id:"--f-best-practices",level:3},{value:"Resource 6: ServiceAccount",id:"resource-6-serviceaccount",level:2},{value:"- A. What is a ServiceAccount",id:"--a-what-is-a-serviceaccount",level:3},{value:"- B. Why Do We Need It?",id:"--b-why-do-we-need-it-1",level:3},{value:"- C. Default Behavior",id:"--c-default-behavior",level:3},{value:"- D. How to create a ServiceAccount",id:"--d-how-to-create-a-serviceaccount",level:3},{value:"- E. How to Attach a ServiceAccount to a Deployment",id:"--e-how-to-attach-a-serviceaccount-to-a-deployment",level:3},{value:"- F. Combining with RBAC",id:"--f-combining-with-rbac",level:3},{value:"- G. Best Practices",id:"--g-best-practices",level:3},{value:"Resource 999: Ingress",id:"resource-999-ingress",level:2},{value:"- A. What is an Ingress",id:"--a-what-is-an-ingress",level:3},{value:"- B. Why Do We Need It?",id:"--b-why-do-we-need-it-2",level:3},{value:"- C. How It Works",id:"--c-how-it-works",level:3},{value:"- D. How to create a ServiceAccount",id:"--d-how-to-create-a-serviceaccount-1",level:3},{value:"- E. How to Expose a Deployment via Ingress",id:"--e-how-to-expose-a-deployment-via-ingress",level:3},{value:"- F. Additional Notes",id:"--f-additional-notes",level:3},{value:"- G. Best Practices",id:"--g-best-practices-1",level:3}];function d(e){const n={br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"kubernetes-resources",children:"Kubernetes Resources"})}),"\n",(0,t.jsx)(n.p,{children:"Let's start with some terminology and talk about the architecture of kubernetes:"}),"\n",(0,t.jsx)(n.h2,{id:"resource-1-a-pod",children:"Resource 1: A Pod"}),"\n",(0,t.jsxs)(n.p,{children:["A ",(0,t.jsx)(n.strong,{children:"Pod"})," is the smallest unit that exists within the ",(0,t.jsx)(n.em,{children:"kubernetes"})," world.",(0,t.jsx)(n.br,{}),"\n","Note that ",(0,t.jsx)(n.strong,{children:"container"})," is the smallest unit that exists within the ",(0,t.jsx)(n.em,{children:"docker"})," world. In kubernetes however, it is the ",(0,t.jsx)(n.strong,{children:"pod"}),".",(0,t.jsx)(n.br,{}),"\n","Containers are created INSIDE a pod!",(0,t.jsx)(n.br,{}),"\n","Inside the pod, there could be one or more containers, although the most common scenario is to have ",(0,t.jsx)(n.strong,{children:"a single container running inside a pod"}),". One pod, one container."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"resource-2-deployment",children:"Resource 2: Deployment"}),"\n",(0,t.jsx)(n.h3,{id:"--a-what-is-a-deployment",children:"- A. What is a Deployment?"}),"\n",(0,t.jsxs)(n.p,{children:["A Deployment is a higher-level Kubernetes resource that manages the ",(0,t.jsx)(n.strong,{children:"lifecycle of Pods"})," via ",(0,t.jsx)(n.strong,{children:"ReplicaSets"}),". It allows you to declaratively define the desired state of your application (e.g., how many replicas, what image, which config) and lets Kubernetes automatically handle creating, updating, and healing Pods to match that state."]}),"\n",(0,t.jsx)(n.h3,{id:"--b-why-do-we-need-it",children:"- B. Why Do We Need It?"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Declarative Management"}),": Define what your app should look like, and Kubernetes makes it happen."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Rolling Updates"}),": Deploy new versions with zero downtime by gradually replacing old Pods."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Rollbacks"}),": Easily revert to previous versions if something goes wrong."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Scalability"}),": Seamlessly scale your app up or down by adjusting the replicas count."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"--c-what-a-deployment-does-internally",children:"- C. What a Deployment Does Internally"}),"\n",(0,t.jsxs)(n.p,{children:["A Deployment uses a ",(0,t.jsx)(n.strong,{children:"Pod template"})," to define what Pods should look like \u2014 including container images, ports, environment variables, and more.\nIt ",(0,t.jsx)(n.strong,{children:"automatically creates a ReplicaSet"}),", which in turn ensures that the specified number of identical Pods are running."]}),"\n",(0,t.jsxs)(n.p,{children:["If the Pod template changes (e.g., new image version), the Deployment creates a ",(0,t.jsx)(n.strong,{children:"new ReplicaSet"}),", and gradually shifts traffic from the old Pods to the new ones \u2014 this is the ",(0,t.jsx)(n.strong,{children:"rolling update strategy"}),", which is the default."]}),"\n",(0,t.jsx)(n.h3,{id:"--d-anatomy-of-a-deployment",children:"- D. Anatomy of a Deployment"}),"\n",(0,t.jsx)(n.p,{children:"Minimal YAML Example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: myapp\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: myapp\n  template:\n    metadata:\n      labels:\n        app: myapp\n    spec:\n      containers:\n        - name: myapp\n          image: myapp:1.0.0\n          ports:\n            - containerPort: 8080\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"replicas"}),": Number of desired Pods."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"selector"}),".matchLabels: Matches Pods to the Deployment (must match labels in the template)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"template"}),': The Pod "recipe" \u2014 what gets created.']}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"strategy"}),": By default, uses ",(0,t.jsx)(n.strong,{children:"RollingUpdate"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"To apply this Deployment:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"kubectl apply -f deployment.yaml\n"})}),"\n",(0,t.jsx)(n.h3,{id:"--e-rolling-updates--rollbacks",children:"- E. Rolling Updates & Rollbacks"}),"\n",(0,t.jsx)(n.p,{children:"Update image:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"kubectl set image deployment/myapp myapp=myapp:2.0.0\n"})}),"\n",(0,t.jsx)(n.p,{children:"Watch rollout progress:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"kubectl rollout status deployment/myapp\n"})}),"\n",(0,t.jsx)(n.p,{children:"Roll back to previous version:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"kubectl rollout undo deployment/myapp\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Kubernetes ensures that updates are ",(0,t.jsx)(n.strong,{children:"safe and gradual"})," \u2014 new Pods start running before old ones are terminated."]}),"\n",(0,t.jsx)(n.h3,{id:"--f-behind-the-scenes-replicasets",children:"- F. Behind the Scenes: ReplicaSets"}),"\n",(0,t.jsxs)(n.p,{children:["Deployments ",(0,t.jsx)(n.strong,{children:"create and manage ReplicaSets"}),", which are responsible for keeping a set number of Pods running."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["A ",(0,t.jsx)(n.strong,{children:"ReplicaSet"})," watches for Pods that match its selector and creates or deletes Pods as needed to maintain the ",(0,t.jsx)(n.code,{children:"replicas"})," count."]}),"\n",(0,t.jsxs)(n.li,{children:["Each Deployment manages ",(0,t.jsx)(n.strong,{children:"its own ReplicaSet"})," \u2014 when the template changes, a new ReplicaSet is created and gradually scaled up while the old one is scaled down."]}),"\n",(0,t.jsxs)(n.li,{children:["Pods link back to their managing ReplicaSet using ",(0,t.jsx)(n.code,{children:"metadata.ownerReferences"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["This architecture makes ",(0,t.jsx)(n.strong,{children:"rolling updates and rollbacks"})," possible \u2014 switching between different ReplicaSets with different Pod templates."]}),"\n",(0,t.jsx)(n.h3,{id:"--g-how-to-scale",children:"- G. How to Scale"}),"\n",(0,t.jsxs)(n.p,{children:["Modify the ",(0,t.jsx)(n.strong,{children:"replicas"})," field and reapply:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"spec:\n  replicas: 5\n"})}),"\n",(0,t.jsx)(n.p,{children:"Or use the CLI:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"kubectl scale deployment myapp --replicas=5\n"})}),"\n",(0,t.jsx)(n.p,{children:"Kubernetes ensures that the actual number of Pods running matches the desired count."}),"\n",(0,t.jsx)(n.h3,{id:"--h-monitoring-deployment-state",children:"- H. Monitoring Deployment State"}),"\n",(0,t.jsx)(n.p,{children:"Run:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"kubectl describe deployment myapp\n"})}),"\n",(0,t.jsx)(n.p,{children:"You'll see fields like:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Replicas"}),": Current status \u2014 desired, updated, available, unavailable."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"StrategyType"}),": Usually RollingUpdate."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Replicas: 3 desired | 3 updated | 3 total | 3 available | 0 unavailable\n"})}),"\n",(0,t.jsx)(n.h3,{id:"--i-deployment-strategies",children:"- I. Deployment Strategies"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"Deployment"})," resource supports two update strategies via the strategy.type field:"]}),"\n",(0,t.jsx)(n.h4,{id:"---1-rollingupdate-default",children:"-- 1. RollingUpdate (default)"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"What it does"}),": Gradually replaces old Pods with new ones."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Benefit"}),": Ensures zero downtime if configured properly."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"How it works"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Creates new Pods using the updated template."}),"\n",(0,t.jsx)(n.li,{children:"Slowly terminates old Pods while ensuring availability."}),"\n",(0,t.jsxs)(n.li,{children:["Controlled by:","\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"strategy:\n  type: RollingUpdate # default\n    rollingUpdate:\n      maxUnavailable: 25% # default\n      maxSurge: 25% # default\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"maxSurge"}),": How many extra Pods can be created temporarily during the update (",(0,t.jsx)(n.strong,{children:"round up"}),"). For example, if you set ",(0,t.jsx)(n.code,{children:"maxSurge: 25%"}),", it means that up to 25% more Pods than the desired number can be created temporarily during the update. With 4 replicas, up to 1 extra pod can be created during rollout."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"maxUnavailable"}),": How many Pods can be unavailable during the update (",(0,t.jsx)(n.strong,{children:"round down"}),"). For example, if you set ",(0,t.jsx)(n.code,{children:"maxUnavailable: 25%"}),", it means that up to 25% of the desired Pods can be unavailable during the update. For example, if you have 4 replicas, 1 pod can be unavailable during the update."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"\u2705 Example 1: replicas: 4"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"maxSurge: 25% \u2192 1 extra pod"}),"\n",(0,t.jsx)(n.li,{children:"maxUnavailable: 25% \u2192 1 pod can be offline"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Initial state:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"4 running Pods (v1)"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Step-by-step update:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Kubernetes creates 1 new Pod (v2) \u2014 allowed by maxSurge.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Now: 4 old Pods (v1) + 1 new Pod (v2) = 5 Pods total."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Once the new Pod (v2) is ready, Kubernetes terminates 1 old Pod (v1) \u2014 allowed by maxUnavailable.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Now: 3 old (v1) + 1 new (v2)"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Repeat:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Create 1 new Pod (v2) \u2192 total 5 Pods."}),"\n",(0,t.jsx)(n.li,{children:"Terminate 1 old Pod (v1)"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.li,{children:"After 4 cycles, you end up with 4 Pods, all running the new version."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Summary:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Update proceeds 1 pod at a time."}),"\n",(0,t.jsx)(n.li,{children:"Total pods never exceed 5 (replicas + maxSurge)."}),"\n",(0,t.jsx)(n.li,{children:"No more than 1 pod is down (maxUnavailable) at a time."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"\u2705 Example 2: replicas: 2"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"maxSurge: 25% \u2192 0.5 \u2192 rounds up \u2192 1 extra pod"}),"\n",(0,t.jsx)(n.li,{children:"maxUnavailable: 25% \u2192 0.5 \u2192 rounds down \u2192 0 pods can be unavailable"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Initial state:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"2 running Pods (v1)"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Step-by-step update:"})}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Kubernetes creates ",(0,t.jsx)(n.strong,{children:"1 new Pod (v2)"})," \u2014 allowed by maxSurge.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Now: 2 old Pods (v1) + 1 new Pod (v2) = 3 Pods total."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["It ",(0,t.jsx)(n.strong,{children:"waits"})," for the new Pod to become ",(0,t.jsx)(n.strong,{children:"Ready"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["Once it's Ready, Kubernetes can now terminate an old Pod \u2014 but must ensure ",(0,t.jsx)(n.strong,{children:"0 downtime"}),", so ",(0,t.jsx)(n.strong,{children:"it keeps 2 Pods running at all times"}),"."]}),"\n",(0,t.jsx)(n.li,{children:"It deletes 1 old Pod and repeats."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Summary:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Even stricter update: ",(0,t.jsx)(n.strong,{children:"no downtime allowed at all"}),"."]}),"\n",(0,t.jsx)(n.li,{children:"Only 1 Pod is updated at a time."}),"\n",(0,t.jsx)(n.li,{children:"Total Pods temporarily reach 3 (due to maxSurge)."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"\ud83d\udd0d Key Takeaways"})}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Replicas"}),(0,t.jsx)(n.th,{children:"maxSurge (25%)"}),(0,t.jsx)(n.th,{children:"maxUnavailable (25%)"}),(0,t.jsx)(n.th,{children:"Max Total Pods"}),(0,t.jsx)(n.th,{children:"Min Available During Update"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"4"}),(0,t.jsx)(n.td,{children:"1"}),(0,t.jsx)(n.td,{children:"1"}),(0,t.jsx)(n.td,{children:"5"}),(0,t.jsx)(n.td,{children:"3"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"2"}),(0,t.jsx)(n.td,{children:"1"}),(0,t.jsx)(n.td,{children:"0"}),(0,t.jsx)(n.td,{children:"3"}),(0,t.jsx)(n.td,{children:"2"})]})]})]}),"\n",(0,t.jsx)(n.h4,{id:"---2-recreate",children:"-- 2. Recreate"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"What it does"}),": Terminates ",(0,t.jsx)(n.strong,{children:"all existing Pods"})," before creating new ones."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Benefit"}),": Guarantees that new and old versions ",(0,t.jsx)(n.strong,{children:"never run simultaneously"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Drawback"}),": Causes downtime during the transition."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Use case"}),": Useful when your app ",(0,t.jsx)(n.strong,{children:"can't handle two versions running at once"})," (e.g., breaking DB schema changes, shared volume locks)."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"--j-best-practices",children:"- J. Best Practices"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Use labels consistently"})," for ",(0,t.jsx)(n.code,{children:"selector.matchLabels"})," and ",(0,t.jsx)(n.code,{children:"template.metadata.labels"})," \u2014 they must match."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsxs)(n.strong,{children:["Avoid using ",(0,t.jsx)(n.code,{children:"latest"})," tags"]})," for images to prevent unpredictable rollouts."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Pair with ConfigMaps and Secrets"})," for environment configuration."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Use resource limits"})," (CPU/memory) to avoid noisy neighbors and enable autoscaling."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Monitor rollout status"})," after each update to catch issues early."]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"resource-3-service",children:"Resource 3: Service"}),"\n",(0,t.jsx)(n.h3,{id:"---a-what-is-a-service",children:"-- A. What is a Service?"}),"\n",(0,t.jsxs)(n.p,{children:["A ",(0,t.jsx)(n.strong,{children:"Service"})," is an abstract way for ",(0,t.jsx)(n.strong,{children:"exposing"})," an application running on a set of ",(0,t.jsx)(n.strong,{children:"Pods"})," as a ",(0,t.jsx)(n.em,{children:"network service"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["A ",(0,t.jsx)(n.strong,{children:"service"})," has 2 main purposes:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Define a logical set of ",(0,t.jsx)(n.strong,{children:"pods"})," and a ",(0,t.jsx)(n.strong,{children:"policy"})," by which to access them."]}),"\n",(0,t.jsx)(n.li,{children:"Load balance the work-load between the set of pods it is in-charge of."}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["The set of pods targeted by a ",(0,t.jsx)(n.strong,{children:"service"})," is usually determined by a ",(0,t.jsx)(n.code,{children:"selector"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["A ",(0,t.jsx)(n.strong,{children:"service"})," in kubernetes is a REST object, similar to a ",(0,t.jsx)(n.strong,{children:"pod"}),". Being a REST object, it means that a ",(0,t.jsx)(n.strong,{children:"Service"})," can be created, updated or deleted. It could also be read in the sense of getting information about it (with the ",(0,t.jsx)(n.em,{children:"describe"})," command). To be more specific, saying that a ",(0,t.jsx)(n.strong,{children:"service"})," is a REST object means that you can\xa0send a POST\xa0request with a ",(0,t.jsx)(n.strong,{children:"service"})," definition to the API server to create a new instance."]}),"\n",(0,t.jsxs)(n.h3,{id:"---b-why-do-we-need-a-service",children:["-- B. Why do we need a ",(0,t.jsx)(n.strong,{children:"Service"}),"?"]}),"\n",(0,t.jsxs)(n.p,{children:["If you use a ",(0,t.jsx)(n.strong,{children:"deployment"})," to run your app (which you probably are), it can create and destroy ",(0,t.jsx)(n.strong,{children:"pods"})," dynamically. Kubernetes ",(0,t.jsx)(n.strong,{children:"pods"})," are created and destroyed all the time in order to match the ",(0,t.jsx)(n.em,{children:"desired state"})," you mentioned in your deployment's yaml. What this means is that ",(0,t.jsx)(n.strong,{children:"pods"})," are nonpermanent resources. Each ",(0,t.jsx)(n.strong,{children:"pod"})," gets its own IP address, however in a ",(0,t.jsx)(n.strong,{children:"deployment"}),", a set of ",(0,t.jsx)(n.strong,{children:"pods"})," running in one moment in time could be different from the set of ",(0,t.jsx)(n.strong,{children:"pods"})," running in that ",(0,t.jsx)(n.strong,{children:"deployment"})," a moment later. ",(0,t.jsx)(n.strong,{children:"This leads to a problem"}),'. Consider a stateless image-processing server which is running with 3 replicas. Those replicas are identical \u2014 The "frontend" pods do not care ',(0,t.jsx)(n.em,{children:"which"}),' image-processing server would reply/serve their request. While the actual "backend" ',(0,t.jsx)(n.strong,{children:"pods"}),' may change, the "frontend" pods do not need to be aware of that, nor do they need to keep track of the actual set of the "backend" pods themselves.']}),"\n",(0,t.jsx)(n.p,{children:"The Service abstraction enables this decoupling."}),"\n",(0,t.jsx)(n.h3,{id:"--c-how-to-create-a-service",children:"- C. How to create a Service"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"apiVersion: v1\nkind: Service\nmetadata:\n  name: my-service\nspec:\n  type: NodePort\n  selector:\n    app.kubernetes.io/name: MyApp\n  ports:\n    - protocol: TCP\n      port: 80\n      # By default and for convenience, the `targetPort` is set to\n      # the same value as the `port` field.\n      targetPort: 80\n      # Optional field\n      # By default and for convenience, the Kubernetes control plane\n      # will allocate a port from a range (default: 30000-32767)\n      nodePort: 30007\n  clusterIP: 10.0.171.239\n  type: LoadBalancer\nstatus:\n  loadBalancer:\n    ingress:\n    - ip: 192.0.2.127\n"})}),"\n",(0,t.jsx)(n.p,{children:"Or using kubectl:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"kubectl create ...\n"})}),"\n",(0,t.jsx)(n.p,{children:"There are a few things to notice in this yaml config:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Both ",(0,t.jsx)(n.code,{children:"spec.ports.port"})," & ",(0,t.jsx)(n.code,{children:"spec.ports.targetPort"})," need to be filled manually. The ",(0,t.jsx)(n.code,{children:"targetPort"})," is the port number on the container which you'd like to expose out to the ",(0,t.jsx)(n.code,{children:"pod"}),", and ",(0,t.jsx)(n.code,{children:"port"})," is the port number on the ",(0,t.jsx)(n.code,{children:"pod"})," which you would like to expose out to the ",(0,t.jsx)(n.code,{children:"service"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Question"}),": We only specified a ",(0,t.jsx)(n.code,{children:"port"})," which is the pod's port (",(0,t.jsx)(n.code,{children:"--port"}),"), and a ",(0,t.jsx)(n.code,{children:"target-port"})," which is the container's port (",(0,t.jsx)(n.code,{children:"--target-port"}),"). But what about the node's port??\n",(0,t.jsx)(n.strong,{children:"Answer"}),": kubernetes would auto-generated some random port! Typically a high number. For example, if you provide --port=3000 and --target-port=80, kubernetes would add: node:32142 ",(0,t.jsx)(n.code,{children:"--\x3e"})," pod:3000 ",(0,t.jsx)(n.code,{children:"--\x3e"})," container:80"]}),"\n",(0,t.jsx)(n.h3,{id:"--d-service-types",children:"- D. Service Types"}),"\n",(0,t.jsx)(n.h4,{id:"type-1-clusterip-the-default",children:"Type 1: ClusterIP (the default)"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"ClusterIP"})," is the default ",(0,t.jsx)(n.code,{children:"Service"})," type which assigns an IP address from a pool of IP addresses that your cluster has reserved for that purpose."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"ClusterIP"})," is a type you can use to ",(0,t.jsx)(n.strong,{children:"expose a deployment internally"})," inside the cluster."]}),"\n",(0,t.jsxs)(n.p,{children:["A ",(0,t.jsx)(n.strong,{children:"service"})," of type ",(0,t.jsx)(n.strong,{children:"ClusterIP"})," would allow you to connect to its pods ",(0,t.jsx)(n.strong,{children:"only from within"})," the kubernetes cluster. This is great when your kubernetes cluster has a database deployment for example, like mongodb or mysql, which of course should not be available & accessible from the outside world."]}),"\n",(0,t.jsxs)(n.p,{children:["When choosing the type ",(0,t.jsx)(n.strong,{children:"Cluster IP"}),", a ",(0,t.jsx)(n.strong,{children:"service"})," would be created with a new virtual IP address assigned to it. Upon its creation you'd be asked to ",(0,t.jsx)(n.em,{children:"name"})," a ",(0,t.jsx)(n.strong,{children:"deployment"})," to which this ",(0,t.jsx)(n.strong,{children:"service"})," would be linked to. kubernetes would then do all sorts of magic behind the scenes, which essentially gives this ",(0,t.jsx)(n.strong,{children:"service"})," a matching label as that of the ",(0,t.jsx)(n.strong,{children:"deployment"}),".",(0,t.jsx)(n.br,{}),"\n","With the new virtual IP address given to the new ",(0,t.jsx)(n.strong,{children:"service"})," you'd be able to connect to that specific ",(0,t.jsx)(n.strong,{children:"deployment"})," and get responses from its ",(0,t.jsx)(n.strong,{children:"pods"}),". Also, with this ",(0,t.jsx)(n.strong,{children:"service"}),", kubernetes will distribute the load across the different ",(0,t.jsx)(n.strong,{children:"pods"})," related to that ",(0,t.jsx)(n.strong,{children:"deployment"}),"."]}),"\n",(0,t.jsx)(n.h4,{id:"type-2-nodeport",children:"Type 2: NodePort"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"NodePort"})," is a type you can use to ",(0,t.jsx)(n.strong,{children:"expose a deployment externally"})," outside the cluster."]}),"\n",(0,t.jsxs)(n.p,{children:["When we want to grant access to a deployment to the outside world, we pick a service of type ",(0,t.jsx)(n.strong,{children:"NodePort"}),". Typically, this is something we want for our ",(0,t.jsx)(n.strong,{children:"frontend server"})," deployment, and perhaps also our ",(0,t.jsx)(n.strong,{children:"api-gateway"})," deployment."]}),"\n",(0,t.jsxs)(n.p,{children:["If you set the service's type to ",(0,t.jsx)(n.strong,{children:"NodePort"}),", the Kubernetes control plane allocates a port from a range specified by ",(0,t.jsx)(n.code,{children:"--service-node-port-range"})," flag (default: 30000-32767). Each node proxies that port (the same port number on every Node) into your Service. Your Service reports the allocated port in its .spec.ports[*].nodePort field."]}),"\n",(0,t.jsx)(n.p,{children:"Using a NodePort gives you the freedom to set up your own load balancing solution, to configure environments that are not fully supported by Kubernetes, or even to expose one or more nodes' IP addresses directly."}),"\n",(0,t.jsxs)(n.p,{children:["For a node port Service, Kubernetes additionally allocates a port to match the protocol of the Service. Every ",(0,t.jsx)(n.strong,{children:"node"})," in the cluster configures itself to listen on that assigned port and to forward traffic to one of the ready endpoints (",(0,t.jsx)(n.strong,{children:"pods"}),") associated with that ",(0,t.jsx)(n.strong,{children:"Service"}),". You'll be able to contact the ",(0,t.jsx)(n.code,{children:"type: NodePort"})," ",(0,t.jsx)(n.strong,{children:"Service"}),", from outside the cluster, by connecting to any node using the appropriate protocol (for example: TCP), and the appropriate port (as assigned to that Service)."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Choosing your own port"})}),"\n",(0,t.jsxs)(n.p,{children:["If you want a specific port number, you can specify a value in the ",(0,t.jsx)(n.code,{children:"nodePort"})," field. The control plane will either allocate you that port or report that the API transaction failed. This means that you need to take care of possible port collisions yourself. You also have to use a valid port number, one that's inside the range configured for ",(0,t.jsx)(n.code,{children:"NodePort"})," use."]}),"\n",(0,t.jsx)(n.h4,{id:"type-3-loadbalancer",children:"Type 3: LoadBalancer"}),"\n",(0,t.jsxs)(n.p,{children:["On cloud providers which support external load balancers, setting the ",(0,t.jsx)(n.code,{children:"type"})," field to ",(0,t.jsx)(n.code,{children:"LoadBalancer"})," provisions a load balancer for your Service. The actual creation of the load balancer happens asynchronously, and information about the provisioned balancer is published in the Service's .",(0,t.jsx)(n.code,{children:"status.loadBalancer"})," field. For example:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"apiVersion: v1\nkind: Service\nmetadata:\n  name: my-service\nspec:\n  selector:\n    app.kubernetes.io/name: MyApp\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 9376\n  clusterIP: 10.0.171.239\n  type: LoadBalancer\nstatus:\n  loadBalancer:\n    ingress:\n    - ip: 192.0.2.127\n"})}),"\n",(0,t.jsx)(n.p,{children:"Traffic from the external load balancer is directed at the backend Pods. The cloud provider decides how it is load balanced."}),"\n",(0,t.jsxs)(n.p,{children:["To implement a Service of ",(0,t.jsx)(n.code,{children:"type: LoadBalancer"}),", Kubernetes typically starts off by making the changes that are equivalent to you requesting a Service of ",(0,t.jsx)(n.code,{children:"type: NodePort"}),". The cloud-controller-manager component then configures the external load balancer to forward traffic to that assigned node port."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Visual example:"})}),"\n",(0,t.jsxs)(n.p,{children:["I've created a service of type ",(0,t.jsx)(n.code,{children:"LoadBalancer"}),", fetched its details, and I want to show you something interesting."]}),"\n",(0,t.jsxs)(n.p,{children:["I've created a service manually with:",(0,t.jsx)(n.br,{}),"\n",(0,t.jsx)(n.em,{children:"(this hardly makes any different whether it's declarative or imperative)"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"kubectl expose deployment DEPLOYMENT_NAME --type=LoadBalancer --port=<port>\n"})}),"\n",(0,t.jsxs)(n.p,{children:["And now let's do ",(0,t.jsx)(n.code,{children:"get services"})," immediately afterwards:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"kubectl get services\n"})}),"\n",(0,t.jsx)(n.p,{children:"You'd see something like this:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S)\nmy-service LoadBalancer 10.109.195.184 <PENDING> 3000:32268/TCP\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The important thing I want you to notice is the part that says:",(0,t.jsx)(n.br,{}),"\n",(0,t.jsx)(n.code,{children:"External=ip is pending"}),(0,t.jsx)(n.br,{}),"\n","You will see ",(0,t.jsx)(n.code,{children:"<PENDING>"})," if you're using ",(0,t.jsx)(n.strong,{children:"minikube"}),", but when deploying the application by using one of the big known cloud providers, like amazon & google cloud, you will see a load balancer ip address assigned automatically.\nWhen using with minikube though, this will forever stay in this ",(0,t.jsx)(n.code,{children:"<PENDING>"})," state, and would result in a behavior that is exactly the same as ",(0,t.jsx)(n.strong,{children:"NodePort"})," type, meaning we will still be able to connect to our deployment using the IP address of the node."]}),"\n",(0,t.jsx)(n.h4,{id:"type-4-externalname",children:"Type 4: ExternalName"}),"\n",(0,t.jsxs)(n.p,{children:["Services of type ",(0,t.jsx)(n.code,{children:"ExternalName"})," map a Service to a DNS name, not to a typical selector such as ",(0,t.jsx)(n.code,{children:"my-service"})," or ",(0,t.jsx)(n.code,{children:"cassandra"}),". You specify these Services with the ",(0,t.jsx)(n.code,{children:"spec.externalName"})," parameter."]}),"\n",(0,t.jsxs)(n.p,{children:["This Service definition, for example, maps the ",(0,t.jsx)(n.code,{children:"my-service"})," Service in the ",(0,t.jsx)(n.code,{children:"prod"})," namespace to ",(0,t.jsx)(n.code,{children:"my.database.example.com"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"apiVersion: v1\nkind: Service\nmetadata:\n  name: my-service\n  namespace: prod\nspec:\n  type: ExternalName\n  externalName: my.database.example.com\n"})}),"\n",(0,t.jsxs)(n.p,{children:["When looking up the host ",(0,t.jsx)(n.code,{children:"my-service.prod.svc.cluster.local"}),", the cluster DNS Service returns a ",(0,t.jsx)(n.code,{children:"CNAME"})," record with the value ",(0,t.jsx)(n.code,{children:"my.database.example.com"}),". Accessing ",(0,t.jsx)(n.code,{children:"my-service"})," works in the same way as other Services but with the crucial difference that redirection happens at the DNS level rather than via proxying or forwarding. Should you later decide to move your database into your cluster, you can start its Pods, add appropriate selectors or endpoints, and change the Service's ",(0,t.jsx)(n.code,{children:"type"}),"."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"resource-4-secret",children:"Resource 4: Secret"}),"\n",(0,t.jsx)(n.h3,{id:"--a-what-is-a-configmap",children:"- A. What is a ConfigMap"}),"\n",(0,t.jsxs)(n.p,{children:["A ",(0,t.jsx)(n.strong,{children:"ConfigMap"})," is a Kubernetes resource used ",(0,t.jsx)(n.strong,{children:"to store non-confidential"})," configuration data in key-value pairs. It ",(0,t.jsx)(n.strong,{children:"decouples configuration"})," artifacts ",(0,t.jsx)(n.strong,{children:"from container images"}),", allowing applications to be configured dynamically ",(0,t.jsx)(n.strong,{children:"without rebuilding images"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"--b-how-to-create-a-configmap",children:"- B. How to create a ConfigMap"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: app-config\ndata:\n  LOG_LEVEL: "debug"\n  APP_MODE: "production"\n'})}),"\n",(0,t.jsx)(n.p,{children:"Or using kubectl:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"kubectl create configmap app-config --from-literal=LOG_LEVEL=debug --from-literal=APP_MODE=production\n"})}),"\n",(0,t.jsx)(n.h3,{id:"--c-how-to-attach-a-configmap-to-a-deployment",children:"- C. How to Attach a ConfigMap to a Deployment"}),"\n",(0,t.jsx)(n.p,{children:"As Environment Variables:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"envFrom:\n  - configMapRef:\n      name: app-config\n"})}),"\n",(0,t.jsx)(n.p,{children:"As Mounted Files (e.g. config files):"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"volumeMounts:\n  - name: config-volume\n    mountPath: /etc/config\nvolumes:\n  - name: config-volume\n    configMap:\n      name: app-config\n"})}),"\n",(0,t.jsx)(n.h3,{id:"--d-additional-notes",children:"- D. Additional Notes"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["ConfigMaps are ",(0,t.jsx)(n.strong,{children:"namespaced"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["Not suitable for secrets; use ",(0,t.jsx)(n.code,{children:"Secret"})," for sensitive data."]}),"\n",(0,t.jsx)(n.li,{children:"If the ConfigMap is deleted or changed, pods may need a restart (unless files are mounted and watched)."}),"\n",(0,t.jsxs)(n.li,{children:["You can combine ConfigMaps with ",(0,t.jsx)(n.code,{children:"Downward API"})," to inject runtime metadata."]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"resource-5-secret",children:"Resource 5: Secret"}),"\n",(0,t.jsx)(n.h3,{id:"--a-what-is-a-secret",children:"- A. What is a Secret"}),"\n",(0,t.jsxs)(n.p,{children:["A ",(0,t.jsx)(n.strong,{children:"Secret"})," is a Kubernetes resource used to ",(0,t.jsx)(n.strong,{children:"store sensitive data"}),", such as passwords, API keys, tokens, or TLS certificates, in a secure and encoded way."]}),"\n",(0,t.jsx)(n.h3,{id:"--b-common-use-cases",children:"- B. Common Use Cases"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Database credentials"}),"\n",(0,t.jsx)(n.li,{children:"OAuth tokens"}),"\n",(0,t.jsx)(n.li,{children:"SSH keys"}),"\n",(0,t.jsx)(n.li,{children:"TLS certs and keys"}),"\n",(0,t.jsx)(n.li,{children:"Third-party service credentials"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"--c-how-to-create-a-secret",children:"- C. How to create a Secret"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'apiVersion: v1\nkind: Secret\nmetadata:\n  name: db-secret\ntype: Opaque\ndata:\n  username: YWRtaW4=      # "admin"\n  password: c2VjcmV0MTIz  # "secret123"\n'})}),"\n",(0,t.jsx)(n.p,{children:"Or using kubectl:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"kubectl create secret generic db-secret \\\n  --from-literal=username=admin \\\n  --from-literal=password=secret123\n"})}),"\n",(0,t.jsx)(n.h3,{id:"--d-how-to-attach-a-secret-to-a-deployment",children:"- D. How to Attach a Secret to a Deployment"}),"\n",(0,t.jsx)(n.p,{children:"As Environment Variables:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"envFrom:\n  - secretKeyRef:\n      name: db-secret\n"})}),"\n",(0,t.jsx)(n.p,{children:"As Mounted Files (e.g. config files):"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"volumeMounts:\n  - name: secret-volume\n    mountPath: /etc/secrets\nvolumes:\n  - name: secret-volume\n    configMap:\n      name: db-secret\n"})}),"\n",(0,t.jsx)(n.h3,{id:"--e-additional-notes",children:"- E. Additional Notes"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Secrets are ",(0,t.jsx)(n.strong,{children:"base64-encoded"}),", not encrypted by default."]}),"\n",(0,t.jsxs)(n.li,{children:["Enable encryption at rest via ",(0,t.jsx)(n.code,{children:"EncryptionConfiguration"})," for stronger protection."]}),"\n",(0,t.jsxs)(n.li,{children:["Secrets are ",(0,t.jsx)(n.strong,{children:"namespaced"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["Avoid printing Secrets in logs or exposing them in ",(0,t.jsx)(n.code,{children:"kubectl describe"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"--f-best-practices",children:"- F. Best Practices"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Use ",(0,t.jsx)(n.code,{children:"Secret"})," for anything you wouldn't commit to Git."]}),"\n",(0,t.jsxs)(n.li,{children:["Combine with ",(0,t.jsx)(n.code,{children:"ConfigMap"})," for full app configuration."]}),"\n",(0,t.jsx)(n.li,{children:"Use Kubernetes RBAC to restrict access to secrets."}),"\n",(0,t.jsx)(n.li,{children:"Rotate secrets regularly and automate updates with tools like Vault or SealedSecrets."}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"resource-6-serviceaccount",children:"Resource 6: ServiceAccount"}),"\n",(0,t.jsx)(n.h3,{id:"--a-what-is-a-serviceaccount",children:"- A. What is a ServiceAccount"}),"\n",(0,t.jsxs)(n.p,{children:["A ",(0,t.jsx)(n.strong,{children:"ServiceAccount"})," is a Kubernetes resource that provides an ",(0,t.jsx)(n.strong,{children:"identity for pods"})," to interact with the Kubernetes API. It defines what a pod is allowed to do within the cluster using associated ",(0,t.jsx)(n.strong,{children:"credentials and permissions"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"--b-why-do-we-need-it-1",children:"- B. Why Do We Need It?"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Authentication"}),": Every pod that accesses the Kubernetes API needs an identity."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Fine-grained permissions"}),": Paired with ",(0,t.jsx)(n.strong,{children:"RBAC"})," (Role-Based Access Control) to restrict what a pod can do (e.g., list pods, read secrets)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Isolation"}),": Different pods can use different ServiceAccounts with different privileges."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"--c-default-behavior",children:"- C. Default Behavior"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Each ",(0,t.jsx)(n.em,{children:"namespace"})," has a ",(0,t.jsx)(n.strong,{children:"default ServiceAccount"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["If no ",(0,t.jsx)(n.code,{children:"ServiceAccount"})," is specified, pods use ",(0,t.jsx)(n.code,{children:"default"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["Kubernetes automatically mounts a token from the ",(0,t.jsx)(n.code,{children:"ServiceAccount"})," into pods at ",(0,t.jsx)(n.code,{children:"/var/run/secrets/kubernetes.io/serviceaccount"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"--d-how-to-create-a-serviceaccount",children:"- D. How to create a ServiceAccount"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"apiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: app-sa\n"})}),"\n",(0,t.jsx)(n.p,{children:"Or using kubectl:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"kubectl create secret generic db-secret \\\n  --from-literal=username=admin \\\n  --from-literal=password=secret123\n"})}),"\n",(0,t.jsx)(n.h3,{id:"--e-how-to-attach-a-serviceaccount-to-a-deployment",children:"- E. How to Attach a ServiceAccount to a Deployment"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"spec:\n  serviceAccountName: app-sa\n"})}),"\n",(0,t.jsx)(n.h3,{id:"--f-combining-with-rbac",children:"- F. Combining with RBAC"}),"\n",(0,t.jsx)(n.p,{children:"To control access:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Create a ",(0,t.jsx)(n.strong,{children:"Role"})," or ",(0,t.jsx)(n.strong,{children:"ClusterRole"})]}),"\n",(0,t.jsxs)(n.li,{children:["Create a ",(0,t.jsx)(n.strong,{children:"RoleBinding"})," or ",(0,t.jsx)(n.strong,{children:"ClusterRoleBinding"})," that binds the role to the ServiceAccount."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Example RoleBinding:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"apiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: read-pods\n  namespace: default\nsubjects:\n  - kind: ServiceAccount\n    name: app-sa\nroleRef:\n  kind: Role\n  name: pod-reader\n  apiGroup: rbac.authorization.k8s.io\n"})}),"\n",(0,t.jsx)(n.h3,{id:"--g-best-practices",children:"- G. Best Practices"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Use least privilege"}),": Only grant the permissions a pod truly needs."]}),"\n",(0,t.jsxs)(n.li,{children:["Avoid using the ",(0,t.jsx)(n.code,{children:"default"})," ServiceAccount for production workloads."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Rotate tokens"})," if compromised (via ServiceAccount recreation or automation)."]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"resource-999-ingress",children:"Resource 999: Ingress"}),"\n",(0,t.jsx)(n.h3,{id:"--a-what-is-an-ingress",children:"- A. What is an Ingress"}),"\n",(0,t.jsxs)(n.p,{children:["An ",(0,t.jsx)(n.strong,{children:"Ingress"})," is a Kubernetes resource that ",(0,t.jsx)(n.strong,{children:"manages external HTTP(S) access"})," to services within a cluster. It acts as a ",(0,t.jsx)(n.strong,{children:"layer 7 (application layer) reverse proxy"}),", routing traffic based on hostnames and paths."]}),"\n",(0,t.jsx)(n.h3,{id:"--b-why-do-we-need-it-2",children:"- B. Why Do We Need It?"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Single entry point"}),": Consolidates external access to multiple services."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Path-based (or host-based) routing"}),": Routes requests to different services based on URL or hostname."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"TLS termination"}),": Handles HTTPS at the edge."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Custom rules"}),": Supports redirects, headers, rate limiting, etc. via annotations or controllers."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"--c-how-it-works",children:"- C. How It Works"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["An Ingress requires an ",(0,t.jsx)(n.strong,{children:"Ingress Controller"})," (e.g., NGINX, Traefik, HAProxy)."]}),"\n",(0,t.jsx)(n.li,{children:"The Ingress resource defines rules."}),"\n",(0,t.jsx)(n.li,{children:"The controller watches Ingress resources and updates its proxy configuration accordingly."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"--d-how-to-create-a-serviceaccount-1",children:"- D. How to create a ServiceAccount"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: my-ingress\n  annotations:\n    nginx.ingress.kubernetes.io/rewrite-target: /\nspec:\n  rules:\n    - host: example.com\n      http:\n        paths:\n          - path: /app\n            pathType: Prefix\n            backend:\n              service:\n                name: my-service\n                port:\n                  number: 80\n"})}),"\n",(0,t.jsx)(n.h3,{id:"--e-how-to-expose-a-deployment-via-ingress",children:"- E. How to Expose a Deployment via Ingress"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"spec:\n  tls:\n    - hosts:\n        - example.com\n      secretName: tls-secret\n"})}),"\n",(0,t.jsx)(n.h3,{id:"--f-additional-notes",children:"- F. Additional Notes"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Works only with HTTP(S) traffic (for TCP/UDP, use a LoadBalancer or Service)."}),"\n",(0,t.jsxs)(n.li,{children:["You must ",(0,t.jsx)(n.strong,{children:"install an Ingress Controller"})," separately (Ingress alone does nothing)."]}),"\n",(0,t.jsx)(n.li,{children:"Supports rewrite rules, authentication, rate limiting, etc. via annotations."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"--g-best-practices-1",children:"- G. Best Practices"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Use ",(0,t.jsx)(n.strong,{children:"host-based routing"})," for cleaner URL management."]}),"\n",(0,t.jsxs)(n.li,{children:["Use ",(0,t.jsx)(n.strong,{children:"TLS"})," for secure traffic."]}),"\n",(0,t.jsx)(n.li,{children:"Keep Ingress rules in sync with DNS entries."}),"\n",(0,t.jsx)(n.li,{children:"Monitor and secure your Ingress Controller \u2014 it's a major attack surface."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},7010:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>l});var r=s(758);const t={},i=r.createContext(t);function a(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);