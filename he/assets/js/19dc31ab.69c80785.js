"use strict";(self.webpackChunkdocusaurus_guides=self.webpackChunkdocusaurus_guides||[]).push([[5371],{3333:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>l,frontMatter:()=>i,metadata:()=>t,toc:()=>h});const t=JSON.parse('{"id":"programming/crypto","title":"Crypto","description":"1. Introduction","source":"@site/docs/programming/crypto.md","sourceDirName":"programming","slug":"/programming/crypto","permalink":"/guides/he/docs/programming/crypto","draft":false,"unlisted":false,"editUrl":"https://github.com/talkohavy/guides/docs/programming/crypto.md","tags":[],"version":"current","frontMatter":{},"sidebar":"mySidebar","previous":{"title":"- Certificates","permalink":"/guides/he/docs/programming/certificates"},"next":{"title":"- CSS","permalink":"/guides/he/docs/programming/css"}}');var a=s(6070),r=s(7010);const i={},c="Crypto",o={},h=[{value:"1. Introduction",id:"1-introduction",level:2},{value:"2. Cryptography Concepts",id:"2-cryptography-concepts",level:2},{value:"- Concept 1: HASH",id:"--concept-1-hash",level:3},{value:"A. Description",id:"a-description",level:4},{value:"B. Hash in Nodejs",id:"b-hash-in-nodejs",level:4},{value:"- Step 1: createHash",id:"--step-1-createhash",level:5},{value:"- Step 2: choose a hashing algorithm",id:"--step-2-choose-a-hashing-algorithm",level:5},{value:"- Step 3: call <code>update(input)</code>",id:"--step-3-call-updateinput",level:5},{value:"- Step 4: call <code>digest(encoding)</code>",id:"--step-4-call-digestencoding",level:5},{value:"- Concept 2: SALT",id:"--concept-2-salt",level:3},{value:"A. Description",id:"a-description-1",level:4},{value:"B. Implementation in nodejs",id:"b-implementation-in-nodejs",level:4},{value:"C. Usage Example in node",id:"c-usage-example-in-node",level:4},{value:"- Concept 3: HMAC",id:"--concept-3-hmac",level:3},{value:"A. Description",id:"a-description-2",level:4},{value:"B. Is <code>scryptSync</code> an <code>HMAC</code>?",id:"b-is-scryptsync-an-hmac",level:4},{value:"C. Example usage in nodejs",id:"c-example-usage-in-nodejs",level:4},{value:"- Concept 4: SYMMETRIC ENCRYPTION",id:"--concept-4-symmetric-encryption",level:3},{value:"A. Description",id:"a-description-3",level:4},{value:"B. Example usage in nodejs",id:"b-example-usage-in-nodejs",level:4},{value:"- Concept 5: KEYPAIRS",id:"--concept-5-keypairs",level:3},{value:"- Concept 6: ASYMMETRIC ENCRYPTION",id:"--concept-6-asymmetric-encryption",level:3},{value:"- Concept 7: SIGNING",id:"--concept-7-signing",level:3},{value:"3. Summary",id:"3-summary",level:2},{value:"- A. Create Hash",id:"--a-create-hash",level:3},{value:"\u2022 Algorithm:",id:"-algorithm",level:4},{value:"\u2022 Encoding:",id:"-encoding",level:4},{value:"- B. Create Salt",id:"--b-create-salt",level:3}];function d(e){const n={br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"crypto",children:"Crypto"})}),"\n",(0,a.jsx)(n.h2,{id:"1-introduction",children:"1. Introduction"}),"\n",(0,a.jsxs)(n.p,{children:["Node comes with a built-in package called crypto.\nThe node",":crypto"," module provides cryptographic functionality that includes a set of wrappers for OpenSSL's hash, HMAC, cipher, decipher, sign, and verify functions.\nBefore talking about crypto, we need to discuss 7 cryptography concepts."]}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"2-cryptography-concepts",children:"2. Cryptography Concepts"}),"\n",(0,a.jsx)(n.h3,{id:"--concept-1-hash",children:"- Concept 1: HASH"}),"\n",(0,a.jsx)(n.h4,{id:"a-description",children:"A. Description"}),"\n",(0,a.jsxs)(n.p,{children:["A ",(0,a.jsx)(n.strong,{children:"hash"})," is simply applying a function on a certain content, and receiving back a mumbled string that looks like garbage. The important part is that - if we apply the same ",(0,a.jsx)(n.strong,{children:"hash function"})," on the same input, we'd get the same output."]}),"\n",(0,a.jsxs)(n.p,{children:["A unique feature of a hash is that it's ",(0,a.jsx)(n.strong,{children:"one way"}),". In contrast to encryption, one cannot decipher a hashed content, since the ",(0,a.jsx)(n.strong,{children:"output isn't unique"}),". Two ",(0,a.jsx)(n.em,{children:"different"})," inputs can generate the ",(0,a.jsx)(n.em,{children:"same output"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"A common usage for hashes is storing passwords in a database. In such case, even if the database has been breached, the passwords can never be recovered."}),"\n",(0,a.jsx)(n.h4,{id:"b-hash-in-nodejs",children:"B. Hash in Nodejs"}),"\n",(0,a.jsx)(n.h5,{id:"--step-1-createhash",children:"- Step 1: createHash"}),"\n",(0,a.jsxs)(n.p,{children:["How can we use hash in node?",(0,a.jsx)(n.br,{}),"\n","We start off by importing the ",(0,a.jsx)(n.code,{children:"createHash"})," function from the crypto package:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const { createHash } = require('crypto');\n"})}),"\n",(0,a.jsx)(n.p,{children:'Next, we generate a custom function, which we\'d name as "myHash":'}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"// This is an incomplete code!\nfunction myHash(input){\n  return createHash();\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"The function above returns a hash string as the output."}),"\n",(0,a.jsx)(n.h5,{id:"--step-2-choose-a-hashing-algorithm",children:"- Step 2: choose a hashing algorithm"}),"\n",(0,a.jsx)(n.p,{children:"The next step is to define the hashing algorithm you want to use."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// This is an incomplete code!\nfunction hash(input){\n  return createHash('sha256');\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The algorithm is dependent on the available algorithms supported by the version of ",(0,a.jsx)(n.code,{children:"openssl"})," on the platform."]}),"\n",(0,a.jsx)(n.p,{children:"You can run:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"openssl list --digest-algorithms\n"})}),"\n",(0,a.jsx)(n.p,{children:"to display available algorithms."}),"\n",(0,a.jsx)(n.p,{children:"Famous algorithm options are:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"sha256"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"sha512"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"md5"})}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"argon2"})," (not built-in to node's crypto)"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:['In the example code above, I\'m using "sha256", which stands for "',(0,a.jsx)(n.strong,{children:"Secure Hash Algorithm"}),'". This algorithm returns a ',(0,a.jsx)(n.strong,{children:"hash value"}),", which is also called a ",(0,a.jsx)(n.strong,{children:"digest"}),", with 256 bits."]}),"\n",(0,a.jsxs)(n.p,{children:["The algorithm you choose is important! OFor example, one of the algorithms to choose from is ",(0,a.jsx)(n.code,{children:"md5"}),". As computers have become faster, and the internet more vast, the ",(0,a.jsx)(n.code,{children:"md5"})," algorithm has become obsolete. Remember, cryptography is always evolving. ",(0,a.jsx)(n.code,{children:"sha256"})," is a good option, but there are even better solutions like ",(0,a.jsx)(n.code,{children:"argon2"}),", although it's not built-in to node's crypto.",(0,a.jsx)(n.br,{}),"\n","Once we have our hashing algo, we can call ",(0,a.jsx)(n.code,{children:"update"})," and pass in input value:"]}),"\n",(0,a.jsxs)(n.h5,{id:"--step-3-call-updateinput",children:["- Step 3: call ",(0,a.jsx)(n.code,{children:"update(input)"})]}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"update"})," method accepts an input, the input we want to be hashed:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// This is an incomplete code!\nfunction hash(value){\n  return createHash('sha256').update(value);\n}\n"})}),"\n",(0,a.jsxs)(n.h5,{id:"--step-4-call-digestencoding",children:["- Step 4: call ",(0,a.jsx)(n.code,{children:"digest(encoding)"})]}),"\n",(0,a.jsxs)(n.p,{children:["We return an output by invoking the ",(0,a.jsx)(n.code,{children:"digest"})," method, along with the ",(0,a.jsx)(n.strong,{children:"encoding"})," we want to return:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"function hash(value){\n  return createHash('sha256').update(value).digest('hex');\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"Key things to notice here:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["We invoke ",(0,a.jsx)(n.code,{children:"createHash"})," every time on every new input. We do not call ",(0,a.jsx)(n.code,{children:"createHash"})," just once, and use it on multiple inputs. If we did that, we would get an error! ",(0,a.jsx)(n.code,{children:"Error [ERR_CRYPTO_HASH_FINALIZED]: Digest already called"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:["We have two separate methods: ",(0,a.jsx)(n.code,{children:"update"})," & ",(0,a.jsx)(n.code,{children:"digest"}),". The ",(0,a.jsx)(n.code,{children:"update(data)"})," method allows you to incrementally add chunks of data to the hash function. This is useful for steaming support which grants performance optimization."]}),"\n",(0,a.jsxs)(n.li,{children:["The digest(encoding) method finalizes the hash computation and produces the final output (typically in 'hex', 'base64', or a raw Buffer). Once digest() is called ",(0,a.jsx)(n.strong,{children:"the hash computation is finalized"}),". You can no longer call ",(0,a.jsx)(n.code,{children:"update()"})," on that hash instance (you'd need to create a new one to hash more data)."]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["As the name suggests, the ",(0,a.jsx)(n.code,{children:"digest"})," function digests (calculates) all of the data passed, which you want to be hashed. If an encoding is provided, a ",(0,a.jsx)(n.em,{children:"string"})," will be returned; otherwise a ",(0,a.jsx)(n.em,{children:"Buffer"})," is returned."]}),"\n",(0,a.jsx)(n.p,{children:"Here is the list of all encoding options that digest accepts:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"hex"})," (what we will use)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"base64"})," (what you'll commonly see)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"utf8"})," (utf-8 is an alias)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"utf16le"})," (utf-16le is an alias)"]}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"latin1"})}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Now that you have this function, you can pass in an input, like a password:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const password = 'hi-mom!';\nconst hash1 = hash(password);\n\nconsole.log(hash1); // output: 7a5d84e61a2234b450185fde58c237bb13e93d93d90f669b114d\n"})}),"\n",(0,a.jsx)(n.p,{children:"So you'll get this long string of numbers and letters, that hide its original meaning. Now, if we create another hash, and compare the two, we'll know that the original value is the same, if the two hashes match-up:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// compare two hashed passwords:\nconst password2 = 'hi-mom!';\nconst hash2 = hash(password);\nconst isMatch = hash1 === hash2\nconsole.log(isMatch)\n// would print out: true\n"})}),"\n",(0,a.jsxs)(n.p,{children:["That's super useful, but a hash by itself isn't actually sufficient for storing a password in a database. And that brings us to our next topic - ",(0,a.jsx)(n.strong,{children:"salt"}),"!"]}),"\n",(0,a.jsx)(n.h3,{id:"--concept-2-salt",children:"- Concept 2: SALT"}),"\n",(0,a.jsx)(n.h4,{id:"a-description-1",children:"A. Description"}),"\n",(0,a.jsxs)(n.p,{children:["As mentioned above, a hash is super useful, but by itself, a hash isn't sufficient enough for storing passwords in a database. We need ",(0,a.jsx)(n.code,{children:"salt"}),"!"]}),"\n",(0,a.jsx)(n.p,{children:'The fact that a hashing function always returns the same value is also a problem when it comes to passwords. Especially when you let stupid humans come up with them, like "password123".'}),"\n",(0,a.jsxs)(n.p,{children:["If a hacker obtains the database, and the passwords are hashed, they can often just go to something like a ",(0,a.jsx)(n.strong,{children:"rainbow table"}),", that has a bunch of pre-computed hashes and find a bunch of commonly used passwords.",(0,a.jsx)(n.br,{}),"\n","A ",(0,a.jsx)(n.code,{children:"salt"})," is just a random value that's added to the password before it's hashed, and therefore making it much harder to guess."]}),"\n",(0,a.jsx)(n.h4,{id:"b-implementation-in-nodejs",children:"B. Implementation in nodejs"}),"\n",(0,a.jsxs)(n.p,{children:["In nodejs, we have a function called ",(0,a.jsx)(n.code,{children:"scryptSync"})," (prefer using ",(0,a.jsx)(n.code,{children:"scrypt"})," instead to prevent blocking the main thread)."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"scryptSync"})," is a built-in function in Node.js inside the ",(0,a.jsx)(n.code,{children:"crypto"})," module that derives a cryptographic key from a password. It is mainly used for securely hashing passwords and generating encryption keys. ",(0,a.jsx)(n.code,{children:"scryptSync"})," is a hashing function, but it's specifically ",(0,a.jsx)(n.strong,{children:"a key derivation function (KDF)"})," rather than just a simple hash function like SHA-256."]}),"\n",(0,a.jsxs)(n.p,{children:["How is it different from ",(0,a.jsx)(n.code,{children:"createHash"}),"?"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"createHash(algorithm)"})," (e.g., SHA-256) is a simple hashing function that produces a fixed-length hash. It is fast but ",(0,a.jsx)(n.strong,{children:"not ideal for password storage"})," because it's vulnerable to brute-force attacks."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"scryptSync(password, salt, keyLength, options?)"})," ",(0,a.jsx)(n.strong,{children:"is slow by design"}),' and includes a "salt" to prevent precomputed attacks (rainbow tables). It is better suited for ',(0,a.jsx)(n.strong,{children:"password hashing"})," because it is computationally expensive, making brute-force attacks harder."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"c-usage-example-in-node",children:"C. Usage Example in node"}),"\n",(0,a.jsxs)(n.p,{children:["In node, we can hash a password with salt by importing ",(0,a.jsx)(n.code,{children:"scryptSync"})," & ",(0,a.jsx)(n.code,{children:"randomBytes"})," functions from ",(0,a.jsx)(n.code,{children:"crypto"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const { scryptSync, randomBytes } = require('crypto');\n"})}),"\n",(0,a.jsx)(n.p,{children:"Then we'll define the functions signUp & login:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const { scryptSync, randomBytes } = require('crypto');\n\nfunction signUp(email,password){}\n\nfunction login(email,password){}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["They both take an email and a password as their arguments.",(0,a.jsx)(n.br,{}),"\n","When a user signs up, we'll generate a ",(0,a.jsx)(n.code,{children:"salt"}),", which is just a random set of characters, using the ",(0,a.jsx)(n.code,{children:"randomBytes"})," function:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const { scryptSync, randomBytes } = require('crypto');\n\nfunction signUp(email,password){\n  const salt = randomBytes(16).toString('hex');\n}\n\nfunction login(email,password){}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Then we will use ",(0,a.jsx)(n.code,{children:"scryptSync"})," to hash both the salt and the password:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const { scryptSync, randomBytes } = require('crypto');\n\nfunction signUp(email,password){\n  const salt = randomBytes(16).toString('hex');\n  const hashedPassword = scryptSync(password, salt, 64).toString('hex');\n}\n\nfunction login(email,password){}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["We provide ",(0,a.jsx)(n.code,{children:"scryptSync"})," with 3 things:"]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"the original password"}),"\n",(0,a.jsx)(n.li,{children:"the salt"}),"\n",(0,a.jsxs)(n.li,{children:["a ",(0,a.jsx)(n.em,{children:"key length"})," (which is _recommended to be 64)"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["Without getting into more details, ",(0,a.jsx)(n.code,{children:"scryptSync"})," makes it more ",(0,a.jsx)(n.strong,{children:"computational intensive to crack using brute force"}),", and it's actually been used as ",(0,a.jsx)(n.strong,{children:"proof of work algorithms used in cryptocurrency mining"}),".",(0,a.jsx)(n.br,{}),"\n","So now that we have a hashed password, we also need to store the salt with it, and we can do that by just pre-pending it to the existing string, separated by a semi-colon:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const { scryptSync, randomBytes } = require('crypto');\n\nfunction signUp(email,password){\n  const salt = randomBytes(16).toString('hex');\n  const hashedPassword = scryptSync(password, salt, 64).toString('hex');\n\n  const user = { email, password: `${salt}:${hashedPassword}` }\n}\n\nfunction login(email,password){}\n"})}),"\n",(0,a.jsx)(n.p,{children:"Now, when the user goes to log in, we can grab the salt from the database, and recreate the original hash, like so:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const { scryptSync, randomBytes } = require('crypto');\n\nfunction signUp(email,password){\n  const salt = randomBytes(16).toString('hex');\n  const hashedPassword = scryptSync(password, salt, 64).toString('hex');\n\n  const user = { email, password: `${salt}:${hashedPassword}` };\n\n  users.push(user);\n\n  return user;\n}\n\nfunction login(email,password){\n  const user = users.find((item) => item.email === email);\n\n  const [salt,key] = user.password.split(':');\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"A standard user login flow:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"The client supplies an email & a password."}),"\n",(0,a.jsx)(n.li,{children:"We use ONLY the email to get the user record from the database"}),"\n",(0,a.jsx)(n.li,{children:'Split the "password" column to both the salt & the hashed password'}),"\n",(0,a.jsxs)(n.li,{children:["Use the salt and ",(0,a.jsx)(n.em,{children:"provided"})," password to regenerate the hashed password."]}),"\n",(0,a.jsxs)(n.li,{children:["Compare between the stored hashedPassword, and the regeneratedHashedPassword - ",(0,a.jsx)(n.code,{children:"hashedPassword === regeneratedHashedPassword"})]}),"\n",(0,a.jsx)(n.li,{children:"If true, login was successful! Else, throw 401 unauthorized error."}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["As an extra added security precaution, we will replace step 5, which is just a simple compare action, with a better one. We will use the ",(0,a.jsx)(n.code,{children:"timingSafeEqual"})," function."]}),"\n",(0,a.jsxs)(n.p,{children:["A ",(0,a.jsx)(n.strong,{children:"timing attack"})," is where a hacker measures the amount of time it takes to perform an operation, to obtain information about the value. This function helps prevents that type of attack. How?"]}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"timingSafeEqual"})," function compares the bytes that represent the 2 given inputs ",(0,a.jsx)(n.strong,{children:"using a constant-time algorithm"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const { scryptSync, randomBytes, timingSafeEqual } = require('crypto');\n\nfunction signUp(email,password){ ... }\n\nfunction login(email,password){\n  const user = users.find((item) => item.email === email);\n\n  const [salt,hashedPassword] = user.password.split(':');\n  const rawHashedPasswordBuffer = scryptSync(rawPassword, salt, 64);\n\n  const hashedPasswordBuffer = Buffer.from(hashedPassword, 'hex');\n  const match = timingSafeEqual(rawHashedPasswordBuffer, hashedPasswordBuffer);\n  if(match) return 'login success!';\n\n  return 'login failed...';\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"crypto.timingSafeEqual()"})," function is used to determine whether two variables are equal without exposing timing information that may allow an attacker to guess one of the values. A constant-time algorithm underpins it. That's how basic email-password authentication works on the web, but a related topic you might come across is Hashed-based Message Authentication Code (",(0,a.jsx)(n.strong,{children:"HMAC"}),")."]}),"\n",(0,a.jsx)(n.h3,{id:"--concept-3-hmac",children:"- Concept 3: HMAC"}),"\n",(0,a.jsx)(n.h4,{id:"a-description-2",children:"A. Description"}),"\n",(0,a.jsxs)(n.p,{children:["What is ",(0,a.jsx)(n.strong,{children:"HMAC"}),"?"]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["It Stands for: ",(0,a.jsx)(n.strong,{children:"Hashed Based Message Authentication Code"})]}),"\n",(0,a.jsx)(n.li,{children:"It's a hash that also requires a password/key."}),"\n",(0,a.jsxs)(n.li,{children:["It's used for signing a message, preventing against tampering & forged messages (as its name suggest - ",(0,a.jsx)(n.strong,{children:"Message Authentication"}),")."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"An example is a Json Web Token (JWT), used for authentication on the web. When a user logs in on a trusted server, the server generates a token using a special key chosen by the developer. Then, the client and server can pass that token back and forth, and the server can trust it because it knows that only someone with the exact same secret key could have generated that hash signature."}),"\n",(0,a.jsxs)(n.h4,{id:"b-is-scryptsync-an-hmac",children:["B. Is ",(0,a.jsx)(n.code,{children:"scryptSync"})," an ",(0,a.jsx)(n.code,{children:"HMAC"}),"?"]}),"\n",(0,a.jsxs)(n.p,{children:["No, ",(0,a.jsx)(n.code,{children:"scryptSync"})," is not an ",(0,a.jsx)(n.code,{children:"HMAC"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["At a high level, both ",(0,a.jsx)(n.code,{children:"HMAC"})," and ",(0,a.jsx)(n.code,{children:"scryptSync"})," involve a secret input and a hashing function, ",(0,a.jsx)(n.strong,{children:"but they serve different cryptographic purposes"}),". Let's break it down further."]}),"\n",(0,a.jsxs)(n.p,{children:["One might say that other other than the fact that one is fast (",(0,a.jsx)(n.code,{children:"HMAC"}),") and the other is slow by design (",(0,a.jsx)(n.code,{children:"scryptSync"}),"), they both seem very much alike. That it's basically like using a permanent fixed salt."]}),"\n",(0,a.jsxs)(n.p,{children:["It's true that the ",(0,a.jsx)(n.em,{children:"secret key"})," can resemble a ",(0,a.jsx)(n.em,{children:"fixed salt"})," in some ways:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Both modify the hashing process to introduce uniqueness."}),"\n",(0,a.jsx)(n.li,{children:"Both prevent certain attacks (e.g., precomputed attacks like rainbow tables)."}),"\n",(0,a.jsxs)(n.li,{children:["Both take an additional input (",(0,a.jsx)(n.code,{children:"HMAC"}),": a key, ",(0,a.jsx)(n.code,{children:"scryptSync"}),": a salt)."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"However, there are critical differences that make this analogy imperfect:"}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"Feature"}),(0,a.jsxs)(n.th,{children:[(0,a.jsx)(n.code,{children:"scryptSync"})," (",(0,a.jsx)(n.strong,{children:"KDF"}),")"]}),(0,a.jsxs)(n.th,{children:[(0,a.jsx)(n.code,{children:"HMAC"})," (Message Authentication)"]})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.strong,{children:"Purpose"})}),(0,a.jsx)(n.td,{children:"Key derivation (password hashing)"}),(0,a.jsx)(n.td,{children:"Message integrity & authenticity"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.strong,{children:"What It Produces"})}),(0,a.jsx)(n.td,{children:"A derived cryptographic key"}),(0,a.jsx)(n.td,{children:"A message authentication code (MAC)"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.strong,{children:"Input Components"})}),(0,a.jsx)(n.td,{children:"Password + Salt + Work Factor"}),(0,a.jsx)(n.td,{children:"Secret Key + Message"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.strong,{children:"Salt/Key Behavior"})}),(0,a.jsx)(n.td,{children:"Salt must be random per user"}),(0,a.jsx)(n.td,{children:"Secret key is fixed per system"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.strong,{children:"Prevention Against"})}),(0,a.jsx)(n.td,{children:"Brute-force & Rainbow Table attacks"}),(0,a.jsx)(n.td,{children:"Tampering & Forged Messages"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.strong,{children:"Processing Time"})}),(0,a.jsx)(n.td,{children:"Slow (designed to be expensive)"}),(0,a.jsx)(n.td,{children:"Fast (designed for quick verification)"})]})]})]}),"\n",(0,a.jsxs)(n.p,{children:["\u2705 Why not use a fixed salt for ",(0,a.jsx)(n.code,{children:"scrypt"}),"?"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"A fixed salt"})," is just like hashing a password without one \u2014 it offers no real protection against precomputed attacks."]}),"\n",(0,a.jsxs)(n.p,{children:["\u2705 Why not use a random salt for ",(0,a.jsx)(n.code,{children:"HMAC"}),"?"]}),"\n",(0,a.jsxs)(n.p,{children:["Each ",(0,a.jsx)(n.code,{children:"HMAC"})," computation should be deterministic, meaning that the same input should always yield the same result, otherwise it can't be verified."]}),"\n",(0,a.jsx)(n.p,{children:"\u2705 What Happens If You Swap Them?"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["If you use ",(0,a.jsxs)(n.strong,{children:[(0,a.jsx)(n.code,{children:"HMAC"})," for password hashing"]}),", it's too fast and vulnerable to brute-force."]}),"\n",(0,a.jsxs)(n.li,{children:["If you use ",(0,a.jsxs)(n.strong,{children:[(0,a.jsx)(n.code,{children:"scryptSync"})," for message authentication"]}),", it\u2019s too slow and inefficient."]}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"c-example-usage-in-nodejs",children:"C. Example usage in nodejs"}),"\n",(0,a.jsxs)(n.p,{children:["In node, we can import the ",(0,a.jsx)(n.code,{children:"createHmac"})," function:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const { createHmac } = require('crypto');\n"})}),"\n",(0,a.jsx)(n.p,{children:"Then we'll define a secret key, along with the message that we want to hash:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const { createHmac } = require('crypto');\n\nconst key = 'super-secret!'; // Store it some-place safe! Like a .env file\nconst message = 'boo!';\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Now we use the ",(0,a.jsx)(n.code,{children:"hmac"})," function to create a hash, similar to as we did with the ",(0,a.jsx)(n.code,{children:"hash"})," function before:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const { createHmac } = require('crypto');\n\nconst key = 'super-secret!';\nconst message = 'boo !';\n\nconst hash1 = createHmac('sha256', key).update(message).digest('hex');\nconst hash2 = createHmac('sha256', key).update(message).digest('hex');\n\nconsole.log(hash1);\nconsole.log(hash2);\nconsole.log(hash1 === hash2); // true\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The only difference we notice here is that we also provide this ",(0,a.jsx)(n.code,{children:"key"})," param to ",(0,a.jsx)(n.code,{children:"createHmac"}),". The important thing to notice here, is that we would only get the same hash, if the same message ",(0,a.jsx)(n.strong,{children:"AND"})," key/password combination is used. If we had the same message, but with a different key, we would get a different hash as a result."]}),"\n",(0,a.jsxs)(n.p,{children:["Here is a simple implementation of jwt-like, using ",(0,a.jsx)(n.code,{children:"hmac"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"import { createHmac } from 'node:crypto';\n\nfunction base64UrlEncode(buffer) {\n  return buffer.toString('base64url'); // Base64url encoding (removes padding and special chars)\n}\n\nfunction base64UrlDecode(base64url) {\n  return Buffer.from(base64url, 'base64url').toString();\n}\n\nfunction sign(payload, secret) {\n  const header = { alg: 'HS256', typ: 'JWT' };\n\n  // Convert header and payload to base64url\n  const encodedHeader = base64UrlEncode(Buffer.from(JSON.stringify(header)));\n  const encodedPayload = base64UrlEncode(Buffer.from(JSON.stringify(payload)));\n\n  // Create signature using HMAC-SHA256\n  const signature = createHmac('sha256', secret)\n    .update(`${encodedHeader}.${encodedPayload}`)\n    .digest('base64url');\n\n  // Return the full JWT-like token\n  return `${encodedHeader}.${encodedPayload}.${signature}`;\n}\n\nfunction verify(token, secret) {\n  const [encodedHeader, encodedPayload, receivedSignature] = token.split('.');\n\n  // Recompute the signature\n  const expectedSignature = createHmac('sha256', secret)\n    .update(`${encodedHeader}.${encodedPayload}`)\n    .digest('base64url');\n\n  // Compare signatures\n  if (receivedSignature === expectedSignature) {\n    return JSON.parse(base64UrlDecode(encodedPayload)); // Valid token, return decoded payload\n  } else {\n    throw new Error('Invalid signature');\n  }\n}\n\n// Example usage\nconst secret = 'super-secret-key';\nconst payload = { userId: 123, role: 'admin' };\n\n// Signing a token\nconst token = sign(payload, secret);\nconsole.log('Token:', token);\n\n// Verifying a token\ntry {\n  const decoded = verify(token, secret);\n  console.log('Decoded:', decoded);\n} catch (err) {\n  console.error(err.message);\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["That's pretty cool!",(0,a.jsx)(n.br,{}),"\n","But what happens when you want to completely scramble the text, and not just base64 it, and be able to talk to the other party secretly? You both need to share a secret key, to be able to read the original hidden message. That's where ",(0,a.jsx)(n.strong,{children:"encryption"})," comes in."]}),"\n",(0,a.jsx)(n.h3,{id:"--concept-4-symmetric-encryption",children:"- Concept 4: SYMMETRIC ENCRYPTION"}),"\n",(0,a.jsx)(n.h4,{id:"a-description-3",children:"A. Description"}),"\n",(0,a.jsxs)(n.p,{children:["What is encryption exactly?",(0,a.jsx)(n.br,{}),"\n","With encryption, we take a message, scramble up the bytes to make it unreadable, that's called the ",(0,a.jsx)(n.strong,{children:"Cyphertext"})," - an encrypted text transformed from plaintext using an encryption algorithm. Then we provide a key/password allowing somebody else to decrypt it."]}),"\n",(0,a.jsx)(n.p,{children:"It's also typically randomized, so that each time you encrypt, you'd get an entirely different encrypted output, even if the key and message are the same. The first encryption example we'll look at is the Symmetric one, which means that there's a shared password between the two parties. Both the sender and the receiver of the message need to have the exact same key."}),"\n",(0,a.jsx)(n.h4,{id:"b-example-usage-in-nodejs",children:"B. Example usage in nodejs"}),"\n",(0,a.jsx)(n.p,{children:"To implement this in node, we're going to import:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"createCipheriv"}),'\nfor when encrypting a message (btw, iv stands for "initial vector").']}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"randomBytes"}),"\nfor randomness at each encryption (the SALT)."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"createDecipheriv"}),"\nfor when decrypting a message."]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const { createCipheriv, randomBytes, createDecipheriv } = require('crypto');\n"})}),"\n",(0,a.jsx)(n.p,{children:"So, first we have the message itself, the one that we're trying to encrypt:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const { createCipheriv, randomBytes, createDecipheriv } = require('crypto');\n\nconst message = 'I like turtles';\n"})}),"\n",(0,a.jsxs)(n.p,{children:['Then we\'ll define "key" as ',(0,a.jsx)(n.strong,{children:"32 randomBytes"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const { createCipheriv, randomBytes, createDecipheriv } = require('crypto');\n\nconst message = 'I like turtles';\nconst key = randomBytes(32);\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Next we'll create the initial vector as ",(0,a.jsx)(n.strong,{children:"16 randomBytes"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const { createCipheriv, randomBytes, createDecipheriv } = require('crypto');\n\nconst message = 'I like turtles';\nconst key = randomBytes(32);\nconst iv = randomBytes(16);\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The iv will ",(0,a.jsx)(n.strong,{children:"randomize"})," the output when its encrypted, so that when identical sequence attacks occur, they will never produce the same cyphertext, making it more difficult for a hacker to break the encryption. Now, we can use these values to create a ",(0,a.jsx)(n.code,{children:"cipher"}),". Like a hash, it is dependent upon an algorithm, although encryption algorithms are inherently different than hashing algorithms (Advanced Encryption Standard - AES), so you'll notice an entirely different set of options here:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const { createCipheriv, randomBytes, createDecipheriv } = require('crypto');\n\nconst message = 'I like turtles';\nconst key = randomBytes(32);\nconst iv = randomBytes(16);\n\nconst cipher = createCipheriv('aes256', key, iv);\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Now, you can ",(0,a.jsx)(n.em,{children:"use"})," the ",(0,a.jsx)(n.code,{children:"cipher"})," to ",(0,a.jsx)(n.em,{children:"encrypt a message"})," by calling ",(0,a.jsx)(n.code,{children:"cypher.update"}),", or even multiple messages if you want to, then finish it off by calling ",(0,a.jsx)(n.code,{children:"cipher.final"}),", and ",(0,a.jsx)(n.em,{children:"add that value to the end of the encrypted message"}),", and finalize the ",(0,a.jsx)(n.code,{children:"cipher"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const { createCipheriv, randomBytes, createDecipheriv } = require('crypto');\n\nconst message = 'I like turtles';\nconst key = randomBytes(32);\nconst iv = randomBytes(16);\n\nconst cipher = createCipheriv('aes256', key, iv);\n\n// Encrypt:\nconst encryptedMessage = cipher.update(message, 'utf8', 'hex') + cipher.final('hex');\n"})}),"\n",(0,a.jsxs)(n.p,{children:["At this point, the ",(0,a.jsx)(n.code,{children:"cipher"})," ",(0,a.jsx)(n.em,{children:"can no longer be used to encrypt data"}),"!\nNow, to decipher it, create a ",(0,a.jsx)(n.code,{children:"decipher"})," object using ",(0,a.jsx)(n.code,{children:"createDecipheriv"}),", with the same key and initial vector (iv). Use the same basic pattern of ",(0,a.jsx)(n.code,{children:"update"})," and ",(0,a.jsx)(n.code,{children:"final"})," to convert the encrypted message back into plain text:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const { createCipheriv, randomBytes, createDecipheriv } = require('crypto');\n\nconst message = 'I like turtles';\nconst key = randomBytes(32);\nconst iv = randomBytes(16);\n\nconst cipher = createCipheriv('aes256', key, iv);\n\n// Encrypt:\nconst encryptedMessage = cipher.update(message, 'utf8', 'hex') + cipher.final('hex');\n\nconst decipher = createDecipheriv('aes256', key, iv);\n\n// Decrypt:\nconst decryptedMessage = decipher.update(encryptedMessage, 'hex', 'utf-8') + decipher.final('utf8');\n"})}),"\n",(0,a.jsx)(n.p,{children:"And that's how you encrypt and decrypt a message in node."}),"\n",(0,a.jsx)(n.h3,{id:"--concept-5-keypairs",children:"- Concept 5: KEYPAIRS"}),"\n",(0,a.jsx)(n.p,{children:"There's a big limitation to symmetric encryption, and that's the fact that both the sender and receiver of the message, need to share a password. It's just not practical for two different parties to agree upon a shared password."}),"\n",(0,a.jsxs)(n.p,{children:["Once again, math comes to the rescue, and this time in the form of a public-key crypto-system. Instead of one key, it uses two keys that are mathematically linked.\nA ",(0,a.jsx)(n.strong,{children:"public key"}),", and a ",(0,a.jsx)(n.strong,{children:"private key"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["key can be shared with other people. In node, we can generate a private & public key pair using the ",(0,a.jsx)(n.code,{children:"generateKeyPair"})," function."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const { generateKeyPairSync } = require('crypto');\n"})}),"\n",(0,a.jsx)(n.p,{children:"The first argument is the crypto-system you wanna use:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const { generateKeyPairSync } = require('crypto');\n\nconst { privateKey, publicKey } = generateKeyPairSync('rsa');\n"})}),"\n",(0,a.jsxs)(n.p,{children:["which in our case will be 'rsa', and you're not gonna believe what the initials stand for:",(0,a.jsx)(n.br,{}),"\n",(0,a.jsx)(n.strong,{children:"rsa = Rivest + Shamir + Adleman"}),(0,a.jsx)(n.br,{}),"\n","Fucking names! Adi Shamir is an Israeli Jewish, born in 1952, B.sc. in computer science and Mathematics.",(0,a.jsx)(n.br,{}),"\n","Anyways,",(0,a.jsx)(n.br,{}),"\n","Within the ",(0,a.jsx)(n.em,{children:"options"})," of the function we can define a bunch of settings, like the length of the key in bits, and also the encoding of the public & private keys. We'll go with the recommended settings here, and have it return a format of 'pem' (which stands for Privacy Enhanced Mail) to show us the keys in base64 format:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const { generateKeyPairSync } = require('crypto');\n\nconst { privateKey, publicKey } = generateKeyPairSync('rsa', {\n  modulusLength: 2048, // the length of your key in bits,\n  publicKeyEncoding: {\n    type: 'spki', // recommended to be 'spki' by the Node.js docs\n    format: 'pem',\n  },\n  privateKeyEncoding: {\n    type: 'pkcs8', // recommended to be 'pkcs8' by the Node.js docs\n    format: 'pem',\n    // cipher: 'aes-256-cbc',\n    // passpharse: 'top secret',\n  },\n});\n\nconsole.log(publicKey);\nconsole.log(privateKey);\n\nmodule.exports = { privateKey, publicKey }\n"})}),"\n",(0,a.jsx)(n.p,{children:"You could also add a passphrase to your private key for added security (the cipher & passphrase options which are commented out above)."}),"\n",(0,a.jsx)(n.h3,{id:"--concept-6-asymmetric-encryption",children:"- Concept 6: ASYMMETRIC ENCRYPTION"}),"\n",(0,a.jsxs)(n.p,{children:["And that brings us to asymmetric encryption!",(0,a.jsx)(n.br,{}),"\n","You use asymmetric encryption any time you go to a website using an https. The browser will automatically find a public key of an SSL certificate installed on the website."]}),"\n",(0,a.jsx)(n.p,{children:"In git, when pushing to a git repository, your private key and the other party's public key are used to encrypt the data which you send over. That prevents hackers from gaining anything useful from it in transit."}),"\n",(0,a.jsx)(n.p,{children:"On websites, HTTPS uses asymmetric encryption to establish the identity of the parties and to exchange a symmetric key. Then symmetric encryption is used since it's faster."}),"\n",(0,a.jsxs)(n.p,{children:["The implementation in node is very simple. We import ",(0,a.jsx)(n.code,{children:"publicEncrypt"}),", and ",(0,a.jsx)(n.code,{children:"privateDecrypt"})," from node crypto, along with the ",(0,a.jsx)(n.em,{children:"public & private keys"})," that we generated previously:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const { privateEncrypt, publicDecrypt } = require('crypto');\nconst { publicKey, privateKey } = require('./keypair');\n"})}),"\n",(0,a.jsxs)(n.p,{children:["we can then encrypt a message or put it in a mailbox by combining the ",(0,a.jsx)(n.strong,{children:"publicKey"})," with the ",(0,a.jsx)(n.strong,{children:"message"})," itself."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// The Frontend:\nconst { publicDecrypt } = require('crypto');\nconst { publicKey } = require('./keypair'); // got back from the server! Like an SSL Cert!\n\nconst message = 'the british are coming!';\n\nconst encryptedData = publicEncrypt(publicKey, Buffer.from(message));\n\nconsole.log(encryptedData.toString('hex'));\n// Send the encrypted message to the server!\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Notice that we're not providing the message in its original format, rather use a buffer format. It needs to be that way. The ",(0,a.jsx)(n.code,{children:"publicEncrypt"})," function will ",(0,a.jsx)(n.em,{children:"encrypt the message"})," so that only the owner of the mailbox could read it. At some point in the future, the recipient may want to read the original message, which can be done by calling ",(0,a.jsx)(n.code,{children:"privateDecrypt"}),", along with the ",(0,a.jsx)(n.em,{children:"privateKey"})," and the ",(0,a.jsx)(n.code,{children:"encryptedData"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// The Backend:\nconst { privateDecrypt } = require('crypto');\nconst { privateKey } = require('./keypair');\n\nconst encryptedData = got it from the frontend\u2026.\n\nconst decryptedData = privateDecrypt(privateKey, encryptedData);\n\nconsole.log(decryptedData.toString('utf-8'));\n"})}),"\n",(0,a.jsx)(n.p,{children:'This is the "unlock mailbox" operation.'}),"\n",(0,a.jsx)(n.h3,{id:"--concept-7-signing",children:"- Concept 7: SIGNING"}),"\n",(0,a.jsx)(n.p,{children:"Now, encryption is fun, but in many cases you don't actually need to encrypt data, but rather validate that it came from a trusted party. That's where signing comes in."}),"\n",(0,a.jsx)(n.p,{children:"What is a digital signature?"}),"\n",(0,a.jsx)(n.p,{children:"Let's imagine you're expecting a letter in the mail, with some sensitive information. You need to be able to trust that that letter came from the right person. So you require them to sign it with blood. It also can't be tempered with, so they put a special seal on it..."}),"\n",(0,a.jsx)(n.p,{children:"@@@@@@\nenvelope signing image\n@@@@@@"}),"\n",(0,a.jsxs)(n.p,{children:["...that if broken, will indicate that it's been tempered with.",(0,a.jsx)(n.br,{}),"\n","Digital signatures work in the same basic way."]}),"\n",(0,a.jsx)(n.p,{children:"@@@@@@\nblood image\n@@@@@@"}),"\n",(0,a.jsx)(n.p,{children:"The sender of the message will use their private key to sign a hash of the original message. The private key guarantees authenticity, like blood, and the hash guarantees that the message can't be tempered with, because it would produce an entirely different signature. The recipient can then use the publicKey to validate the authenticity of the message."}),"\n",(0,a.jsx)(n.p,{children:"@@@@@@\nverify image\n@@@@@@"}),"\n",(0,a.jsx)(n.p,{children:"In node, we can create a signature with the createSign function:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const { createSign } = require('crypto');\n"})}),"\n",(0,a.jsx)(n.p,{children:"then pass in the algorithm that uses the rsa crypto-system sha256 for hashing:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const { createSign } = require('crypto');\n\n// SIGN:\nconst signer = createSign('rsa-sha256');\n"})}),"\n",(0,a.jsx)(n.p,{children:"We then update it with the message we want to sign, and create the actual signature with the private key."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const { createSign } = require('crypto');\nconst { privateKey } = require('./keypair');\n\n// SIGN:\nconst signer = createSign('rsa-sha256');\nsigner.update(message);\nconst signature = signer.sign(privateKey, 'hex');\n"})}),"\n",(0,a.jsx)(n.p,{children:'We can now attach the signature to the original message, and send it to someone. The message itself can remain un-encrypted, because what this use case is saying: "all I care about is you being who you say you are". When the other side gets it, he can create a verifier, update the original message, and then verify the signature with the sender\'s public key:'}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const { createSign, createVerify } = require('crypto');\nconst { privateKey, publicKey } = require('./keypair');\n\n// SIGN:\nconst signer = createSign('rsa-sha256');\nsigner.update(message);\nconst signature = signer.sign(privateKey, 'hex');\n\n// VERIFY:\nconst verifier = createVerify('rsa-sha256');\nverifier.update(message);\nconst isVerified = verifier.verify(publicKey, signature, 'hex');\n"})}),"\n",(0,a.jsx)(n.p,{children:"If the signature was forged, or the message got changed, the verifier will fail. And that gives us 7 cryptography concepts that every developer should know:"}),"\n",(0,a.jsx)(n.p,{children:"@@@@@@\nall concepts image\n@@@@@@"}),"\n",(0,a.jsx)(n.h2,{id:"3-summary",children:"3. Summary"}),"\n",(0,a.jsx)(n.h3,{id:"--a-create-hash",children:"- A. Create Hash"}),"\n",(0,a.jsx)(n.p,{children:"Command structure:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"function hash(value){\n  return createHash('sha256').update(value).digest('hex');\n}\n\nconst password = 'hi-mom!';\nconst hash1 = hash(password);\n\nconsole.log(hash1);\n// would print: 7a5d84e61a2234b450185fde58c237bb13e93d93d90f669b114d\n\n// compare two hashed passwords:\nconst password2 = 'hi-mom!';\nconst hash2 = hash(password);\nconst isMatch = hash1 === hash2;\nconsole.log(isMatch); // would print out: true\n"})}),"\n",(0,a.jsx)(n.h4,{id:"-algorithm",children:"\u2022 Algorithm:"}),"\n",(0,a.jsx)(n.p,{children:"The algorithm is dependent on the available algorithms supported by the version of OpenSSL on the platform. Examples are 'sha256', 'sha512', etc. On recent releases of OpenSSL, openssl list -digest-algorithms will display the available digest algorithms."}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"sha256"}),"\n",(0,a.jsx)(n.li,{children:"sha512"}),"\n",(0,a.jsx)(n.li,{children:"md5"}),"\n",(0,a.jsx)(n.li,{children:"argon2 (not built-in to node's crypto)"}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"-encoding",children:"\u2022 Encoding:"}),"\n",(0,a.jsx)(n.p,{children:"Here is the list of all encoding options that digest accepts:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"hex (what we will use)"}),"\n",(0,a.jsx)(n.li,{children:"base64 (an option you'll commonly see)"}),"\n",(0,a.jsx)(n.li,{children:"utf8 (utf-8 is an alias)"}),"\n",(0,a.jsx)(n.li,{children:"utf16le (utf-16le is an alias)"}),"\n",(0,a.jsx)(n.li,{children:"latin1"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"--b-create-salt",children:"- B. Create Salt"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const { scryptSync, randomBytes, timingSafeEqual } = require('crypto');\n\nasync function signUp( email, password ){\n  const salt = randomBytes(16).toString('hex');\n  const hashedPassword = scryptSync(password, salt, 64).toString('hex');\n\n  const user = { email, hashedPassword, salt };\n  const data = await Users.register(user);\n\n  return data;\n}\n\nasync function login(email,password){\n  const user = await Users.findUserByEmail(email);\n  const { salt, hashedPassword } = user;\n\n  const rawHashedPasswordBuffer = scryptSync(rawPassword, salt, 64);\n  const hashedPasswordBuffer = Buffer.from(hashedPassword, 'hex');\n  const match = timingSafeEqual(rawHashedPasswordBuffer, hashedPasswordBuffer);\n\n  return match ? 'login success!' : 'login failed...';\n}\n"})})]})}function l(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},7010:(e,n,s)=>{s.d(n,{R:()=>i,x:()=>c});var t=s(758);const a={},r=t.createContext(a);function i(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);