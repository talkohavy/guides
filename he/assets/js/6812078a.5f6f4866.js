"use strict";(self.webpackChunkdocusaurus_guides=self.webpackChunkdocusaurus_guides||[]).push([[130],{8646:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>i,metadata:()=>l,toc:()=>o});const l=JSON.parse('{"id":"programming/devops/helm","title":"Guide For Helm","description":"1. Helm Daily Workflow","source":"@site/docs/programming/devops/helm.md","sourceDirName":"programming/devops","slug":"/programming/devops/helm","permalink":"/guides/he/docs/programming/devops/helm","draft":false,"unlisted":false,"editUrl":"https://github.com/talkohavy/guides/docs/programming/devops/helm.md","tags":[],"version":"current","frontMatter":{},"sidebar":"mySidebar","previous":{"title":"- Kubernetes","permalink":"/guides/he/docs/programming/devops/kubernetes"},"next":{"title":"- Design Patterns","permalink":"/guides/he/docs/programming/design-patterns"}}');var r=n(6070),t=n(7010);const i={},a="Guide For Helm",c={},o=[{value:"<strong>1. Helm Daily Workflow</strong>",id:"1-helm-daily-workflow",level:2},{value:"- A. list all your charts",id:"--a-list-all-your-charts",level:3},{value:"- B. Delete a deployment + service",id:"--b-delete-a-deployment--service",level:3},{value:"- C. Create a new chart-template with deployment+service for an app",id:"--c-create-a-new-chart-template-with-deploymentservice-for-an-app",level:3},{value:"- D. Provision a deployment+service for the first time",id:"--d-provision-a-deploymentservice-for-the-first-time",level:3},{value:"- E. Keep track of an installation progress",id:"--e-keep-track-of-an-installation-progress",level:3},{value:"- F. Upgrade (update) a chart&#39;s revision",id:"--f-upgrade-update-a-charts-revision",level:3},{value:"- G. Abort unsuccessful upgrade of a chart",id:"--g-abort-unsuccessful-upgrade-of-a-chart",level:3},{value:"- H. Decrypt a helm Secret",id:"--h-decrypt-a-helm-secret",level:3},{value:"<strong>2. Helm Commands</strong>",id:"2-helm-commands",level:2},{value:"- Command 1: helm ls",id:"--command-1-helm-ls",level:3},{value:"- Command 2: helm create",id:"--command-2-helm-create",level:3},{value:"- Command 3: helm uninstall",id:"--command-3-helm-uninstall",level:3},{value:"The <code>--keep-history</code> flag",id:"the---keep-history-flag",level:4},{value:"- Command 4: helm install",id:"--command-4-helm-install",level:3},{value:"- Command 5: helm upgrade",id:"--command-5-helm-upgrade",level:3},{value:"- A. The <code>CHART</code> argument:",id:"--a-the-chart-argument",level:4},{value:"- B. The <code>--values</code> flag:",id:"--b-the---values-flag",level:4},{value:"- C. The <code>--reuse-values</code> flag:",id:"--c-the---reuse-values-flag",level:4},{value:"- D. The <code>--dry-run</code> flag",id:"--d-the---dry-run-flag",level:4},{value:"- Command 6: helm status",id:"--command-6-helm-status",level:3},{value:"- Command 7: helm history",id:"--command-7-helm-history",level:3},{value:"- Command 8: helm rollback",id:"--command-8-helm-rollback",level:3},{value:"- Command 9: helm template",id:"--command-9-helm-template",level:3},{value:"- Command 10: helm package",id:"--command-10-helm-package",level:3},{value:"- Command 11: helm get values",id:"--command-11-helm-get-values",level:3},{value:"- Command 12: helm get notes",id:"--command-12-helm-get-notes",level:3},{value:"3. Helm Architecture",id:"3-helm-architecture",level:2},{value:"- Concept 1: Chart",id:"--concept-1-chart",level:3},{value:"- Concept 2: Repository",id:"--concept-2-repository",level:3},{value:"- Concept 3: Release",id:"--concept-3-release",level:3},{value:"- Concept 4: Tiller",id:"--concept-4-tiller",level:3},{value:"<strong>4. What is helm?</strong>",id:"4-what-is-helm",level:2},{value:"<strong>5. Why Helm?</strong>",id:"5-why-helm",level:2},{value:"- Intelligent Deployments",id:"--intelligent-deployments",level:3},{value:"- Lifecycle Hooks",id:"--lifecycle-hooks",level:3},{value:"- Security",id:"--security",level:3},{value:"<strong>6. How does helm work?</strong>",id:"6-how-does-helm-work",level:2},{value:"- Step 1: Chart resolution",id:"--step-1-chart-resolution",level:3},{value:"- Step 2: Merge Values",id:"--step-2-merge-values",level:3},{value:"- Step 3: Template Rendering",id:"--step-3-template-rendering",level:3},{value:"- Step 4: Install Release to Kubernetes",id:"--step-4-install-release-to-kubernetes",level:3},{value:"- Step 5: Create Release Record (in Cluster)",id:"--step-5-create-release-record-in-cluster",level:3},{value:"- Step 6: Run Hooks (if any exists)",id:"--step-6-run-hooks-if-any-exists",level:3},{value:"- Step 7: Show Output",id:"--step-7-show-output",level:3}];function h(e){const s={br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.header,{children:(0,r.jsx)(s.h1,{id:"guide-for-helm",children:"Guide For Helm"})}),"\n",(0,r.jsx)(s.h2,{id:"1-helm-daily-workflow",children:(0,r.jsx)(s.strong,{children:"1. Helm Daily Workflow"})}),"\n",(0,r.jsx)(s.h3,{id:"--a-list-all-your-charts",children:"- A. list all your charts"}),"\n",(0,r.jsx)(s.p,{children:"You start out by listing all your charts with:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-bash",children:"helm ls\n"})}),"\n",(0,r.jsx)(s.h3,{id:"--b-delete-a-deployment--service",children:"- B. Delete a deployment + service"}),"\n",(0,r.jsx)(s.p,{children:"You can uninstall any of the listed charts using:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-bash",children:"helm uninstall CHART_NAME\n"})}),"\n",(0,r.jsx)(s.h3,{id:"--c-create-a-new-chart-template-with-deploymentservice-for-an-app",children:"- C. Create a new chart-template with deployment+service for an app"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-bash",children:"helm create CHART_NAME\n"})}),"\n",(0,r.jsx)(s.h3,{id:"--d-provision-a-deploymentservice-for-the-first-time",children:"- D. Provision a deployment+service for the first time"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-bash",children:"helm install CHART_NAME . --values values.yaml --debug --verify -n NAMESPACE --create-namespace\n"})}),"\n",(0,r.jsx)(s.p,{children:"Or by using force:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-bash",children:"helm install CHART_NAME . --values values.yaml --debug --verify -n NAMESPACE --create-namespace --force\n"})}),"\n",(0,r.jsx)(s.h3,{id:"--e-keep-track-of-an-installation-progress",children:"- E. Keep track of an installation progress"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-bash",children:"helm status CHART_NAME -n NAMESPACE\n"})}),"\n",(0,r.jsx)(s.h3,{id:"--f-upgrade-update-a-charts-revision",children:"- F. Upgrade (update) a chart's revision"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-bash",children:"helm upgrade CHART_NAME . --install --values values.yaml -n NAMESPACE --create-namespace\n"})}),"\n",(0,r.jsxs)(s.p,{children:["Notice the ",(0,r.jsx)(s.code,{children:"--install"})," flag, which makes ",(0,r.jsx)(s.code,{children:"helm install"})," command redundant, since you now no longer need to decide between ",(0,r.jsx)(s.code,{children:"helm install"})," & ",(0,r.jsx)(s.code,{children:"helm upgrade"}),", just always use ",(0,r.jsx)(s.code,{children:"helm upgrade"}),"."]}),"\n",(0,r.jsx)(s.h3,{id:"--g-abort-unsuccessful-upgrade-of-a-chart",children:"- G. Abort unsuccessful upgrade of a chart"}),"\n",(0,r.jsxs)(s.p,{children:["When an upgrade is unsuccessful, and the ",(0,r.jsx)(s.code,{children:"rollingUpdate"})," seems to fail, you might need to abort the upgrade. Here's how you do it:"]}),"\n",(0,r.jsxs)(s.p,{children:["If you know the ",(0,r.jsx)(s.strong,{children:"revision number"})," of the current successful chart, simply ",(0,r.jsx)(s.strong,{children:"rollback"})," to it:"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-bash",children:"helm rollback CHART_NAME REVISION_NUMBER -n NAMESPACE\n"})}),"\n",(0,r.jsxs)(s.p,{children:["If you need to check the current revision number, you can use the ",(0,r.jsx)(s.strong,{children:"history"})," command:"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-bash",children:"helm history backend -n NAMESPACE\n"})}),"\n",(0,r.jsx)(s.h3,{id:"--h-decrypt-a-helm-secret",children:"- H. Decrypt a helm Secret"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-bash",children:"kubectl get secret sh.helm.release.v1.mysql-db-service.v1 -o jsonpath=\"{ .data.release }\" | base64 -d | base64 -d | gunzip -c | jq '.chart.templates[].data' | tr -d '\"' | base64 -d > hello.txt\n"})}),"\n",(0,r.jsx)(s.hr,{}),"\n",(0,r.jsx)(s.h2,{id:"2-helm-commands",children:(0,r.jsx)(s.strong,{children:"2. Helm Commands"})}),"\n",(0,r.jsx)(s.h3,{id:"--command-1-helm-ls",children:"- Command 1: helm ls"}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"- The command:"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-bash",children:"helm ls -n NAMESPACE\n"})}),"\n",(0,r.jsx)(s.p,{children:"Or..."}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-bash",children:"helm list -n NAMESPACE\n"})}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"- Description:"})}),"\n",(0,r.jsxs)(s.p,{children:["This command ",(0,r.jsx)(s.strong,{children:"lists all the releases"})," for a specified namespace (uses current namespace context if namespace not specified)."]}),"\n",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(s.h3,{id:"--command-2-helm-create",children:"- Command 2: helm create"}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"- The command:"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-bash",children:"helm create CHART_NAME\n"})}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"- Description:"})}),"\n",(0,r.jsxs)(s.p,{children:["create a new ",(0,r.jsx)(s.strong,{children:"chart"})," with the given name."]}),"\n",(0,r.jsxs)(s.p,{children:["This command creates a chart directory along with the common files and directories used in a chart. ",(0,r.jsx)(s.code,{children:"helm create"})," takes a ",(0,r.jsx)(s.em,{children:"path"})," for an argument. If directories in the given path do not exist, Helm will attempt to create them as it goes. If the given destination exists and there are files in that directory, conflicting files will be overwritten, but other files will be left alone."]}),"\n",(0,r.jsxs)(s.p,{children:["For example, ",(0,r.jsx)(s.code,{children:"helm create foo"})," will create a directory structure that looks something like this:"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{children:"foo/\n\u251c\u2500\u2500 .helmignore   # Contains patterns to ignore when packaging Helm charts.\n\u251c\u2500\u2500 Chart.yaml    # Information about your chart\n\u251c\u2500\u2500 values.yaml   # The default values for your templates\n\u251c\u2500\u2500 charts/       # Charts that this chart depends on\n\u2514\u2500\u2500 templates/    # The template files\n    \u2514\u2500\u2500 tests/    # The test files\n"})}),"\n",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(s.h3,{id:"--command-3-helm-uninstall",children:"- Command 3: helm uninstall"}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"- The command:"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-bash",children:"helm uninstall RELEASE_NAME -n NAMESPACE\n"})}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"- Description:"})}),"\n",(0,r.jsx)(s.p,{children:"Uninstall a release."}),"\n",(0,r.jsx)(s.p,{children:"This command takes a release name and uninstalls the release. It removes all of the resources associated with the last release of the chart as well as the release history, freeing it up for future use."}),"\n",(0,r.jsxs)(s.h4,{id:"the---keep-history-flag",children:["The ",(0,r.jsx)(s.code,{children:"--keep-history"})," flag"]}),"\n",(0,r.jsxs)(s.p,{children:["In the past, this was the default. Now, running ",(0,r.jsx)(s.code,{children:"uninstall"})," deletes everything. If you want to uninstall a chart, but keep its history, use this flag."]}),"\n",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(s.h3,{id:"--command-4-helm-install",children:"- Command 4: helm install"}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"- The command:"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-bash",children:"helm install chart_nickname path/to/root --values path/to/values.yaml -n NAMESPACE --debug\n"})}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"- Description:"})}),"\n",(0,r.jsxs)(s.p,{children:["This command installs a ",(0,r.jsx)(s.strong,{children:"chart"})," archive, and gives it a ",(0,r.jsx)(s.strong,{children:"nickname"})," which you provide."]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["The ",(0,r.jsx)(s.code,{children:"-f"}),", ",(0,r.jsx)(s.code,{children:"--values"})," flags specify values in a YAML file or a URL (can specify multiple)."]}),"\n",(0,r.jsxs)(s.li,{children:["The ",(0,r.jsx)(s.code,{children:"--debug"})," flag enables verbose output."]}),"\n",(0,r.jsxs)(s.li,{children:["The ",(0,r.jsx)(s.code,{children:"--dry-run"})," flag simulates an install. ",(0,r.jsx)(s.code,{children:"--dry-run"})," is similar to ",(0,r.jsx)(s.code,{children:"--dry-run=client"}),", which means that it will not attempt cluster connections, while setting ",(0,r.jsx)(s.code,{children:"--dry-run=server"})," attempts to connect the cluster."]}),"\n",(0,r.jsxs)(s.li,{children:["The ",(0,r.jsx)(s.code,{children:"--force"})," flag forces resource updates through a replacement strategy."]}),"\n",(0,r.jsxs)(s.li,{children:["The ",(0,r.jsx)(s.code,{children:"--verify"})," flag verifies the package before using it."]}),"\n",(0,r.jsxs)(s.li,{children:["The ",(0,r.jsx)(s.code,{children:"--wait"})," flag will wait until all Pods, PVCs, Services, and minimum number of Pods of a Deployment, StatefulSet, or ReplicaSet are in a ",(0,r.jsx)(s.strong,{children:"ready state"})," before marking the release as ",(0,r.jsx)(s.strong,{children:"successful"}),". It will wait for as long as ",(0,r.jsx)(s.code,{children:"--timeout"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(s.p,{children:["The install argument must be a ",(0,r.jsx)(s.strong,{children:"chart reference"}),", a ",(0,r.jsx)(s.strong,{children:"path to a packaged chart"}),", a ",(0,r.jsx)(s.strong,{children:"path to an unpacked chart directory"}),", or a ",(0,r.jsx)(s.strong,{children:"URL"}),"."]}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"When using a path to an unpacked chart directory:"})}),"\n",(0,r.jsxs)(s.ol,{children:["\n",(0,r.jsxs)(s.li,{children:["The ",(0,r.jsx)(s.code,{children:"root"})," directory must include a ",(0,r.jsx)(s.code,{children:"Chart.yaml"})," file."]}),"\n",(0,r.jsxs)(s.li,{children:["Inside that ",(0,r.jsx)(s.code,{children:"Chart.yaml"})," file, you ",(0,r.jsx)(s.strong,{children:"MUST"})," specify:","\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["a ",(0,r.jsx)(s.code,{children:"name"})," field"]}),"\n",(0,r.jsxs)(s.li,{children:["an ",(0,r.jsx)(s.code,{children:"version"})," field"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["The ",(0,r.jsx)(s.code,{children:"root"})," directory needs to include a folder named ",(0,r.jsx)(s.code,{children:"templates"}),". This isn't required per-say, since the operation won't fail if one does not exist. However, even though running ",(0,r.jsx)(s.code,{children:"helm ls"})," would show that a chart has been created, nothing would actually be deployed to your cluster! So while technically it is not required, it ",(0,r.jsx)(s.em,{children:"is"})," sort of required."]}),"\n",(0,r.jsxs)(s.li,{children:["The ",(0,r.jsx)(s.code,{children:"templates"})," folder is where you include all your yaml files, whether it be a config for a ",(0,r.jsx)(s.strong,{children:"deployment"}),", or a ",(0,r.jsx)(s.strong,{children:"service"}),", or a ",(0,r.jsx)(s.strong,{children:"configmap"}),". The names of the files don't matter, since kubernetes/helm looks inside the file and derives what resource it is based on its ",(0,r.jsx)(s.code,{children:"Kind"}),"."]}),"\n",(0,r.jsxs)(s.li,{children:["The root folder may include a ",(0,r.jsx)(s.code,{children:"values.yaml"})," file, to which you would point when invoking the ",(0,r.jsx)(s.code,{children:"install"})," command, along with the flag of ",(0,r.jsx)(s.code,{children:"--values"}),"."]}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Another way to set values"})}),"\n",(0,r.jsx)(s.p,{children:"To override values in a chart, use either the '--values' flag and pass in a file or use the '--set' flag and pass configuration from the command line, to force a string value use '--set-string'. You can use '--set-file' to set individual values from a file when the value itself is too long for the command line or is dynamically generated. You can also use '--set-json' to set json values (scalars/objects/arrays) from the command line."}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"- Example Usage:"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-bash",children:"helm install user ./user --values ./user/values.yaml -n NAMESPACE --create-namespace\n"})}),"\n",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(s.h3,{id:"--command-5-helm-upgrade",children:"- Command 5: helm upgrade"}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"- The command:"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-bash",children:"helm upgrade RELEASE CHART --values path/to/values.yaml -n NAMESPACE\n"})}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"- Description:"})}),"\n",(0,r.jsx)(s.p,{children:"This command upgrades a release to a new version of a chart."}),"\n",(0,r.jsxs)(s.p,{children:["The upgrade arguments must be a ",(0,r.jsx)(s.code,{children:"release"})," and ",(0,r.jsx)(s.code,{children:"chart"}),"."]}),"\n",(0,r.jsxs)(s.h4,{id:"--a-the-chart-argument",children:["- A. The ",(0,r.jsx)(s.code,{children:"CHART"})," argument:"]}),"\n",(0,r.jsxs)(s.p,{children:["The chart argument can be either: a path to a chart directory, a packaged chart, a fully qualified URL, or a chart ",(0,r.jsx)(s.em,{children:"reference"})," ('example/mariadb'). For chart ",(0,r.jsx)(s.em,{children:"references"}),", the ",(0,r.jsx)(s.strong,{children:"latest"})," version will be specified unless the '--version' flag is set."]}),"\n",(0,r.jsxs)(s.h4,{id:"--b-the---values-flag",children:["- B. The ",(0,r.jsx)(s.code,{children:"--values"})," flag:"]}),"\n",(0,r.jsxs)(s.p,{children:["To override values in a chart, use either the ",(0,r.jsx)(s.code,{children:"--values"})," flag and pass in a file or use the ",(0,r.jsx)(s.code,{children:"--set"})," flag and pass configuration from the command line, to force string values, use ",(0,r.jsx)(s.code,{children:"--set-string"}),". You can use ",(0,r.jsx)(s.code,{children:"--set-file"})," to set individual values from a file when the value itself is too long for the command line or is dynamically generated. You can also use ",(0,r.jsx)(s.code,{children:"--set-json"})," to set json values (scalars/objects/arrays) from the command line.",(0,r.jsx)(s.br,{}),"\n","You can specify the ",(0,r.jsx)(s.code,{children:"--values"}),"/",(0,r.jsx)(s.code,{children:"-f"})," flag multiple times. ",(0,r.jsx)(s.strong,{children:"Priority will be given to the last values.yaml specified"})," (the one on the most-right). If both ",(0,r.jsx)(s.code,{children:"values.yaml"})," and ",(0,r.jsx)(s.code,{children:"values-override.yaml"})," contained a key called ",(0,r.jsx)(s.code,{children:"Test"}),", the value set in ",(0,r.jsx)(s.code,{children:"values-override.yaml"})," would win."]}),"\n",(0,r.jsxs)(s.h4,{id:"--c-the---reuse-values-flag",children:["- C. The ",(0,r.jsx)(s.code,{children:"--reuse-values"})," flag:"]}),"\n",(0,r.jsxs)(s.p,{children:["Re-use values from last release. When upgrading, reuse the last release's values, and merge in any overrides. If ",(0,r.jsx)(s.code,{children:"--reset-values"})," is specified, this flag ignored.",(0,r.jsx)(s.br,{}),"\n","Imagine this situation: You initially install a chart with..."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-bash",children:"helm install my-release my-chart --set image.tag=1.0.0 --set replicas=3\n"})}),"\n",(0,r.jsx)(s.p,{children:"Later, you want to only change the image tag:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-bash",children:"helm upgrade my-release my-chart --set image.tag=2.0.0\n"})}),"\n",(0,r.jsxs)(s.p,{children:["If you don't use ",(0,r.jsx)(s.code,{children:"--reuse-values"}),", then:"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"replicas"})," will reset to the chart default (e.g., let's say 1),"]}),"\n",(0,r.jsxs)(s.li,{children:["Because you're only passing ",(0,r.jsx)(s.code,{children:"image.tag"}),', Helm thinks "oh, I should use only these values."']}),"\n"]}),"\n",(0,r.jsxs)(s.h4,{id:"--d-the---dry-run-flag",children:["- D. The ",(0,r.jsx)(s.code,{children:"--dry-run"})," flag"]}),"\n",(0,r.jsxs)(s.p,{children:["The ",(0,r.jsx)(s.code,{children:"--dry-run"})," mode would only go through the first few steps of ",(0,r.jsx)(s.code,{children:"helm install"}),", meaning it will load the charts, merge values from ",(0,r.jsx)(s.code,{children:"values.yaml"}),", render the required k8s templates, but it will not submit them to the k8s API server, and thus, will not get created."]}),"\n",(0,r.jsxs)(s.p,{children:["To sum up, the ",(0,r.jsx)(s.code,{children:"--dry-run"})," flag will output all generated ",(0,r.jsx)(s.code,{children:"chart manifests"}),", including ",(0,r.jsx)(s.code,{children:"Secrets"})," which can contain sensitive values. You can hide Kubernetes Secrets using the ",(0,r.jsx)(s.code,{children:"--hide-secret"})," flag. Please carefully consider how and when these flags are used."]}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"- Usage Example:"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-bash",children:"helm upgrade --install users-service ./toolbox/deploy/charts/users-service --values ./toolbox/deploy/charts/users-service/values.yaml -n application\n"})}),"\n",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(s.h3,{id:"--command-6-helm-status",children:"- Command 6: helm status"}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"- The command: status"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-bash",children:"helm status CHART_NAME -n NAMESPACE\n"})}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"- Description:"})}),"\n",(0,r.jsxs)(s.p,{children:["The ",(0,r.jsx)(s.code,{children:"helm status"})," commands is useful when using the ",(0,r.jsx)(s.code,{children:"helm install"})," command. When running ",(0,r.jsx)(s.code,{children:"helm install"}),", Helm does not wait until all of the resources are running before it exits. Many charts require Docker images that are over 600MB in size, and may take a long time to install into the cluster. So, to keep track of a release's state, or to re-read configuration information, you can use ",(0,r.jsx)(s.code,{children:"helm status"}),"."]}),"\n",(0,r.jsx)(s.p,{children:"Display the status of the named release."}),"\n",(0,r.jsx)(s.p,{children:"This command shows the status of a named release. The status consists of:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsx)(s.p,{children:"last deployment time"}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsx)(s.p,{children:"k8s namespace in which the release lives"}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsx)(s.p,{children:"state of the release (can be: unknown, deployed, uninstalled, superseded, failed, uninstalling, pending-install, pending-upgrade or pending-rollback)"}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsx)(s.p,{children:"revision of the release"}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsx)(s.p,{children:"description of the release (can be completion message or error message, need to enable --show-desc)"}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsx)(s.p,{children:"list of resources that this release consists of (need to enable --show-resources)"}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsx)(s.p,{children:"details on last test suite run, if applicable"}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsx)(s.p,{children:"additional notes provided by the chart"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(s.h3,{id:"--command-7-helm-history",children:"- Command 7: helm history"}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"- The command:"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-bash",children:"helm history RELEASE_NAME -n NAMESPACE\n"})}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"- Description:"})}),"\n",(0,r.jsx)(s.p,{children:"Fetch a release's history."}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"history"})," prints out historical revisions for a given release. A default maximum of 256 revisions will be returned. Setting ",(0,r.jsx)(s.code,{children:"--max"})," configures the maximum length of the revision list returned."]}),"\n",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(s.h3,{id:"--command-8-helm-rollback",children:"- Command 8: helm rollback"}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"- The command:"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-bash",children:"helm rollback RELEASE_NAME REVISION_NUMBER -n NAMESPACE\n"})}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"- Description:"})}),"\n",(0,r.jsx)(s.p,{children:"Roll back a release to a previous revision."}),"\n",(0,r.jsxs)(s.p,{children:["The first argument of the rollback command is the name of a release, and the second is a revision (version) number. ",(0,r.jsxs)(s.em,{children:["If this argument is omitted or set to 0, it will roll back to the ",(0,r.jsx)(s.strong,{children:"previous"})," release"]}),"."]}),"\n",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(s.h3,{id:"--command-9-helm-template",children:"- Command 9: helm template"}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"- The command:"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-bash",children:"helm template CHART path/to/chart --values path/to/values.yaml\n"})}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"- Description:"})}),"\n",(0,r.jsx)(s.p,{children:"Render chart templates locally and display the output."}),"\n",(0,r.jsx)(s.p,{children:"Any values that would normally be looked up or retrieved in-cluster will be faked locally. Additionally, none of the server-side testing of chart validity (e.g. whether an API is supported) is done."}),"\n",(0,r.jsxs)(s.p,{children:["The ",(0,r.jsx)(s.code,{children:"template"})," command outputs clean templates, ready to be used by a kubernetes API server, so if you like doing all the applying job yourself, and just want helm to help you with the creation of the charts, you have an option for that as well."]}),"\n",(0,r.jsxs)(s.p,{children:["Note that creating a template does not communicate with the server at all, not even for validating that the resource template yaml is ok. This is as opposed to the ",(0,r.jsx)(s.code,{children:"--dry-run"})," flag on ",(0,r.jsx)(s.code,{children:"helm upgrade"}),", which does. This is what makes ",(0,r.jsx)(s.code,{children:"helm template"})," so useful, that it doesn't need the credentials to talk to a k8x cluster, just to have a template validated."]}),"\n",(0,r.jsx)(s.h3,{id:"--command-10-helm-package",children:"- Command 10: helm package"}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"- The command:"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-bash",children:"helm package path/to/root [flags] --version VERSION_NUMBER --debug\n"})}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"- Description:"})}),"\n",(0,r.jsx)(s.p,{children:"Package a chart directory into a chart archive."}),"\n",(0,r.jsxs)(s.p,{children:["This command packages a chart into a ",(0,r.jsx)(s.strong,{children:"versioned"})," chart archive file. If a path is given, this will look at that path for a chart (which must contain a ",(0,r.jsx)(s.code,{children:"Chart.yaml"})," file) and then package that directory."]}),"\n",(0,r.jsx)(s.p,{children:"Versioned chart archives are used by Helm package repositories."}),"\n",(0,r.jsx)(s.p,{children:"To sign a chart, use the '--sign' flag. In most cases, you should also provide '--keyring path/to/secret/keys' and '--key keyname'."}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-bash",children:"helm package --sign ./mychart --key mykey --keyring ~/.gnupg/secring.gpg\n"})}),"\n",(0,r.jsx)(s.p,{children:"If '--keyring' is not specified, Helm usually defaults to the public keyring unless your environment is otherwise configured."}),"\n",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(s.h3,{id:"--command-11-helm-get-values",children:"- Command 11: helm get values"}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"- The command:"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-bash",children:"helm get values RELEASE_NAME\n"})}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"- Description:"})}),"\n",(0,r.jsx)(s.p,{children:"Download the values file for a named release."}),"\n",(0,r.jsx)(s.p,{children:"Running the command just like that, gives you the values used on this upgrade alone."}),"\n",(0,r.jsxs)(s.p,{children:["To get all values, use the ",(0,r.jsx)(s.code,{children:"--all"})," flag."]}),"\n",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(s.h3,{id:"--command-12-helm-get-notes",children:"- Command 12: helm get notes"}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"- The command:"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-bash",children:"helm get notes RELEASE_NAME\n"})}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"- Description:"})}),"\n",(0,r.jsx)(s.p,{children:"Get the release notes of some named release."}),"\n",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(s.hr,{}),"\n",(0,r.jsx)(s.h2,{id:"3-helm-architecture",children:"3. Helm Architecture"}),"\n",(0,r.jsx)(s.p,{children:"Prerequisites:"}),"\n",(0,r.jsxs)(s.ol,{children:["\n",(0,r.jsx)(s.li,{children:"A Kubernetes cluster"}),"\n",(0,r.jsx)(s.li,{children:"Deciding what security configurations to apply to your installation, if any"}),"\n",(0,r.jsx)(s.li,{children:"Installing and configuring Helm."}),"\n",(0,r.jsx)(s.li,{children:"You must have Kubernetes installed. For the latest release of Helm, we recommend the latest stable release of Kubernetes, which in most cases is the second-latest minor release."}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:"Helm has 4 big concepts to it:"}),"\n",(0,r.jsx)(s.h3,{id:"--concept-1-chart",children:"- Concept 1: Chart"}),"\n",(0,r.jsxs)(s.p,{children:["A ",(0,r.jsx)(s.strong,{children:"Chart"})," is a Helm package. It contains all of the resource definitions necessary to run an application, tool, or service inside of a Kubernetes cluster. Think of it like the Kubernetes equivalent of a Homebrew formula, an Apt dpkg, or a Yum RPM file."]}),"\n",(0,r.jsx)(s.h3,{id:"--concept-2-repository",children:"- Concept 2: Repository"}),"\n",(0,r.jsxs)(s.p,{children:["A ",(0,r.jsx)(s.strong,{children:"Repository"})," is the place where charts can be collected and shared. It's like Perl's CPAN archive or the Fedora Package Database, but for Kubernetes packages."]}),"\n",(0,r.jsx)(s.h3,{id:"--concept-3-release",children:"- Concept 3: Release"}),"\n",(0,r.jsxs)(s.p,{children:["A ",(0,r.jsx)(s.strong,{children:"Release"})," is ",(0,r.jsxs)(s.em,{children:["an instance of a ",(0,r.jsx)(s.strong,{children:"chart"})]})," running inside a Kubernetes cluster. One chart can often be installed many times into the same cluster. And each time it is installed, a new ",(0,r.jsx)(s.strong,{children:"release"})," is created. Consider a MySQL chart. If you want two databases running in your cluster, you can install that chart twice. Each one will have its own ",(0,r.jsx)(s.strong,{children:"release"}),", which will in turn have its own ",(0,r.jsx)(s.em,{children:"release name"}),"."]}),"\n",(0,r.jsx)(s.p,{children:"With these concepts in mind, we can now explain Helm like this:"}),"\n",(0,r.jsxs)(s.p,{children:["Helm installs ",(0,r.jsx)(s.strong,{children:"charts"})," into Kubernetes, creating a new ",(0,r.jsx)(s.strong,{children:"release"})," for each installation. And to find new charts, you can search Helm chart ",(0,r.jsx)(s.strong,{children:"repositories"}),"."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-bash",children:"helm show values\n"})}),"\n",(0,r.jsx)(s.h3,{id:"--concept-4-tiller",children:"- Concept 4: Tiller"}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Tiller"})," is a component of Helm that runs inside the Kubernetes cluster. Tiller is what provides the functionality to apply the Kubernetes resource descriptions to the Kubernetes cluster. When you install a release, the helm client essentially packages up the values and charts as a release, which is submitted to Tiller."]}),"\n",(0,r.jsx)(s.hr,{}),"\n",(0,r.jsx)(s.h2,{id:"4-what-is-helm",children:(0,r.jsx)(s.strong,{children:"4. What is helm?"})}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Helm"})," is a ",(0,r.jsx)(s.strong,{children:"package manager"})," for ",(0,r.jsx)(s.strong,{children:"kubernetes"}),", that makes it easy to take applications and services that are highly repeatable or get used in a lot of different scenarios and it makes it easier to deploy them to a typical kubernetes cluster. chart = template. Your chart is going to consist of all the files that you're going to be templating here.\nHelm talks to a component that needs to be installed on your kubernetes cluster called ",(0,r.jsx)(s.strong,{children:"Tiller"}),'. Tiller is basically just the server-side component of helm. It\'s gonna take the commands you\'ve sent with helm client, and turn it into something that your kubernetes cluster will understand. Now, this becomes extra useful when you wanna do things like "upgrade to a new configuration" or "rollback to an older revision".\nWhat Helm will also give you is that it actually keeps a version history for you of different configurations you\'ve sent over the wire with help, so you can rollback to the last known working configuration whenever you want to.\nGood things to template:']}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["the ",(0,r.jsx)(s.code,{children:"namespace"})]}),"\n",(0,r.jsxs)(s.li,{children:["the ",(0,r.jsx)(s.code,{children:"selector"})," name"]}),"\n",(0,r.jsxs)(s.li,{children:["the ",(0,r.jsx)(s.code,{children:"image"}),":","\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["its ",(0,r.jsx)(s.code,{children:"name"})]}),"\n",(0,r.jsxs)(s.li,{children:["its ",(0,r.jsx)(s.code,{children:"tag"})]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["the ",(0,r.jsx)(s.code,{children:"configmap.name"}),"\nCreate a NOTES.txt file, which outputs to the user on every upgrade command.\nThis file could also be templated.\nYou can create 1 values.yaml file for production and one for development."]}),"\n"]}),"\n",(0,r.jsx)(s.hr,{}),"\n",(0,r.jsx)(s.h2,{id:"5-why-helm",children:(0,r.jsx)(s.strong,{children:"5. Why Helm?"})}),"\n",(0,r.jsx)(s.h3,{id:"--intelligent-deployments",children:"- Intelligent Deployments"}),"\n",(0,r.jsxs)(s.p,{children:["Helm is very intelligent when it comes to deployments. When we directly work with Kubernetes, we have to mention the order in which the resources should be created. For example, ",(0,r.jsx)(s.strong,{children:"configmaps"})," and ",(0,r.jsx)(s.strong,{children:"secrets"})," should be usually created before ",(0,r.jsx)(s.strong,{children:"deployment"})," and ",(0,r.jsx)(s.strong,{children:"services"}),". Helm knows to consider the correct order in which Kubernetes resources should be created, and it will automatically do it for us."]}),"\n",(0,r.jsx)(s.h3,{id:"--lifecycle-hooks",children:"- Lifecycle Hooks"}),"\n",(0,r.jsx)(s.p,{children:"Helm also uses lifecycle hooks."}),"\n",(0,r.jsxs)(s.p,{children:["If there is any work, which is not directly related to Kubernetes, but it has to be done during the installation or the upgrade, ",(0,r.jsx)(s.strong,{children:"helm allows us to write hooks"})," that can be hooked into the lifecycle events."]}),"\n",(0,r.jsx)(s.p,{children:"Example lifecycle hooks are installation, upgrade, uninstallation, tests, etc."}),"\n",(0,r.jsx)(s.p,{children:"This could be writing data to database, backing up a database, or making sure that the Kubernetes cluster is in a required state before we do an installation. Such work can be put into a hook, and it can be hooked into helm's installation or upgrade, or uninstallation lifecycle."}),"\n",(0,r.jsx)(s.h3,{id:"--security",children:"- Security"}),"\n",(0,r.jsx)(s.p,{children:"Helm has built-in support to ensure that charts which are downloaded from a central repository are secured."}),"\n",(0,r.jsxs)(s.p,{children:["The ",(0,r.jsx)(s.strong,{children:"charts can be signed"})," using cryptography, and hashes can be generated, and when we install these charts, we're pulling them from the central repos, ",(0,r.jsx)(s.strong,{children:"helm will verify"})," that these charts are really from the source we are expecting and that they were not tweaked by any hacker."]}),"\n",(0,r.jsx)(s.hr,{}),"\n",(0,r.jsx)(s.h2,{id:"6-how-does-helm-work",children:(0,r.jsx)(s.strong,{children:"6. How does helm work?"})}),"\n",(0,r.jsx)(s.h3,{id:"--step-1-chart-resolution",children:"- Step 1: Chart resolution"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["Helm looks for the chart (",(0,r.jsx)(s.code,{children:"<chart>"}),") either locally or from a remote chart repository (like ",(0,r.jsx)(s.code,{children:"https://charts.bitnami.com/bitnami"}),")."]}),"\n",(0,r.jsxs)(s.li,{children:["It loads the chart into memory, including:","\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"Chart.yaml"}),": metadata"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"values.yaml"}),": default configuration values"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"templates/"}),": YAML templates with Go templating"]}),"\n",(0,r.jsxs)(s.li,{children:["Any other custom files like ",(0,r.jsx)(s.code,{children:"NOTES.txt"})]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["Helm parses the ",(0,r.jsx)(s.code,{children:"Chart.yaml"})," (chart metadata) and ",(0,r.jsx)(s.code,{children:"values.yaml"})," (default values) using a YAML parser. If you pass a custom values file (",(0,r.jsx)(s.code,{children:"-f my-values.yaml"}),") or ",(0,r.jsx)(s.code,{children:"--set"})," flags, those are also parsed."]}),"\n"]}),"\n",(0,r.jsxs)(s.p,{children:["The first thing Helm does when you do a ",(0,r.jsx)(s.code,{children:"helm install"})," is to load the chart and its dependencies. If it is a local chart, it will simply load it from your local machine. If it is a chart living on a repository, it will pull that chart and it will load it."]}),"\n",(0,r.jsx)(s.h3,{id:"--step-2-merge-values",children:"- Step 2: Merge Values"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["Helm merges configuration values:","\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:(0,r.jsx)(s.code,{children:"values.yaml"})}),"\n",(0,r.jsxs)(s.li,{children:["Any ",(0,r.jsx)(s.code,{children:"--values"})," (",(0,r.jsx)(s.code,{children:"-f"}),") file provided"]}),"\n",(0,r.jsxs)(s.li,{children:["Any ",(0,r.jsx)(s.code,{children:"--set"})," CLI overrides"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["The result is a ",(0,r.jsx)(s.strong,{children:"single values map"})," used to render templates."]}),"\n"]}),"\n",(0,r.jsx)(s.h3,{id:"--step-3-template-rendering",children:"- Step 3: Template Rendering"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["Helm renders the Go templates inside ",(0,r.jsx)(s.code,{children:"templates/"})," directory using the merged values."]}),"\n",(0,r.jsxs)(s.li,{children:["This results in standard Kubernetes manifests (YAML) \u2014 like ",(0,r.jsx)(s.code,{children:"Deployments"}),", ",(0,r.jsx)(s.code,{children:"Services"}),", ",(0,r.jsx)(s.code,{children:"Ingress"}),", ",(0,r.jsx)(s.code,{children:"ConfigMaps"}),", etc."]}),"\n",(0,r.jsx)(s.li,{children:"The produces final YAML documents are in ** plain text**. These rendered YAMLs are still just strings at this point."}),"\n"]}),"\n",(0,r.jsx)(s.h3,{id:"--step-4-install-release-to-kubernetes",children:"- Step 4: Install Release to Kubernetes"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:["Before sending to Kubernetes, ",(0,r.jsx)(s.strong,{children:"Helm parses the rendered YAMLs"})," to:"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"Validate them structurally (to some degree)"}),"\n",(0,r.jsx)(s.li,{children:"Convert them to Kubernetes API-compatible JSON objects (Kubernetes API works with JSON under the hood)"}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Invalid YAMLs here will raise errors"})," (e.g. bad indentation, missing colons)."]}),"\n",(0,r.jsx)(s.li,{children:"Helm needs to convert YAML to internal objects to check for things like hooks, CRDs, kinds, etc."}),"\n",(0,r.jsx)(s.li,{children:"Kubernetes itself also validates these later, but Helm catches obvious issues first."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:["Helm then ",(0,r.jsx)(s.strong,{children:"connects"})," to the Kubernetes cluster (via ",(0,r.jsx)(s.code,{children:"~/.kube/config"})," or ",(0,r.jsx)(s.code,{children:"context"}),")."]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsx)(s.p,{children:"It sends the rendered manifests to the Kubernetes API server."}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsx)(s.p,{children:"The Kubernetes API server validates and stores the manifests in etcd."}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:["Resources are then created by Kubernetes controllers (e.g., ",(0,r.jsx)(s.code,{children:"Deployment"})," creates ",(0,r.jsx)(s.code,{children:"Pods"}),")."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(s.h3,{id:"--step-5-create-release-record-in-cluster",children:"- Step 5: Create Release Record (in Cluster)"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["Helm stores a ",(0,r.jsx)(s.strong,{children:"release object"})," in the cluster using ",(0,r.jsx)(s.code,{children:"secrets/configmaps"})," in the release namespace. (in older versions, 2 and below, it would store them in the namespace ",(0,r.jsx)(s.code,{children:"kube-system"}),")."]}),"\n",(0,r.jsxs)(s.li,{children:["The release record includes:","\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"Rendered manifests"}),"\n",(0,r.jsx)(s.li,{children:"Chart metadata"}),"\n",(0,r.jsx)(s.li,{children:"Values used"}),"\n",(0,r.jsx)(s.li,{children:"Version info"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(s.h3,{id:"--step-6-run-hooks-if-any-exists",children:"- Step 6: Run Hooks (if any exists)"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"Helm checks for lifecycle hooks defined in templates (like pre-install, post-install)."}),"\n",(0,r.jsx)(s.li,{children:"These jobs/pods are created and monitored."}),"\n"]}),"\n",(0,r.jsx)(s.h3,{id:"--step-7-show-output",children:"- Step 7: Show Output"}),"\n",(0,r.jsxs)(s.p,{children:["If successful, Helm outputs the status. Release name, namespace, resources created, and any messages from ",(0,r.jsx)(s.code,{children:"NOTES.txt"})," (templated and displayed)."]})]})}function d(e={}){const{wrapper:s}={...(0,t.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},7010:(e,s,n)=>{n.d(s,{R:()=>i,x:()=>a});var l=n(758);const r={},t=l.createContext(r);function i(e){const s=l.useContext(t);return l.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),l.createElement(t.Provider,{value:s},e.children)}}}]);