"use strict";(self.webpackChunkdocusaurus_guides=self.webpackChunkdocusaurus_guides||[]).push([[7767],{7084:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>t,metadata:()=>a,toc:()=>c});var i=s(6070),r=s(5710);const t={},o="ElasticSearch",a={id:"programming/elasticsearch",title:"ElasticSearch",description:"Coming Soon:",source:"@site/docs/programming/elasticsearch.md",sourceDirName:"programming",slug:"/programming/elasticsearch",permalink:"/guides/he/docs/programming/elasticsearch",draft:!1,unlisted:!1,editUrl:"https://github.com/talkohavy/guides/docs/programming/elasticsearch.md",tags:[],version:"current",frontMatter:{},sidebar:"mySidebar",previous:{title:"- Docker",permalink:"/guides/he/docs/programming/docker"},next:{title:"- ELK Stack",permalink:"/guides/he/docs/programming/elk"}},l={},c=[{value:"Coming Soon:",id:"coming-soon",level:2},{value:"<strong>1. How to Query in ElasticSearch</strong>",id:"1-how-to-query-in-elasticsearch",level:2},{value:"A. Leaf Nodes",id:"a-leaf-nodes",level:3},{value:"- match",id:"--match",level:4},{value:"- multi_match",id:"--multi_match",level:4},{value:"- query_string",id:"--query_string",level:4},{value:"- term",id:"--term",level:4},{value:"B. Compound Queries",id:"b-compound-queries",level:3},{value:"- Command parent: <code>bool</code>",id:"--command-parent-bool",level:4},{value:"- Command 1: <code>bool.must</code>",id:"--command-1-boolmust",level:4},{value:"- Command 2: <code>bool.filter</code>",id:"--command-2-boolfilter",level:4},{value:"- Command 3: <code>bool.should</code>",id:"--command-3-boolshould",level:4},{value:"- Command 4: <code>bool.filter</code>",id:"--command-4-boolfilter",level:4},{value:"<strong>2. Aggregations.</strong>",id:"2-aggregations",level:2},{value:"Aggregation Type 1: <code>terms</code>",id:"aggregation-type-1-terms",level:3},{value:"Aggregation Type 2: metric aggs <code>sum</code>, <code>avg</code>, <code>min</code>, <code>max</code>",id:"aggregation-type-2-metric-aggs-sum-avg-min-max",level:3},{value:"Aggregation Type 3: <code>stats</code>",id:"aggregation-type-3-stats",level:3},{value:"Aggregation Type 4: <code>cardinality</code>",id:"aggregation-type-4-cardinality",level:3},{value:"Aggregation Type 5: bucket aggs <code>histogram</code> &amp; <code>date_histogram</code>",id:"aggregation-type-5-bucket-aggs-histogram--date_histogram",level:3},{value:"<strong>3. Misc.</strong>",id:"3-misc",level:2},{value:"- A. <code>track_total_hits</code>",id:"--a-track_total_hits",level:3},{value:"-B. <code>from</code> &amp; <code>size</code> (Pagination)",id:"-b-from--size-pagination",level:3},{value:"-C. <code>_source</code>",id:"-c-_source",level:3},{value:"<strong>4. Practical Examples</strong>",id:"4-practical-examples",level:2},{value:"- Action 1: Get a Document by id",id:"--action-1-get-a-document-by-id",level:3},{value:"- Action 2: Get all Documents",id:"--action-2-get-all-documents",level:3},{value:"- Action 3: Get Documents where FIELD is an exact match to value",id:"--action-3-get-documents-where-field-is-an-exact-match-to-value",level:3},{value:"- Action 4: Get Documents where Field value ranges between x &amp; Y",id:"--action-4-get-documents-where-field-value-ranges-between-x--y",level:3},{value:"- Action 5: Get avg value of field",id:"--action-5-get-avg-value-of-field",level:3},{value:"- Action 6: Count how many instances of a certain value are there",id:"--action-6-count-how-many-instances-of-a-certain-value-are-there",level:3},{value:"- Action 7: Get the sum value of FIELD_NAME",id:"--action-7-get-the-sum-value-of-field_name",level:3},{value:"- Action 8: Get the avg value of FIELD_NAME",id:"--action-8-get-the-avg-value-of-field_name",level:3},{value:"- Action 9: Get the min/max value of FIELD_NAME",id:"--action-9-get-the-minmax-value-of-field_name",level:3},{value:"- Action 10: Group by some field name",id:"--action-10-group-by-some-field-name",level:3},{value:"- Action 11: Group documents by time intervals (day, week, month).",id:"--action-11-group-documents-by-time-intervals-day-week-month",level:3},{value:"7. Learn about the Operations",id:"7-learn-about-the-operations",level:2},{value:"- Setting Size to 0",id:"--setting-size-to-0",level:3}];function d(e){const n={admonition:"admonition",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"elasticsearch",children:"ElasticSearch"})}),"\n",(0,i.jsx)(n.h2,{id:"coming-soon",children:"Coming Soon:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"inverted index"}),"\n",(0,i.jsx)(n.li,{children:"dynamic mapping"}),"\n",(0,i.jsx)(n.li,{children:"data types (of numbers)"}),"\n",(0,i.jsx)(n.li,{children:"creating a runtime field"}),"\n",(0,i.jsx)(n.li,{children:"precision"}),"\n",(0,i.jsx)(n.li,{children:"recall"}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"1-how-to-query-in-elasticsearch",children:(0,i.jsx)(n.strong,{children:"1. How to Query in ElasticSearch"})}),"\n",(0,i.jsxs)(n.p,{children:["There are 2 main ways to search in elasticsearch: ",(0,i.jsx)(n.code,{children:"queries"})," & ",(0,i.jsx)(n.code,{children:"aggregations"}),". Queries are used to retrieve documents that meet certain criteria."]}),"\n",(0,i.jsx)(n.p,{children:'There are 2 types of queries under the "query" command:'}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Leaf Query Clauses"}),": These clauses search for a specific value in a specific field."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Compound Query Clauses"}),": These clauses combine multiple leaf or compound query clauses to build complex queries."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Some examples of ",(0,i.jsx)(n.strong,{children:"leaf query"})," nodes are:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"match"}),"\n",(0,i.jsx)(n.li,{children:"multi_match"}),"\n",(0,i.jsx)(n.li,{children:"query_string"}),"\n",(0,i.jsx)(n.li,{children:"term"}),"\n",(0,i.jsx)(n.li,{children:"range"}),"\n",(0,i.jsx)(n.li,{children:"match_all"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"After all those queries there cannot be any nested queries within."}),"\n",(0,i.jsxs)(n.p,{children:["And then there are the ",(0,i.jsx)(n.strong,{children:"compound queries"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"Compound is in the sense that it helps combine a bunch of leaf queries together. And this is something we do often, we want several conditions to be met, so we need to combine a number of leaf query nodes."}),"\n",(0,i.jsxs)(n.p,{children:["Some examples of ",(0,i.jsx)(n.strong,{children:"compound query"})," arrays:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"bool"}),"\n",(0,i.jsx)(n.li,{children:"dis_max"}),"\n",(0,i.jsx)(n.li,{children:"function_score"}),"\n",(0,i.jsx)(n.li,{children:"boosting"}),"\n",(0,i.jsx)(n.li,{children:"constant_score"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"a-leaf-nodes",children:"A. Leaf Nodes"}),"\n",(0,i.jsx)(n.h4,{id:"--match",children:"- match"}),"\n",(0,i.jsx)(n.p,{children:"...write here..."}),"\n",(0,i.jsx)(n.h4,{id:"--multi_match",children:"- multi_match"}),"\n",(0,i.jsx)(n.p,{children:"...write here..."}),"\n",(0,i.jsx)(n.h4,{id:"--query_string",children:"- query_string"}),"\n",(0,i.jsx)(n.p,{children:"...write here..."}),"\n",(0,i.jsx)(n.h4,{id:"--term",children:"- term"}),"\n",(0,i.jsx)(n.p,{children:"...write here..."}),"\n",(0,i.jsx)(n.h3,{id:"b-compound-queries",children:"B. Compound Queries"}),"\n",(0,i.jsxs)(n.h4,{id:"--command-parent-bool",children:["- Command parent: ",(0,i.jsx)(n.code,{children:"bool"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"The form:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "query": {\n    "bool": {\n      "must": [],\n      "filter": [],\n      "should": [],\n      "must_not": []\n    }\n  }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(n.p,{children:["The bool compound is useful when you want to combine a number of leaf queries by using a boolean operation like an ",(0,i.jsx)(n.code,{children:"AND"})," or ",(0,i.jsx)(n.code,{children:"OR"})," or ",(0,i.jsx)(n.code,{children:"NOT"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Use ",(0,i.jsx)(n.code,{children:"bool.must"})," when you need to implement an ",(0,i.jsx)(n.code,{children:"AND"}),".",(0,i.jsx)(n.br,{}),"\n","Use ",(0,i.jsx)(n.code,{children:"bool.should"})," when you need to implement an ",(0,i.jsx)(n.code,{children:"OR"})," operator.",(0,i.jsx)(n.br,{}),"\n","Use ",(0,i.jsx)(n.code,{children:"bool.must_not"})," when you need to implement a ",(0,i.jsx)(n.code,{children:"NOT"})," operator."]}),"\n",(0,i.jsx)(n.p,{children:"All 3 are nothing but arrays of sub-documents, inside which we need to write all the leaf queries."}),"\n",(0,i.jsxs)(n.p,{children:["Like ",(0,i.jsx)(n.code,{children:"bool.must"}),", the ",(0,i.jsx)(n.code,{children:"bool.must_not"})," has an ",(0,i.jsx)(n.code,{children:"AND"})," relation between all its leaf nodes."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.em,{children:(0,i.jsxs)("font",{size:"4",children:[(0,i.jsx)(n.code,{children:"bool.filter"})," V.S. ",(0,i.jsx)(n.code,{children:"bool.must"})]})})})}),"\n",(0,i.jsxs)(n.p,{children:["There's a fourth member called ",(0,i.jsx)(n.code,{children:"bool.filter"})," we haven't talked about."]}),"\n",(0,i.jsxs)(n.p,{children:["In a way, the ",(0,i.jsx)(n.code,{children:"bool.filter"})," and the ",(0,i.jsx)(n.code,{children:"bool.must"})," are very much alike. They only differ by some small things. When we write a leaf query inside a ",(0,i.jsx)(n.code,{children:"bool.must"}),", that query will contribute to the ",(0,i.jsx)(n.strong,{children:"relevance score"}),", but if it written inside the ",(0,i.jsx)(n.code,{children:"bool.filter"}),", it will not have any effect on the score. Use ",(0,i.jsx)(n.code,{children:"bool.filter"})," for faster searches, because there is no score to compute and no ranking to be done."]}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsxs)(n.h4,{id:"--command-1-boolmust",children:["- Command 1: ",(0,i.jsx)(n.code,{children:"bool.must"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"The form:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "query": {\n    "bool": {\n      "must": [],\n    }\n  }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"bool.must"})," is like an ",(0,i.jsx)(n.code,{children:"AND"})," operation. The ",(0,i.jsx)(n.code,{children:"must"})," is an array of checks, and ",(0,i.jsx)(n.strong,{children:"ALL"})," checks must be met in order for a document to go through and be considered a result. ",(0,i.jsx)(n.code,{children:"must"})," goes really well together with the ",(0,i.jsx)(n.code,{children:"match"})," leaf query."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Usage Example:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "query": {\n    "bool": {\n      "must": [\n        { "match": { "fieldName": "Luna" } }\n      ],\n    }\n  }\n}\n'})}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsxs)(n.h4,{id:"--command-2-boolfilter",children:["- Command 2: ",(0,i.jsx)(n.code,{children:"bool.filter"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"The form:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "query": {\n    "bool": {\n      "must": [],\n    }\n  }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(n.p,{children:["Only documents that meet the criteria mentioned under ",(0,i.jsx)(n.code,{children:"bool.filter"})," would pass through. The ",(0,i.jsx)(n.code,{children:"bool.filter"})," field ",(0,i.jsx)(n.em,{children:"DOES NOT affect the ranking"})," score of each document. Using ONLY the ",(0,i.jsx)(n.code,{children:"bool.filter"}),' field in our query would result in all returned documents having a score of 0, because we haven\'t specified a "relevance" factor to be taken into consideration.']}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Usage Example:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "query": {\n    "bool": {\n      "filter": [\n        { "match": { "fieldName": "Luna" } },\n        { "exists": { "field": "fieldName" } },\n        { "range": { "salary": { "gte": 5000, "lte": 20000 } } }\n      ],\n    }\n  }\n}\n'})}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsxs)(n.h4,{id:"--command-3-boolshould",children:["- Command 3: ",(0,i.jsx)(n.code,{children:"bool.should"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"The form:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "query": {\n    "bool": {\n      "should": [],\n    }\n  }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"bool.should"})," is like an ",(0,i.jsx)(n.code,{children:"OR"})," operation. It is an array of checks, and ",(0,i.jsx)(n.strong,{children:"AT LEAST ONE"})," check must be met in order for a document to go through and be considered a result. Like ",(0,i.jsx)(n.code,{children:"bool.must"}),", the ",(0,i.jsx)(n.code,{children:"bool.should"})," goes really well with the ",(0,i.jsx)(n.code,{children:"match"})," leaf node."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Usage Example:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "query": {\n    "bool": {\n      "should": [\n        { "match": { "job_desc": "President" } },\n        { "match": { "name": "Anna" } },\n      ],\n    }\n  }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"In the example above, the documents to be returned would:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:'Either have a name of "Anna".'}),"\n",(0,i.jsx)(n.li,{children:"Either have a job description of President"}),"\n",(0,i.jsx)(n.li,{children:"Or both!"}),"\n"]}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsxs)(n.h4,{id:"--command-4-boolfilter",children:["- Command 4: ",(0,i.jsx)(n.code,{children:"bool.filter"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"The form:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "query": {\n    "bool": {\n      "must": [],\n    }\n  }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(n.p,{children:["We use the ",(0,i.jsx)(n.code,{children:"bool.filter"}),' to filter out results based on a "yes / no" questions. Only documents that meet the criteria mentioned under this field would pass through. The filter field ',(0,i.jsx)(n.em,{children:"DOES NOT affect the ranking"})," score of each document. Using ONLY the ",(0,i.jsx)(n.code,{children:"bool.filter"}),' field in our query would result in all returned documents having a score of 0, because we haven\'t specified a "relevance" factor to be taken into consideration.']}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Usage Example:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "query": {\n    "bool": {\n      "filter": [\n        { "match": { "fieldName": "Luna" } },\n        { "exists": { "field": "fieldName" } },\n        { "range": { "salary": { "gte": 5000, "lte": 20000 } } }\n      ],\n    }\n  }\n}\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"2-aggregations",children:(0,i.jsx)(n.strong,{children:"2. Aggregations."})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"The aggregation form:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "size": 0,\n  "aggs": {\n    "name-your-agg-here": {\n      "specify agg type here": {\n        "field": "name of the field you want to aggregate upon",\n        "size": "state how many buckets you want returned",\n      }\n    }\n  }\n}\n'})}),"\n",(0,i.jsxs)(n.admonition,{type:"info",children:[(0,i.jsxs)(n.p,{children:["Notice the ",(0,i.jsx)(n.code,{children:"size: 0"})," mentioned above?"]}),(0,i.jsxs)(n.p,{children:["When querying using the aggregation, our results would appear under a key called ",(0,i.jsx)(n.code,{children:"aggregations"}),". However, there would still be a ",(0,i.jsx)(n.code,{children:"hits"})," key, containing results of actual rows. Generally speaking, we could omit the ",(0,i.jsx)(n.code,{children:"size: 0"}),", and the query would run just fine. It's just that by default, elastic search returns the top 10 results inside the ",(0,i.jsx)(n.code,{children:"hits"})," array field. But when doing an ",(0,i.jsx)(n.code,{children:"aggregation"}),", we're not interested in the ",(0,i.jsx)(n.code,{children:"hits"}),", we're interested in the ",(0,i.jsx)(n.code,{children:"aggregations"})," result. To hide those 10 results, prefer settings ",(0,i.jsx)(n.code,{children:"size"})," to 0. This tells elasticsearch to forget about the top 10 results, because we're just not interested in them."]})]}),"\n",(0,i.jsxs)(n.h3,{id:"aggregation-type-1-terms",children:["Aggregation Type 1: ",(0,i.jsx)(n.code,{children:"terms"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"The form:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "size": 0,\n  "aggs": {\n    "nameTheAgg": {\n      "terms": {\n        "field": "firstName.keyword",\n        "size": "100", // <--- optional! defaults to 10\n        "order": { "_count": "asc" } // <--- optional! default to `"order": { "_count": "desc" }`\n      }\n    }\n  }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"terms"})," aggregation creates a new ",(0,i.jsx)(n.code,{children:"bucket"})," ",(0,i.jsx)(n.em,{children:"for every unique term"})," it encounters for the specified field."]}),"\n",(0,i.jsx)(n.p,{children:"It is often used to find the most frequently found terms in a document."}),"\n",(0,i.jsx)(n.p,{children:"By default, it returns top 10 terms that are most frequently mentioned in a given dataset, which means it creates up to 10 buckets."}),"\n",(0,i.jsxs)(n.p,{children:["We can override that default behavior and set a custom max bucket size, using the ",(0,i.jsx)(n.code,{children:"size"})," field."]}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.code,{children:"terms"})," aggregation ",(0,i.jsx)(n.strong,{children:"already counts"})," for us how many documents fell under each bucket, and is naming the count field for each bucket as ",(0,i.jsx)(n.code,{children:"doc_count"}),", giving it its count value."]}),"\n",(0,i.jsxs)(n.p,{children:["By default, the ",(0,i.jsx)(n.code,{children:"terms"})," aggregation will sort the buckets by the doc",(0,i.jsx)(n.em,{children:"count values, _in a descending order"}),". You could specify an ascending order if you'd like."]}),"\n",(0,i.jsxs)(n.admonition,{type:"info",children:[(0,i.jsxs)(n.p,{children:["Note the ",(0,i.jsx)(n.code,{children:".keyword"})," addition on the ",(0,i.jsx)(n.em,{children:"firstName"})," above?"]}),(0,i.jsxs)(n.p,{children:["When the field is of type ",(0,i.jsx)(n.code,{children:"text"}),", if you don't add the ",(0,i.jsx)(n.code,{children:".keyword"}),", you'll get back an error!"]}),(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:'"Text fields are not optimiszed for operations that require per-document field data like aggregations and sorting, so these operations are disabled by default. Please use a keyword field instead. Alternatively, set fielddata=true on [firstName] in order to load field data by uninverting the inverted index. Note that this can use significant memory."'})})]}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsxs)(n.h3,{id:"aggregation-type-2-metric-aggs-sum-avg-min-max",children:["Aggregation Type 2: metric aggs ",(0,i.jsx)(n.code,{children:"sum"}),", ",(0,i.jsx)(n.code,{children:"avg"}),", ",(0,i.jsx)(n.code,{children:"min"}),", ",(0,i.jsx)(n.code,{children:"max"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"The form:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "size": 0,\n  "aggs": {\n    "sum_unit_price_agg": {\n      "sum": {\n        "field": "unitPrice"\n      }\n    },\n    "max_unit_price_agg": {\n      "max": {\n        "field": "unitPrice"\n      }\n    },\n    "min_unit_price_agg": {\n      "min": {\n        "field": "unitPrice"\n      }\n    },\n    "avg_unit_price_agg": {\n      "avg": {\n        "field": "unitPrice"\n      }\n    }\n  }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsx)(n.p,{children:"Notice how under each custom name there must be only 1 metric aggregation (either sum, max, min or avg). Having more then 1 would result in an error."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"A Result Example"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "took" : 39,\n  "timed_out" : false,\n  "_shards" : {\n    "total" : 1,\n    "successful" : 1,\n    "skipped" : 0,\n    "failed" : 0\n  },\n  "hits" : {\n    "total" : {\n      "value" : 1002,\n      "relation" : "eq"\n    },\n    "max_score" : null,\n    "hits" : [ ]\n  },\n  "aggregations" : {\n    "sum_unit_price_agg" : {\n      "value" : 1.89859304075E12\n    },\n    "max_unit_price_agg" : {\n      "value" : 6.413472E11\n    },\n    "min_unit_price_agg" : {\n      "value" : 3.091809E7\n    },\n    "avg_unit_price_agg" : {\n      "value" : 1.8948034338822355E9\n    }\n  }\n}\n'})}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsxs)(n.h3,{id:"aggregation-type-3-stats",children:["Aggregation Type 3: ",(0,i.jsx)(n.code,{children:"stats"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"The form:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "size": 0,\n  "aggs": {\n    "unit_price_agg": {\n      "stats": {\n        "field": "unitPrice"\n      }\n    }\n  }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.p,{children:["Running all these metrics, ",(0,i.jsx)(n.code,{children:"min"}),", ",(0,i.jsx)(n.code,{children:"max"}),", ",(0,i.jsx)(n.code,{children:"avg"}),", and ",(0,i.jsx)(n.code,{children:"sum"})," can be quite tedious. That's why elasticsearch developed the action called ",(0,i.jsx)(n.code,{children:"stats"}),", that calculates all these aggregation metrics in one go for us."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"A Result Example"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "aggregations": {\n    "all_stats_unit_price": {\n      "count": 426,\n      "min": 1.01,\n      "max": 498,\n      "avg": 4.39,\n      "sum": 1876200,\n    }\n  }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Notice that the response form is a bit different than if you were to use each one separately."}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsxs)(n.h3,{id:"aggregation-type-4-cardinality",children:["Aggregation Type 4: ",(0,i.jsx)(n.code,{children:"cardinality"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"The form:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "size": 0,\n  "aggs": {\n    "some_agg_name": {\n      "cardinality": {\n        "field": "fieldName",\n        "precision_threshold": 100 // <--- optional! defaults to 3000\n      }\n    }\n  }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsx)(n.p,{children:"A single-value metrics aggregation that calculates an approximate count of distinct values."}),"\n",(0,i.jsxs)(n.p,{children:["This is best explained with an example. Consider you have a shopping table, and a certain column is the name of the product that was purchased. So you might see: ",(0,i.jsx)(n.code,{children:"orange"}),", ",(0,i.jsx)(n.code,{children:"orange"}),", ",(0,i.jsx)(n.code,{children:"banana"}),", ",(0,i.jsx)(n.code,{children:"orange"}),", ",(0,i.jsx)(n.code,{children:"apple"}),", ",(0,i.jsx)(n.code,{children:"apple"}),", ",(0,i.jsx)(n.code,{children:"apple"}),". Using the ",(0,i.jsx)(n.code,{children:"cardinality"})," agg, you'll get back the value 3."]}),"\n",(0,i.jsxs)(n.p,{children:["Note about the word ",(0,i.jsx)(n.strong,{children:"approximate"}),". For high numbers this ",(0,i.jsx)(n.code,{children:"cardinality"})," agg isn't accurate. Use it when the distinct count is low."]}),"\n",(0,i.jsxs)(n.p,{children:["The default ",(0,i.jsx)(n.code,{children:"threshold"})," value is 3000.",(0,i.jsx)(n.br,{}),"\n","The maximum supported value is 40000, thresholds above this number will have the same effect as a threshold of 40000"]}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsxs)(n.h3,{id:"aggregation-type-5-bucket-aggs-histogram--date_histogram",children:["Aggregation Type 5: bucket aggs ",(0,i.jsx)(n.code,{children:"histogram"})," & ",(0,i.jsx)(n.code,{children:"date_histogram"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"The form:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "size": 0,\n  "aggs": {\n    "some_agg_name": {\n      "date_histogram": {\n        "field": "fieldName",\n        "fixed_interval": "specify the interval here, for example: 8h ", // <--- optional! defaults to...\n        "calendar_interval": "specify the interval here, for example: 1M " // <--- optional! defaults to...\n      }\n    }\n  }\n}\n'})}),"\n",(0,i.jsxs)(n.admonition,{type:"info",children:[(0,i.jsx)(n.p,{children:"NOTE!"}),(0,i.jsxs)(n.p,{children:["You can use either ",(0,i.jsx)(n.code,{children:"fixed_interval"}),", or ",(0,i.jsx)(n.code,{children:"calendar_interval"}),", but ",(0,i.jsx)(n.strong,{children:"NOT BOTH"}),"!"]})]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"3-misc",children:(0,i.jsx)(n.strong,{children:"3. Misc."})}),"\n",(0,i.jsxs)(n.h3,{id:"--a-track_total_hits",children:["- A. ",(0,i.jsx)(n.code,{children:"track_total_hits"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"The form:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "track_total_hits": true,\n  "query": {\n    "match_all": { }\n  }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.p,{children:["Generally the total hit count can't be computed accurately without visiting all matches, which is costly for queries that match lots of documents. The ",(0,i.jsx)(n.code,{children:"track_total_hits"})," parameter allows you to control how the total number of hits should be tracked."]}),"\n",(0,i.jsxs)(n.p,{children:["The default value ",(0,i.jsx)(n.code,{children:"track_total_hits"})," is set to 10,000."]}),"\n",(0,i.jsx)(n.p,{children:"This means that requests will count the total hit accurately up to 10,000 hits. It is a good trade off to speed up searches if you don\u2019t need the accurate number of hits after a certain threshold."}),"\n",(0,i.jsxs)(n.p,{children:["When ",(0,i.jsx)(n.code,{children:"track_total_hits"})," is set to ",(0,i.jsx)(n.code,{children:"true"})," the search response will always track the accurate number of hits that match the query."]}),"\n",(0,i.jsxs)(n.h3,{id:"-b-from--size-pagination",children:["-B. ",(0,i.jsx)(n.code,{children:"from"})," & ",(0,i.jsx)(n.code,{children:"size"})," (Pagination)"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"The form:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "size": 10,\n  "from": 0,\n  "query": {\n    "match_all": { }\n  }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"size"})," parameter is the maximum number of hits to return. Defaults to 10.\nThe ",(0,i.jsx)(n.code,{children:"from"})," parameter defines the number of hits to skip. Defaults to 0."]}),"\n",(0,i.jsx)(n.p,{children:"Combine these two together, these parameters define a page of results."}),"\n",(0,i.jsxs)(n.h3,{id:"-c-_source",children:["-C. ",(0,i.jsx)(n.code,{children:"_source"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"The form:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "_source": [ "firstName", "age" ],\n  "from": 0,\n  "query": {\n    "match_all": { }\n  }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description"})}),"\n",(0,i.jsxs)(n.p,{children:["Use the ",(0,i.jsx)(n.code,{children:"_source: []"})," to specify what fields would be retrieved and returned back to the user."]}),"\n",(0,i.jsxs)(n.p,{children:["By default, ",(0,i.jsx)(n.code,{children:"_source"})," includes all the fields within a document."]}),"\n",(0,i.jsxs)(n.p,{children:["When you query the database, under ",(0,i.jsx)(n.code,{children:"hits"})," is where you see the results. Each ",(0,i.jsx)(n.code,{children:"hit"})," includes a ",(0,i.jsx)(n.code,{children:"_source"})," key. ",(0,i.jsx)(n.code,{children:"_source"})," contains the content of the retrieved document itself."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"4-practical-examples",children:(0,i.jsx)(n.strong,{children:"4. Practical Examples"})}),"\n",(0,i.jsx)(n.h3,{id:"--action-1-get-a-document-by-id",children:"- Action 1: Get a Document by id"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"The command:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"GET NAME_OF_INDEX/_doc/id_of_document\n"})}),"\n",(0,i.jsx)(n.p,{children:'Tip: Reading it from right to left would make sense. We\'re requesting the id, of a _document, inside of an index called "NAME_OF_INDEX".'}),"\n",(0,i.jsx)(n.p,{children:"An example for a good response would like:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "_index": "NAME_OF_INDEX",\n  "_type": "_doc ",\n  "_id": "1",\n  "_version": 1,\n  "_seq_no": 1,\n  "found": true,\n  "_source": {\n    "first_name": "John",\n    "candy": "kinder bueno"\n  }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Notice that the ",(0,i.jsx)(n.code,{children:"_source"})," part is containing the information inside the document."]}),"\n",(0,i.jsx)(n.h3,{id:"--action-2-get-all-documents",children:"- Action 2: Get all Documents"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"The command:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'GET NAME_OF_INDEX/_search\n{\n  "query": {\n    "match_all": {}\n  }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"--action-3-get-documents-where-field-is-an-exact-match-to-value",children:"- Action 3: Get Documents where FIELD is an exact match to value"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"The command:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'GET /NAME_OF_INDEX/_search\n{\n  "query": {\n    "term": {\n      "custom_field_name": 2\n    }\n  }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"--action-4-get-documents-where-field-value-ranges-between-x--y",children:"- Action 4: Get Documents where Field value ranges between x & Y"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"The command:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'GET /NAME_OF_INDEX/_search\n{\n  "query": {\n    "range": {\n      "YYY": {\n        "gte": "2024-01-01", // or: "2024-09-30T00:00:00"\n        "lte": "2024-12-31", // or: "2024-09-30T23:59:59",\n        "format": "yyyy-MM-dd" // or: "yyyy-MM-dd\'T\'HH:mm:ss"\n      }\n    }\n  }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["If the ",(0,i.jsx)(n.code,{children:"format"})," parameter is omitted, Elasticsearch will use the default format defined in the mapping of the ",(0,i.jsx)(n.code,{children:"YYY"})," field. The default format for date fields in Elasticsearch is typically ",(0,i.jsx)(n.code,{children:"strict_date_optional_time || epoch_millis"}),", which means:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"strict_date_optional_time"}),": Accepts dates in various common formats, such as ",(0,i.jsx)(n.code,{children:"yyyy-MM-dd"})," (e.g., ",(0,i.jsx)(n.code,{children:"2024-01-01"}),"), ",(0,i.jsx)(n.code,{children:"yyyy-MM-dd'T'HH:mm:ssZ"})," (e.g., ",(0,i.jsx)(n.code,{children:"2024-01-01T00:00:00Z"}),"), and more."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"epoch_millis"}),": Accepts dates as timestamps in milliseconds since the Unix epoch (e.g., ",(0,i.jsx)(n.code,{children:"1704067200000"})," for ",(0,i.jsx)(n.code,{children:"2024-01-01T00:00:00Z"}),")."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Behavior Without format"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["If your date values match the default format (e.g., ",(0,i.jsx)(n.code,{children:"yyyy-MM-dd"})," or ISO 8601), the query works without specifying ",(0,i.jsx)(n.code,{children:"format"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["If your dates use a non-standard format (e.g., ",(0,i.jsx)(n.code,{children:"dd-MM-yyyy"}),"), Elasticsearch might fail to parse them correctly unless ",(0,i.jsx)(n.code,{children:"format"})," is explicitly specified to match the custom format."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"--action-5-get-avg-value-of-field",children:"- Action 5: Get avg value of field"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"The command:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'GET /NAME_OF_INDEX/_search\n{\n  "size": 0,\n  "aggs": {\n    "my_average_price": {\n      "avg": {\n        "field": "FIELD_NAME"\n      }\n    }\n  }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"--action-6-count-how-many-instances-of-a-certain-value-are-there",children:"- Action 6: Count how many instances of a certain value are there"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"The command:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'GET /NAME_OF_INDEX/_search\n{\n  "size": 0,\n  "aggs": {\n    "products_by_category": {\n      "terms": {\n        "field": "FIELD_NAME.keyword"\n      }\n    }\n  }\n}\n\n'})}),"\n",(0,i.jsx)(n.h3,{id:"--action-7-get-the-sum-value-of-field_name",children:"- Action 7: Get the sum value of FIELD_NAME"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"The command:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'GET /products/_search\n{\n  "size": 0,\n  "aggs": {\n    "total_value": {\n      "sum": {\n        "field": "price"\n      }\n    }\n  }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"sum"})," Adds up values of a numeric field."]}),"\n",(0,i.jsx)(n.h3,{id:"--action-8-get-the-avg-value-of-field_name",children:"- Action 8: Get the avg value of FIELD_NAME"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"The command:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'GET /products/_search\n{\n  "size": 0,\n  "aggs": {\n    "average_price": {\n      "avg": {\n        "field": "price"\n      }\n    }\n  }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"--action-9-get-the-minmax-value-of-field_name",children:"- Action 9: Get the min/max value of FIELD_NAME"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"The command:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'GET /products/_search\n{\n  "size": 0,\n  "aggs": {\n    "lowest_price": {\n      "min": {\n        "field": "price"\n      }\n    }\n  }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"min"})," / ",(0,i.jsx)(n.code,{children:"max"})," finds the minimum or maximum value. Works on date fields as well."]}),"\n",(0,i.jsx)(n.p,{children:"Here's an example with a date:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'GET /your_index/_search\n{\n  "size": 0,\n  "aggs": {\n    "earliest_date": {\n      "min": {\n        "field": "your_date_field"\n      }\n    },\n    "latest_date": {\n      "max": {\n        "field": "your_date_field"\n      }\n    }\n  }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:'The results will be in epoch milliseconds by default, but you can format them to human-readable dates by adding the "format" parameter. For example:'}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'"earliest_date": {\n  "min": {\n    "field": "your_date_field",\n    "format": "yyyy-MM-dd"\n  }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"--action-10-group-by-some-field-name",children:"- Action 10: Group by some field name"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"The command:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'GET /products/_search\n{\n  "size": 0,\n  "aggs": {\n    "products_by_category": {\n      "terms": {\n        "field": "category.keyword"\n      }\n    }\n  }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Here, terms aggregation creates a bucket for each unique category and counts the products in each."}),"\n",(0,i.jsx)(n.h3,{id:"--action-11-group-documents-by-time-intervals-day-week-month",children:"- Action 11: Group documents by time intervals (day, week, month)."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"The command:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'GET /logs/_search\n{\n  "size": 0,\n  "aggs": {\n    "logs_per_day": {\n      "date_histogram": {\n        "field": "timestamp",\n        "calendar_interval": "day"\n      }\n    }\n  }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"7-learn-about-the-operations",children:"7. Learn about the Operations"}),"\n",(0,i.jsx)(n.h3,{id:"--setting-size-to-0",children:"- Setting Size to 0"}),"\n",(0,i.jsx)(n.p,{children:'Setting "size": 0 in an Elasticsearch query tells Elasticsearch not to return any document results\u2014only the aggregation data. This is useful when you\'re only interested in summary information or metrics, not in individual documents.'}),"\n",(0,i.jsx)(n.p,{children:'For example, in a query where you\'re aggregating sales data by category, if you set "size": 0, Elasticsearch skips loading individual documents, which can speed up the query, reduce resource usage, and simplify the response.'}),"\n",(0,i.jsx)(n.p,{children:'If you need both the documents and the aggregation results, you can adjust the size to get a limited number of documents. But for aggregations-only requests, setting "size": 0 is a common best practice.'}),"\n",(0,i.jsx)(n.p,{children:'If you don\'t specify "size" in an Elasticsearch query, the default is 10. This means Elasticsearch will return up to 10 matching documents along with the aggregation results (if any aggregations are included).'})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},5710:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>a});var i=s(758);const r={},t=i.createContext(r);function o(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);