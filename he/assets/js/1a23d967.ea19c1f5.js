"use strict";(self.webpackChunkdocusaurus_guides=self.webpackChunkdocusaurus_guides||[]).push([[8752],{1351:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"programming/javascript/getters-and-setters","title":"Getters & Setters","description":"1. Description","source":"@site/docs/programming/javascript/getters-and-setters.md","sourceDirName":"programming/javascript","slug":"/programming/javascript/getters-and-setters","permalink":"/guides/he/docs/programming/javascript/getters-and-setters","draft":false,"unlisted":false,"editUrl":"https://github.com/talkohavy/guides/docs/programming/javascript/getters-and-setters.md","tags":[],"version":"current","frontMatter":{},"sidebar":"mySidebar","previous":{"title":"- Iterator","permalink":"/guides/he/docs/programming/javascript/iterator"},"next":{"title":"- Strict Mode","permalink":"/guides/he/docs/programming/javascript/strict-mode"}}');var s=n(5813),a=n(3546);const i={},o="Getters & Setters",c={},l=[{value:"1. Description",id:"1-description",level:2},{value:"2. Benefits",id:"2-benefits",level:2},{value:"- A. Create readonly immutable property",id:"--a-create-readonly-immutable-property",level:3},{value:"- B. Run Validations",id:"--b-run-validations",level:3},{value:"- C. Derived/Computed Properties",id:"--c-derivedcomputed-properties",level:3},{value:"3. When to avoid",id:"3-when-to-avoid",level:2}];function d(e){const t={br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"getters--setters",children:"Getters & Setters"})}),"\n",(0,s.jsx)(t.h2,{id:"1-description",children:"1. Description"}),"\n",(0,s.jsx)(t.p,{children:"Getters and setters provide more control, flexibility, and encapsulation compared to direct property access. They are particularly useful in cases where you want to:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Validate or transform input/output."}),"\n",(0,s.jsx)(t.li,{children:"Encapsulate implementation details."}),"\n",(0,s.jsx)(t.li,{children:"Dynamically compute values."}),"\n",(0,s.jsx)(t.li,{children:"Add side effects, such as logging or debugging."}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"For straightforward properties, however, direct access is still a valid and simpler choice."}),"\n",(0,s.jsxs)(t.p,{children:["A ",(0,s.jsx)(t.strong,{children:"getter"})," is a function associated with a property that gets the value of a specific property.",(0,s.jsx)(t.br,{}),"\n","A ",(0,s.jsx)(t.strong,{children:"setter"})," is a function associated with a property that sets the value of a specific property. Together, they can indirectly represent the value of a property."]}),"\n",(0,s.jsxs)(t.p,{children:["Within object initializers, getters and setters are defined like regular methods, but prefixed with the keywords ",(0,s.jsx)(t.code,{children:"get"})," or ",(0,s.jsx)(t.code,{children:"set"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"The getter method must not expect a parameter, while the setter method expects exactly one parameter (the new value to set). For instance:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"const myObj = {\n  a: 7,\n  get b() {\n    return this.a + 1;\n  },\n  set c(x) {\n    this.a = x / 2;\n  },\n};\n\nconsole.log(myObj.a); // 7\nconsole.log(myObj.b); // 8, returned from the get b() method\nmyObj.c = 50; // Calls the set c(x) method\nconsole.log(myObj.a); // 25\n"})}),"\n",(0,s.jsx)(t.p,{children:"The myObj object's properties are:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"myObj.a"})," \u2014 a number"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"myObj.b"})," \u2014 a getter that returns ",(0,s.jsx)(t.code,{children:"myObj.a"})," plus 1"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"myObj.c"})," \u2014 a setter that sets the value of ",(0,s.jsx)(t.code,{children:"myObj.a"})," to half of the value ",(0,s.jsx)(t.code,{children:"myObj.c"})," is being set to"]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["Getters and setters can also be added to an object at any time after creation using the ",(0,s.jsx)(t.code,{children:"Object.defineProperties()"})," method. This method's first parameter is the object on which you want to define the getter or setter. The second parameter is an object whose property names are the getter or setter names, and whose property values are objects for defining the getter or setter functions. Here's an example that defines the same getter and setter used in the previous example:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"const myObj = { a: 0 };\n\nObject.defineProperties(myObj, {\n  b: {\n    get() {\n      return this.a + 1;\n    },\n  },\n  c: {\n    set(x) {\n      this.a = x / 2;\n    },\n  },\n});\n\nmyObj.c = 10; // Runs the setter, which assigns 10 / 2 (5) to the 'a' property\nconsole.log(myObj.b); // Runs the getter, which yields a + 1 or 6\n"})}),"\n",(0,s.jsx)(t.p,{children:"Which of the two forms to choose depends on your programming style and task at hand. If you can change the definition of the original object, you will probably define getters and setters through the original initializer. This form is more compact and natural. However, if you need to add getters and setters later \u2014 maybe because you did not write the particular object \u2014 then the second form is the only possible form. The second form better represents the dynamic nature of JavaScript, but it can make the code hard to read and understand."}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsx)(t.h2,{id:"2-benefits",children:"2. Benefits"}),"\n",(0,s.jsx)(t.h3,{id:"--a-create-readonly-immutable-property",children:"- A. Create readonly immutable property"}),"\n",(0,s.jsx)(t.p,{children:"A property with only a getter (i.e. no setter), creates a non-overridable property."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"class User {\n  constructor(name) {\n    this._name = name; // Private-like property\n  }\n\n  get name() {\n    console.log('Getting name...');\n    return this._name;\n  }\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["You can now call ",(0,s.jsx)(t.code,{children:"user.name"}),", and get back it's value, and not be worried about someone doing ",(0,s.jsx)(t.code,{children:"user.name = 1234"})," since it won't do anything."]}),"\n",(0,s.jsx)(t.p,{children:"An example:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"const user = new User('Alice');\nconsole.log(user.name); // Logs \"Alice\"\nuser.name = 'John';\nconsole.log(user.name); // Still logs: \"Alice\"\n"})}),"\n",(0,s.jsx)(t.h3,{id:"--b-run-validations",children:"- B. Run Validations"}),"\n",(0,s.jsx)(t.p,{children:"When setting up a property value, you can make it run some custom validation."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"class User {\n  constructor(name) {\n    this._name = name; // Private-like property\n  }\n\n  get name() {\n    return this._name;\n  }\n\n  set name(newName) {\n    if (newName.length < 3) {\n      throw new Error('Name must be at least 3 characters long.');\n    }\n\n    this._name = newName;\n  }\n}\n\nconst user = new User('Alice');\nuser.name = 'Jo';       // throws and error: \"Name must be at least 3 characters long.\"\n"})}),"\n",(0,s.jsx)(t.h3,{id:"--c-derivedcomputed-properties",children:"- C. Derived/Computed Properties"}),"\n",(0,s.jsx)(t.p,{children:"Getters allow you to return computed values dynamically instead of storing them as properties."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"class Rectangle {\n  constructor(width, height) {\n    this.width = width;\n    this.height = height;\n  }\n\n  get area() {\n    return this.width * this.height;\n  }\n}\n\nconst rect = new Rectangle(5, 10);\nconsole.log(rect.area); // 50 (computed dynamically)\n"})}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsx)(t.h2,{id:"3-when-to-avoid",children:"3. When to avoid"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Performance-critical code"}),": If frequent access to a property involves a computationally expensive getter, this can degrade performance."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Simple properties"}),": If you don't need any validation, transformation, or encapsulation, direct access is simpler and clearer."]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},3546:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>o});var r=n(9729);const s={},a=r.createContext(s);function i(e){const t=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),r.createElement(a.Provider,{value:t},e.children)}}}]);