"use strict";(self.webpackChunkdocusaurus_guides=self.webpackChunkdocusaurus_guides||[]).push([[3792],{7175:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"programming/socket-io/delivery-guarantees","title":"Delivery Guarantees","description":"1. Message ordering","source":"@site/docs/programming/socket-io/delivery-guarantees.md","sourceDirName":"programming/socket-io","slug":"/programming/socket-io/delivery-guarantees","permalink":"/guides/he/docs/programming/socket-io/delivery-guarantees","draft":false,"unlisted":false,"editUrl":"https://github.com/talkohavy/guides/docs/programming/socket-io/delivery-guarantees.md","tags":[],"version":"current","frontMatter":{},"sidebar":"mySidebar","previous":{"title":"- Under the Hood - Socket.IO","permalink":"/guides/he/docs/programming/socket-io/under-the-hood-socket-io"},"next":{"title":"- Reserved Event Names","permalink":"/guides/he/docs/programming/socket-io/reserved-event-names"}}');var i=t(5813),r=t(3546);const o={},a="Delivery Guarantees",c={},l=[{value:"1. Message ordering",id:"1-message-ordering",level:2},{value:"2. Message arrival",id:"2-message-arrival",level:2},{value:"- At most once",id:"--at-most-once",level:3},{value:"- At least once",id:"--at-least-once",level:3},{value:"From client to server",id:"from-client-to-server",level:4},{value:"From server to client",id:"from-server-to-client",level:4}];function d(e){const n={admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"delivery-guarantees",children:"Delivery Guarantees"})}),"\n",(0,i.jsx)(n.h2,{id:"1-message-ordering",children:"1. Message ordering"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Socket.IO guarantees message ordering"}),", no matter which low-level transport is used (even during an upgrade from HTTP long-polling to WebSocket)."]}),"\n",(0,i.jsx)(n.p,{children:"This is achieved thanks to:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"the guarantees provided by the underlying TCP connection"}),"\n",(0,i.jsxs)(n.li,{children:["the careful design of the ",(0,i.jsx)(n.strong,{children:"upgrade mechanism"})]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"2-message-arrival",children:"2. Message arrival"}),"\n",(0,i.jsx)(n.h3,{id:"--at-most-once",children:"- At most once"}),"\n",(0,i.jsxs)(n.p,{children:["By default, Socket.IO provides an ",(0,i.jsx)(n.strong,{children:"at most once"})," guarantee of delivery:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["If the ",(0,i.jsx)(n.strong,{children:"connection is broken while an event is being sent"}),", then there is no guarantee that the other side has received it and there will be no retry upon reconnection"]}),"\n",(0,i.jsxs)(n.li,{children:["a disconnected client will ",(0,i.jsx)(n.strong,{children:"buffer events until reconnection"})," (though the previous point still applies)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"There is no such buffer on the server!"}),", which means that any event that was missed by a disconnected client will not be transmitted to that client upon reconnection"]}),"\n"]}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsx)(n.p,{children:"As of now, additional delivery guarantees must be implemented in your application."})}),"\n",(0,i.jsx)(n.h3,{id:"--at-least-once",children:"- At least once"}),"\n",(0,i.jsx)(n.h4,{id:"from-client-to-server",children:"From client to server"}),"\n",(0,i.jsxs)(n.p,{children:["From the client side, you can achieve an at least once guarantee with the ",(0,i.jsx)(n.code,{children:"retries"})," option:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"const socket = io({\n  retries: 3,\n  ackTimeout: 10000\n});\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The client will try to send the event (up to ",(0,i.jsx)(n.code,{children:"retries + 1"})," times), until it gets an acknowledgement from the server."]}),"\n",(0,i.jsx)(n.admonition,{type:"caution",children:(0,i.jsx)(n.p,{children:"Even in that case, any pending event will be lost if the user refreshes its tab."})}),"\n",(0,i.jsx)(n.h4,{id:"from-server-to-client",children:"From server to client"}),"\n",(0,i.jsx)(n.p,{children:"For events sent by the server, additional delivery guarantees can be implemented by:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"assigning a unique ID to each event"}),"\n",(0,i.jsx)(n.li,{children:"persisting the events in a database"}),"\n",(0,i.jsx)(n.li,{children:"storing the offset of the last received event on the client side, and send it upon reconnection"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Example:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"Client"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'const socket = io({\n  auth: {\n    offset: undefined\n  }\n});\n\nsocket.on("my-event", ({ id, data }) => {\n  // do something with the data, and then update the offset\n  socket.auth.offset = id;\n});\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"Server"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'io.on("connection", async (socket) => {\n  const offset = socket.handshake.auth.offset;\n  if (offset) {\n    // this is a reconnection\n    for (const event of await fetchMissedEventsFromDatabase(offset)) {\n      socket.emit("my-event", event);\n    }\n  } else {\n    // this is a first connection\n  }\n});\n\nsetInterval(async () => {\n  const event = {\n    id: generateUniqueId(),\n    data: new Date().toISOString()\n  }\n\n  await persistEventToDatabase(event);\n  io.emit("my-event", event);\n}, 1000);\n'})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},3546:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var s=t(9729);const i={},r=s.createContext(i);function o(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);