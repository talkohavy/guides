"use strict";(self.webpackChunkdocusaurus_guides=self.webpackChunkdocusaurus_guides||[]).push([[3398],{4219:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>r,contentTitle:()=>c,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"programming/devops/circleci/circleci","title":"CircleCI","description":"4. Docker & Docker Images","source":"@site/docs/programming/devops/circleci/circleci.md","sourceDirName":"programming/devops/circleci","slug":"/programming/devops/circleci/","permalink":"/guides/he/docs/programming/devops/circleci/","draft":false,"unlisted":false,"editUrl":"https://github.com/talkohavy/guides/docs/programming/devops/circleci/circleci.md","tags":[],"version":"current","frontMatter":{}}');var i=o(5813),t=o(3546);const a={},c="CircleCI",r={},l=[{value:"4. Docker &amp; Docker Images",id:"4-docker--docker-images",level:2},{value:"5. Checkout",id:"5-checkout",level:2},{value:"6. Jobs &amp; Steps",id:"6-jobs--steps",level:2},{value:"7. Workflows",id:"7-workflows",level:2},{value:"8. Working Directory",id:"8-working-directory",level:2},{value:"9. The RUN command",id:"9-the-run-command",level:2},{value:"10. executors",id:"10-executors",level:2},{value:"11. persist_to_workspace &amp; attach_workspace",id:"11-persist_to_workspace--attach_workspace",level:2},{value:"12. Manually Approved Job (A hold job)",id:"12-manually-approved-job-a-hold-job",level:2},{value:"13. Storing Artifacts",id:"13-storing-artifacts",level:2},{value:"14. Using Contexts",id:"14-using-contexts",level:2},{value:"15. CircleCI CLI",id:"15-circleci-cli",level:2},{value:"Command 1: upgrade circleci version",id:"command-1-upgrade-circleci-version",level:3},{value:"Command 2: setup",id:"command-2-setup",level:3},{value:"Command 3: config validate",id:"command-3-config-validate",level:3},{value:"Command 4: config process",id:"command-4-config-process",level:3},{value:"Command 5: local execute",id:"command-5-local-execute",level:3},{value:"Command 6: context management",id:"command-6-context-management",level:3},{value:"16. Skip Following Steps Inside A Job",id:"16-skip-following-steps-inside-a-job",level:2},{value:"16. Manually Cancel a Workflow",id:"16-manually-cancel-a-workflow",level:2},{value:"17. Caching",id:"17-caching",level:2},{value:"\u2022 Saving Cache",id:"-saving-cache",level:3},{value:"\u2022 Restoring Cache",id:"-restoring-cache",level:3},{value:"18. Multi-Line Run Command",id:"18-multi-line-run-command",level:2},{value:"19. The When Attribute",id:"19-the-when-attribute",level:2},{value:"\u2022 Value 1: on_success",id:"-value-1-on_success",level:3},{value:"\u2022 Value 2: always",id:"-value-2-always",level:3},{value:"\u2022 Value 3: on_fail",id:"-value-3-on_fail",level:3},{value:"\u2022 Specials: on_store_artifacts &amp; store_test_results",id:"-specials-on_store_artifacts--store_test_results",level:3},{value:"20. The When Step",id:"20-the-when-step",level:2}];function d(e){const n={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"circleci",children:"CircleCI"})}),"\n",(0,i.jsx)(n.h2,{id:"4-docker--docker-images",children:"4. Docker & Docker Images"}),"\n",(0,i.jsxs)(n.p,{children:["In the config example above, you might have come across a key called ",(0,i.jsx)(n.code,{children:"docker"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"docker:\n  - image: cimg/node:[tag]\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The docker keyword MUST contain the ",(0,i.jsx)(n.code,{children:"image"})," keyword, and the image's keyword needs an image. That image could be a downloadable image from docker hub, or it could be onde circleci's custom images.\nNow, it should be obvious to you, that in order to run your tests remotely, you first need a remote machine, right? And that machine could be anything! Windows, Macos, or Linux.\nBut your code is probably written for a specific OS, right?\nSo in order to be able to run your code remotely, that machine, whatever it maybe, HAS TO run your code inside a docker! And it's UP TO YOU to tell it which docker image of an operating system YOUR PROJECT NEEDS!"]}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsx)(n.p,{children:'Note! Legacy images with the prefix "circleci/" were deprecated on December 31, 2021. For faster builds, upgrade your projects with next-generation convenience images. They are those which start with "cimg/..."'})}),"\n",(0,i.jsx)(n.p,{children:"Luckily, CircleCI maintains a fleet of images for various programming languages, databases, and operating systems. CircleCI basically gives you a machine that would run a docker container from an image with the operating system of your choice, PLUS some extra stuff that circleci needs in order to live.\nYou can find all of circleci custom images over at:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://circleci.com/developer/images?imageType=docker",children:"https://circleci.com/developer/images?imageType=docker"})}),"\n",(0,i.jsxs)(n.p,{children:["We are going to use ",(0,i.jsx)(n.code,{children:"cimg/node:18.8.0"})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Note"}),"! This image is designed to supersede the legacy CircleCI Node.js image, ",(0,i.jsx)(n.code,{children:"circleci/node"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"cimg/node"})," is a Docker image created by CircleCI with continuous integration builds in mind. Each tag contains a version of Node.js, npm, yarn v1, and any binaries and tools that are required for builds to complete successfully in a CircleCI environment."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"Tag Version"})}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Basically, what we're using is this ",(0,i.jsx)(n.code,{children:"cimg/node:<node-version>"})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"<node-version>"}),' - The version of Node.js to use. This can be a full SemVer point release, such as 10.16.3, or just the minor release, such as 12.6, or a version alias.\nThere are two version aliases: one is "current" and the other is "lts".\nThe alias "current" will always point to the latest, and the alias "lts" will always point to long term releases that Node.js has as according to their website.\n',(0,i.jsx)(n.strong,{children:"Keep in mind"}),"! Using an alias tag will be less stable that specifying a full SemVer version. Breaking changes in node version could break your code without you knowing about it."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"5-checkout",children:"5. Checkout"}),"\n",(0,i.jsxs)(n.p,{children:["One of the most important directives, that would be present in nearly 99% of all your jobs, and for the most part it would come as early in the beginning of a job.\nCheckout performs a ",(0,i.jsx)(n.code,{children:"git clone"})," to your source code, and copies all the relevant files."]}),"\n",(0,i.jsx)(n.p,{children:"How it knows what to clone?"}),"\n",(0,i.jsx)(n.p,{children:"This is one of those things that are done behind the scenes, and this was done when you first connected between circleci and github/bitbucket. By connecting them, you basically allowed circleci to peek into your repository, and gave it access to clone it."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"From the docs"}),":"]}),"\n"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"A special step used to check out source code to the configured path (defaults to the working_directory). The reason this is a special step is because it is more of a helper function designed to make checking out code easy for you. If you require doing git over HTTPS you should not use this step as it configures git to checkout over ssh."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"If\xa0path\xa0already exists and is:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"a git repo - step will not clone whole repo, instead will fetch origin"}),"\n",(0,i.jsx)(n.li,{children:"NOT a git repo - step will fail."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"In the case of\xa0checkout, the step type is just a string with no additional attributes:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"- checkout\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Note: CircleCI does not check out submodules. If your project requires submodules, add run steps with appropriate commands as shown in the following example:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"- checkout\n- run: git submodule sync\n- run: git submodule update --init\n"})}),"\n",(0,i.jsx)(n.p,{children:"This command will automatically add the required authenticity keys for interacting with GitHub and Bitbucket over SSH, which is detailed further in our integration guide \u2013 this guide will also be helpful if you wish to implement a custom checkout command."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Note: The checkout step will configure Git to skip automatic garbage collection. If you are caching your .git directory with restore_cache and would like to use garbage collection to reduce its size, you may wish to use a run step with command git gc before doing so."}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"6-jobs--steps",children:"6. Jobs & Steps"}),"\n",(0,i.jsxs)(n.p,{children:["Even the most basic circleci ",(0,i.jsx)(n.code,{children:"config.yml"})," file would have this trio of: workflow, jobs & steps.\nA CircleCI job is a collection of steps. All of the steps in the job are executed in a single unit, either within a fresh container, or a virtual machine. Jobs are orchestrated using workflows (soon to be discussed).\nInside the config.yml, we define all the jobs we want to run, for example ",(0,i.jsx)(n.code,{children:"build"})," and ",(0,i.jsx)(n.code,{children:"test"}),", and inside each of them, we specify 1 or more steps to be ran.\nAll jobs would be defined under the root key of ",(0,i.jsx)(n.code,{children:"jobs"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'jobs:\n  build:\n    docker: ...\n    steps:\n      - checkout\n      - run echo "hello from build!"\n  test:\n    docker: ...\n    steps:\n      - checkout\n      - run echo "hello from test!"\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Under ",(0,i.jsx)(n.code,{children:"jobs"}),", you specify all your jobs, in an object-like manner.\nEach job is referenced by a unique made-up ",(0,i.jsx)(n.code,{children:"<name>"})," you provide.\nEach job, MUST CONTAIN the ",(0,i.jsx)(n.code,{children:"steps"})," directive, and the ",(0,i.jsx)(n.code,{children:"docker"})," directive.\nThe ",(0,i.jsx)(n.code,{children:"steps"})," is basically an array of commands to be executed sequentially.\nNotice the docker part!\nThis is the first thing to sort out, since your code needs to be executed in some OS environment, so, if you think about it , before all the steps you define, there's actually a step-zero, which is to set up and run an image / docker container."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"7-workflows",children:"7. Workflows"}),"\n",(0,i.jsxs)(n.p,{children:["A workflow gives you the ability to separate and orchestrate jobs.\nYou can refer to ",(0,i.jsx)(n.code,{children:"workflows"}),' as the similar concepts of "pipelines" or "build stages."\nEvery config.yml file should have a ',(0,i.jsx)(n.code,{children:"workflow"})," as a root key!\nIf you do not specify one, a default one would be created for you, which would run only\u2026 I think it's the first job inside the ",(0,i.jsx)(n.code,{children:"jobs"})," array. Anyway, never mind, just define it! Period!"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"workflows:\n  build_and_test:\n    jobs:\n     - build\n     - test\n        requires:\n          - build\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In the example above, you see how the test job is executed after and only after the build job finishes. The second thing you might notice, is the second appearance of the keyword ",(0,i.jsx)(n.code,{children:"jobs"}),". The ",(0,i.jsx)(n.code,{children:"jobs"})," keyword appeared once before as a root level key, where we defined ALL of the project's jobs, and now for a specific workflow, we can take just SOME of those jobs, and re-organize them in any way shape or form we like.\nWhich brings us to our next topic within workflows, with a direct link to workflows, which is sequential and parallel execution of jobs in a workflow."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"Sequential & Parallel execution"})}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["The above example presented a sequential execution, and this was all thanks to the directive of ",(0,i.jsx)(n.code,{children:"requires"}),": -",(0,i.jsx)(n.code,{children:"<job-name>"}),'. The folks at circleci are calling it "fan in" & "fan out".\nHere\'s an example I like that shows both sequential and a parallel execution all-in-one:']}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"                                            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                                            \u2502                      \u2502\n                              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524   Job 1: Build       \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                              \u2502             \u2502         \u2713            \u2502             \u2502\n                              \u2502             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518             \u2502\n                              \u2502                                                  \u2502\n                              \u2502             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510             \u2502\n                              \u2502             \u2502                      \u2502             \u2502\n                              \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524   Job 2: Test        \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502             \u2502         \u2713            \u2502             \u2502       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                      \u2502      \u2502             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518             \u2502       \u2502                      \u2502\n\u2502  Begin               \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524                                                  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524   Job 5: Deploy      \u2502\n\u2502                      \u2502      \u2502             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510             \u2502       \u2502                      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502             \u2502                      \u2502             \u2502       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524   Job 3: Lint        \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n                              \u2502             \u2502         \u2713            \u2502             \u2502\n                              \u2502             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518             \u2502\n                              \u2502                                                  \u2502\n                              \u2502             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510             \u2502\n                              \u2502             \u2502                      \u2502             \u2502\n                              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524   Job 4: Security    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                            \u2502         \u2713            \u2502\n                                            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,i.jsx)(n.p,{children:"This could be achieved in the config.yml by:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"workflows:\n  build_and_test:\n    jobs:\n     - job1\n     - job2\n        requires:\n          - job1\n     - job3\n        requires:\n          - job1\n     - job4\n        requires:\n          - job1\n     - job5\n        requires:\n          - job1\n     - job6\n        requires:\n          - job2\n          - job3\n          - job4\n          - job5\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"8-working-directory",children:"8. Working Directory"}),"\n",(0,i.jsxs)(n.p,{children:["When defining a job, one of the properties you can give it is a directive called ",(0,i.jsx)(n.code,{children:"working_directory"}),", that basically creates a folder, with a name you provide, a second after the container starts to run, to start running the steps of this particular job.\nBy default, when a docker container spins up to run a job, circleci creates this path:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"/home/circleci/project\n"})}),"\n",(0,i.jsxs)(n.p,{children:["By providing a ",(0,i.jsx)(n.code,{children:"working_directory"}),", like so;"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'jobs:\n  build:\n    working_directory: ~/luckylove_frontend\n    docker: ...\n    steps:\n      - checkout\n      - run echo "hello from build!"\n'})}),"\n",(0,i.jsx)(n.p,{children:'you could override the default name "project", and have the path be:'}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"/home/circleci/luckylove_frontend\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"9-the-run-command",children:"9. The RUN command"}),"\n",(0,i.jsxs)(n.p,{children:["As we saw earlier, ",(0,i.jsx)(n.code,{children:"checkout"})," is considered as a ",(0,i.jsx)(n.code,{children:"step"})," inside a ",(0,i.jsx)(n.code,{children:"job"}),".\nHowever, most of the steps you'd want to run would be custom commands you'd write:\nLike ",(0,i.jsx)(n.code,{children:"pnpm install"}),", ",(0,i.jsx)(n.code,{children:"pnpm run lint"}),", ",(0,i.jsx)(n.code,{children:"pnpm run test"}),", ",(0,i.jsx)(n.code,{children:"pnpm run start"}),", etc.\nFor that we have the ",(0,i.jsx)(n.code,{children:"run"})," command, which could be considered as a step inside a job:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'jobs:\n  build:\n    docker: ...\n    steps:\n      - checkout\n      - run echo "hello from build!"\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"run"})," command can actually split into 2 parts, ",(0,i.jsx)(n.code,{children:"name"})," & ",(0,i.jsx)(n.code,{children:"command"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'jobs:\n  build:\n    docker: ...\n    steps:\n      - checkout\n      - run:\n          name: "Step 3: Install all project\'s dependencies"\n          command: echo "hello from build!"\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"10-executors",children:"10. executors"}),"\n",(0,i.jsxs)(n.p,{children:["As you saw in the example above, we had a ",(0,i.jsx)(n.code,{children:"build"})," job, and a ",(0,i.jsx)(n.code,{children:"test"})," job.\nBoth jobs ran the same docker image of cimg/node:18.8.0.\nCircleCI tries its best to remove repetitive code from the configuration file, and hence came the ",(0,i.jsx)(n.code,{children:"executors"})," directive. The ",(0,i.jsx)(n.code,{children:"executors"})," directive is a root key inside the config.yml file, in which you (the developer) would specify a certain image with its tag (i.e. cimg/node:18.8.0) and then later on for every job that requires it, you can simply say:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"+executors:\n  nodejs:\n    docker:\n      - image: cimg/node:18,8,0\n\nbuild:\n+ executor: nodejs\n  working_directory: ~/luckylove_frontend\n- docker:\n-   - image: cimg/node:18.7.0\ntest:\n+ executor: nodejs\n  working_directory: ~/luckylove_frontend\n- docker:\n-   - image: cimg/node:18.7.0\n"})}),"\n",(0,i.jsx)(n.p,{children:"It's is much cleaner that way, and more human-readable."}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"11-persist_to_workspace--attach_workspace",children:"11. persist_to_workspace & attach_workspace"}),"\n",(0,i.jsxs)(n.p,{children:["CircleCI maintains a workspace for you, with a volume of I think 15GB.\nThen it gives you the two directives that actively go together, which are:\n",(0,i.jsx)(n.code,{children:"persist_to_workspace"})," & ",(0,i.jsx)(n.code,{children:"attach_workspace"}),".The first one says: \"hey, at the end of this job? I'm gonna save the container's state and make an image out of it for you guys(1) to use\".\n(1) guys = other jobs\nFrom the docs: persist_to_workspace is a special step used to persist a temporary file to be used by another job in the workflow. persist_to_workspace adopts the storage settings from the storage customization controls on the CircleCI web app. If no custom setting is provided, persist_to_workspace defaults to 15 days."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"- persist_to_workspace:\n    root: /tmp/dir\n    paths:\n      - foo/bar\n      - baz\n"})}),"\n",(0,i.jsx)(n.p,{children:"After this step completes, the following directories are added to the workspace:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"/tmp/dir/foo/bar\n/tmp/dir/baz\n"})}),"\n",(0,i.jsxs)(n.p,{children:["As you see, ",(0,i.jsx)(n.code,{children:"persist_to_workspace"})," gives you access to 2 more directives: ",(0,i.jsx)(n.code,{children:"root"})," & ",(0,i.jsx)(n.code,{children:"paths"}),".\n",(0,i.jsx)(n.code,{children:"root"})," is the root of the workspace circleci maintains for you, and the ",(0,i.jsx)(n.code,{children:"path"})," is the path to copy to the workspace.\nHere's a good example for paths key:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"- persist_to_workspace:\n    root: /tmp/workspace\n    paths:\n      - target/application.jar\n      - build/*\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"persist_to_workspace"})," even accepts a name:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'- persist_to_workspace:\n    name: "Step 5: persist to workspace"\n    root: ...\n    paths: ...\n'})}),"\n",(0,i.jsx)(n.p,{children:"You could also (NOT RECOMMENDED!) copy everything, including node_modules:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"- persist_to_workspace:\n    root: .\n    paths:\n      - .\n"})}),"\n",(0,i.jsx)(n.p,{children:"And then do:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"test:\n\xa0 \xa0 executor: nodejs\n\xa0 \xa0 steps:\n\xa0 \xa0 \xa0 - attach_workspace:\n\xa0 \xa0 \xa0 \xa0 \xa0 at: .\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"12-manually-approved-job-a-hold-job",children:"12. Manually Approved Job (A hold job)"}),"\n",(0,i.jsx)(n.p,{children:"If your deployment strategy requires a manual approval step, you can include a hold/approve job within your workflow. A manual approval button will then be available from the workflows map in the CircleCI web app.\nWorkflows can be configured to wait for manual approval of a job before continuing to the next job. Anyone who has push access to the repository can click the Approval button to continue the workflow. To do this, add a job to the jobs list with the key type: approval. Let\u2019s look at a commented config example."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'# ...\n# << your config for the build, test1, test2, and deploy jobs >>\n# ...\n\nworkflows:\n  version: 2\n  build-test-and-approval-deploy:\n    jobs:\n      - build  # your custom job from your config, that builds your code\n      - test1: # your custom job; runs test suite 1\n          requires: # test1 will not run until the `build` job is completed.\n            - build\n      - test2: # another custom job; runs test suite 2,\n          requires: # test2 is dependent on the success of job `test1`\n            - test1\n      - hold: # <<< A job that will require manual approval in the CircleCI web application.\n          type: approval # <<< This key-value pair will set your workflow to a status of "On Hold"\n          requires: # We only run the "hold" job when test2 has succeeded\n           - test2\n      # On approval of the `hold` job, any successive job that requires the `hold` job will run.\n      # In this case, a user is manually triggering the deploy job.\n      - deploy:\n          requires:\n            - hold\n'})}),"\n",(0,i.jsx)(n.p,{children:"The outcome of the above example is that the\xa0deploy:\xa0job will not run until you click the\xa0hold\xa0job in the Workflows page of the CircleCI app and then click Approve. In this example the purpose of the\xa0hold\xa0job is to wait for approval to begin deployment. A job can be approved for up to 90 days after being issued.\nSome things to keep in mind when using manual approval in a workflow:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"approval\xa0is a special job type that is\xa0only\xa0available to jobs under the\xa0workflow\xa0key"}),"\n",(0,i.jsx)(n.li,{children:"The\xa0hold\xa0job must be a unique name not used by any other job."}),"\n",(0,i.jsx)(n.li,{children:"that is, your custom configured jobs, such as\xa0build\xa0or\xa0test1\xa0in the example above wouldn\u2019t be given a\xa0type: approval\xa0key."}),"\n",(0,i.jsx)(n.li,{children:"The name of the job to hold is arbitrary - it could be\xa0wait\xa0or\xa0pause, for example, as long as the job has a\xa0type: approval\xa0key in it."}),"\n",(0,i.jsx)(n.li,{children:"All jobs that are to run after a manually approved job\xa0must\xa0require:\xa0the name of that job. Refer to the\xa0deploy:\xa0job in the above example."}),"\n",(0,i.jsx)(n.li,{children:"Jobs run in the order defined until the workflow processes a job with the\xa0type: approval\xa0key followed by a job on which it depends."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"By clicking on the pending job's name (build, in the screenshot above), an approval dialog box appears requesting that you approve or cancel the holding job. After approving, the rest of the workflow runs as directed."}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"13-storing-artifacts",children:"13. Storing Artifacts"}),"\n",(0,i.jsx)(n.p,{children:"This document describes how to work with artifacts on CircleCI. Use artifacts to persist data after a job or pipeline has completed. For example, building documents or other assets, or saving test results for further inspection."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"- Artifacts Overview"})}),"\n",(0,i.jsx)(n.p,{children:"Artifacts persist data after a job is completed and may be used for storage of the outputs of your build process. For example, when a Java build/test process finishes, the output of the process is saved as a .jar file. CircleCI can store this file as an artifact, keeping it available after the process has finished.\nHere's how to do that:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"- store_artifacts:\n\xa0 \xa0 \xa0 path: package.json\n\xa0 \xa0 \xa0 destination: my-package.json\n- store_artifacts:\n\xa0 \xa0 \xa0 path: public/static/styles\n\xa0 \xa0 \xa0 destination: my-styles\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"14-using-contexts",children:"14. Using Contexts"}),"\n",(0,i.jsx)(n.p,{children:"Contexts provide a mechanism for securing and sharing environment variables across projects. The environment variables are defined as name/value pairs and are injected at runtime. This document describes creating and using contexts in CircleCI.\nYou can create and manage contexts on the Organization Settings page of the CircleCI web app. You must be an organization member to view, create, or edit contexts. After a context has been created, you can use the context key in the workflows section of a project\nconfig.yml file to give any job(s) access to the environment variables associated with the context, as shown in the image below."}),"\n",(0,i.jsx)(n.p,{children:"Org:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Context: my-context\n$MY_ENV_VAR = my_value\n"})}),"\n",(0,i.jsx)(n.p,{children:"Project:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"version: 2.1\n\nworkflows:\n  build:\n    jobs:\n      - build:\n          context:\n            - my-context\n            - another-context\n\njobs:\n  build:\n    docker:\n      - image: <image-name>:<version TAG>\n    steps: # use env var from Context\n      - run: echo $MY_ENV_VAR\n"})}),"\n",(0,i.jsx)(n.p,{children:"Job Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"echo $MY_ENV_VAR\n\n*******\n"})}),"\n",(0,i.jsx)(n.p,{children:"Here's an example from your code:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'workflows:\n\xa0 build_and_test:\n\xa0 \xa0 jobs:\n\xa0 \xa0 \xa0 - build:\n\xa0 \xa0 \xa0 \xa0 \xa0 context: luckylove\n\xa0 \xa0 \xa0 - test:\n\xa0 \xa0 \xa0 \xa0 \xa0 requires:\n\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 - build\n\njobs:\n\xa0 build:\n\xa0 \xa0 executor: nodejs\n\xa0 \xa0 working_directory: ~/luckylove_frontend\n\xa0 \xa0 steps:\n\xa0 \xa0 \xa0 - checkout\n\xa0 \xa0 \xa0 - run:\n\xa0 \xa0 \xa0 \xa0 \xa0 name: "Step 0: check context variables"\n\xa0 \xa0 \xa0 \xa0 \xa0 command: echo $TOP_SECRET\n'})}),"\n",(0,i.jsxs)(n.p,{children:["As you can see, I gave the ",(0,i.jsx)(n.code,{children:"build"})," jobs the context of ",(0,i.jsx)(n.code,{children:"luckylove"})," only at runtime! At the time of defining it, it had no clue what its context is gonna be."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"15-circleci-cli",children:"15. CircleCI CLI"}),"\n",(0,i.jsx)(n.p,{children:"The CircleCI command line interface (CLI) brings CircleCI's advanced and powerful tools to your terminal. The CLI is supported on cloud and server v3.x+ installations.\nThe CLI requires installation, so if it's not installed for you, head over to google and search \"circleci cli\", and run the installation guide."}),"\n",(0,i.jsx)(n.h3,{id:"command-1-upgrade-circleci-version",children:"Command 1: upgrade circleci version"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"The command:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# windows & linux:\ncircleci update\n\n# macos\nbrew upgrade circleci\n"})}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.h3,{id:"command-2-setup",children:"Command 2: setup"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"The command:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"circleci setup\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(n.p,{children:["This command will create a ",(0,i.jsx)(n.code,{children:".circleci"})," folder inside your user folder, right next to your .ssh folder, and will contain all the cli configurations there. The set up process will prompt you for configuration settings. If you are using the CLI with CircleCI cloud (which you are), use the default CircleCI host."]}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.h3,{id:"command-3-config-validate",children:"Command 3: config validate"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"The command:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"circleci config validate\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(n.p,{children:["Validates that the circleci config you have is valid. Run this command when inside of your ",(0,i.jsx)(n.code,{children:".circleci/"})," folder. Using this command, you can avoid pushing additional commits with bad / invalid configuration file. Instead, run a validation for your config file using the CLI locally."]}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.h3,{id:"command-4-config-process",children:"Command 4: config process"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"The command:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"circleci config process\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsx)(n.p,{children:"Running the following command validates your config, but will also your configuration stripped from comment (at the top), and once again WITH the comment (at the bottom), i.e. in its original form. It's useful if you're using orbs."}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.h3,{id:"command-5-local-execute",children:"Command 5: local execute"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"The command:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"circleci local execute --job JOB_NAME\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"warning",children:(0,i.jsx)(n.p,{children:"As of 2022, circleci doesn't support running on Windows"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsx)(n.p,{children:"The CLI allows you to run a single job from CircleCI on your desktop using Docker. This can only be used to run jobs (not workflows!). The CLI will use Docker to pull down the requirements for the build and then execute your CI steps locally."}),"\n",(0,i.jsx)(n.p,{children:"Limitations of running jobs locally:"}),"\n",(0,i.jsx)(n.p,{children:"Although running jobs locally with circleci is very helpful, there are some limitations."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Machine executor: We haven't covered this, but basically there's a section on circleci called \"Execution Environments\", where they tell you that you can execute circleci either inside docker containers (which is what I chose), or you can do so by using a Linux VM. To use docker, we specified the key ",(0,i.jsx)(n.code,{children:"docker"})," under the name of a job. To use a Linux VM, we need to specify the key ",(0,i.jsx)(n.code,{children:"machine"}),' under the name of a job. So now let\'s go back to the restriction: "With a linux machine You cannot use the machine executor in local jobs. This is because the machine executor requires an extra VM to run its jobs".']}),"\n",(0,i.jsx)(n.li,{children:"Add SSH keys: It is currently not possible to add SSH keys using the add_ssh_keys CLI command."}),"\n",(0,i.jsx)(n.li,{children:"Workflows: The CLI tool does not provide support for running workflows. By nature, workflows leverage running jobs concurrently on multiple machines allowing you to achieve faster, more complex builds. Because the CLI is only running on your machine, it can only run single jobs (which make up parts of a workflow)."}),"\n",(0,i.jsx)(n.li,{children:"Caching and online-only Commands: Caching is not currently supported in local jobs. When you have either a save_cache or restore_cache step in your config, circleci will skip them and display a warning. Furthermore, not all commands may work on your local machine as they do online. If a step is not available on a local build you will see an error in the console. For example, running a store_artifacts step locally will not upload artifacts and throw an error."}),"\n",(0,i.jsxs)(n.li,{children:["Environment variables: For security reasons, encrypted environment variables configured in the web application will not be imported into local builds. As an alternative, you can specify environment variables to the CLI with the -e flag. See the output of the following command for more information: ",(0,i.jsx)(n.code,{children:"circleci help build"}),". If you have multiple environment variables, you must use the flag for each variable, for example: ",(0,i.jsx)(n.code,{children:"circleci build -e VAR1=FOO -e VAR2=BAR"}),"."]}),"\n"]}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.h3,{id:"command-6-context-management",children:"Command 6: context management"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"create"}),": Create a new context"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"delete"}),": Delete the named context"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"list"}),": List all contexts"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"remove-secret"}),": Remove an environment variable from the named context"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"show"}),": Show a context with all its keys (values will be redacted!)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"store-secret"}),": Store a new environment variable in the named context"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:'The above list include "sub-commands" in the CLI, which would be executed like so:'}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'// Examples:\ncircleci context create github OrgName contextName\ncircleci context create contextName --org-id "your-org-id-here"\n\n// Command 2: list all contexts\ncircleci context list <vcs-type> <org-name> [flags]\n// Examples:\ncircleci context list bitbucket talkohavy --token 6802\n\n// Command 3: show context\ncircleci context show bitbucket talkohavy luckylove --token 6802\n\n// Command 4: store a new secret inside a context\ncircleci context store-secret <vcs-type> <org-name> <context-name> <secret name> [flags]\n// By hitting Enter, you\'ll be prompted with:\nEnter secret value and press enter:\n\n// Command 5: Remove secret from context\ncircleci context remove-secret <vcs-type> <org-name> <context-name> <secret name> [flags]\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"The command:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"circleci context create\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsx)(n.p,{children:"A"}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"16-skip-following-steps-inside-a-job",children:"16. Skip Following Steps Inside A Job"}),"\n",(0,i.jsx)(n.p,{children:"You can skip the following steps inside a job by using the command:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"circleci-agent step halt\n"})}),"\n",(0,i.jsx)(n.p,{children:"inside of an early step of a job.\nIt's best to wrap that command inside of a wrapper bash/sh file with extra logic of ifs and elses, and then execute that file from within the config.yml as one of the job's steps."}),"\n",(0,i.jsx)(n.p,{children:"\u2022 Usage Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'steps:\n  - run:\n      name: "Step 1: skip the following steps"\n      command: circleci-agent step halt\n'})}),"\n",(0,i.jsx)(n.p,{children:"Or a more complex one:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'steps:\n  - run:\n      name: "should skip 2e2e"\n      command: |\n        commit_message=$(git log -1 HEAD --pretty=format:%s)\n        echo $commit_message\n        if [[ $commit_message == *"skip-2e2e"* ]]; then\n          circleci-agent step halt\n        fi\n'})}),"\n",(0,i.jsx)(n.p,{children:'\u2022 Question: "Why not use exit 0 or exit 1?"'}),"\n",(0,i.jsx)(n.p,{children:'Good question! That\'s because "exit 1" would flag the step inside that job as "errored", and terminology-wise, that not the case. And with "exit 0" only halts the following lines inside a step from being executed, while the following step would be executed just fine. Also note, that "exit1" not only fails the step! It fails the job, and it fails the workflow (as it should!).'}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"16-manually-cancel-a-workflow",children:"16. Manually Cancel a Workflow"}),"\n",(0,i.jsx)(n.p,{children:"You can manually cancel a workflow in a way that would present so in the circleci UI."}),"\n",(0,i.jsxs)(n.p,{children:["This could be done by sending a ",(0,i.jsx)(n.code,{children:"cancel"})," command via a curl request of the following form:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'curl --request POST --url https://circleci.com/api/v2/workflow/$CIRCLE_WORKFLOW_ID/cancel --header "Circle-Token: ${MY_CIRCLE_TOKEN}"\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Notice the use of ",(0,i.jsx)(n.code,{children:"$CIRCLE_WORKFLOW_ID"}),", which is a built-in env variable that circleci injects (among other env vars), which helps us identify the workflow in progress, as well as providing means for authentication (our API token)."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'build:\n  steps:\n\xa0   - run:\n\xa0 \xa0 \xa0 \xa0 name: "Step 0.25: cancel the entire workflow"\n\xa0 \xa0 \xa0 \xa0 command: \'curl -X POST --url https://circleci.com/api/v2/workflow/$CIRCLE_WORKFLOW_ID/cancel -- "Circle-Token: ${MY_CIRCLE_TOKEN}"\'\ncircleci-agent step halt\n'})}),"\n",(0,i.jsx)(n.p,{children:"A few things to notice here:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:'We are using a token, created in the UI, under the "User Settings" menu, under "Person API Tokens".'}),"\n",(0,i.jsx)(n.li,{children:'We then copied the contents of said token, and created a context variable down at the UI, under the "Organization Settings" menu.'}),"\n",(0,i.jsx)(n.li,{children:'In order for the "build" job to recognize the token sitting inside the context, we gave it access to the context within the workflow.'}),"\n",(0,i.jsxs)(n.li,{children:["Canceling a workflow does not mean that the current job is going to halt, rather than continue to completion. That's why the command to ",(0,i.jsx)(n.code,{children:"cancel a workflow"})," and the command to ",(0,i.jsx)(n.code,{children:"halt a job"})," usually go together! That's why I always put them together. But if you find a reason to cancel a workflow, yet to run a job to its completion, then simply remove the ",(0,i.jsx)(n.code,{children:"halt a job"})," command."]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"17-caching",children:"17. Caching"}),"\n",(0,i.jsxs)(n.p,{children:["I just learned that you can use: ",(0,i.jsx)(n.code,{children:"{{ .Branch }}"})," inside the ",(0,i.jsx)(n.code,{children:"config.yml"})," to print out the current branch name that you are on. This is a circleci built-in env variable."]}),"\n",(0,i.jsx)(n.h3,{id:"-saving-cache",children:"\u2022 Saving Cache"}),"\n",(0,i.jsx)(n.p,{children:"To save a cache of a file or directory, add the save_cache step to a job in your .circleci/config.yml file:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"steps:\n  - save_cache:\n      key: my-cache\n      paths:\n        - my-file.txt\n        - my-project/my-dependencies-directory\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The path for directories is relative to the ",(0,i.jsx)(n.code,{children:"working_directory"})," of your job. You can specify an absolute path if you choose."]}),"\n",(0,i.jsx)(n.h3,{id:"-restoring-cache",children:"\u2022 Restoring Cache"}),"\n",(0,i.jsx)(n.p,{children:"CircleCI restores caches in the order of keys listed in the restore_cache step. Each cache key is namespaced to the project and retrieval is prefix-matched. The cache is restored from the first matching key. If there are multiple matches, the most recently generated cache is used."}),"\n",(0,i.jsx)(n.p,{children:"In the example below, two keys are provided"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'steps:\n  - restore_cache:\n      # name: Restore NPM Package Cache # <optional key>\n      keys:\n# Find a cache corresponding to this specific package-lock.json checksum\n# when this file is changed, this key will fail\n        - v1-npm-deps-{{ checksum "package-lock.json" }}\n        # Find the most recently generated cache used from any branch\n        - v1-npm-deps-\n'})}),"\n",(0,i.jsx)(n.p,{children:"Because the second key is less specific than the first, it is more likely there will be differences between the current state and the most recently generated cache. When a dependency tool runs, it would discover outdated dependencies and update them. This is referred to as a partial cache restore."}),"\n",(0,i.jsxs)(n.p,{children:["Each line in the keys: list manages one cache (each line does not correspond to its own cache). The list of keys (",(0,i.jsx)(n.code,{children:'v1-npm-deps-{{ checksum "package-lock.json" }}'})," and ",(0,i.jsx)(n.code,{children:"v1-npm-deps-"}),"), in this example, represent a single cache. When it is time to restore the cache, CircleCI first validates the cache based on the first (and most specific) key, and then steps through the other keys looking for any other cache key changes."]}),"\n",(0,i.jsxs)(n.p,{children:["The first key concatenates the checksum of package-lock.json file into the string ",(0,i.jsx)(n.code,{children:"v1-npm-deps-"}),". If this file changed in your commit, CircleCI would see a new cache key."]}),"\n",(0,i.jsxs)(n.p,{children:["The next key does not have a dynamic component to it. It is simply a static string: ",(0,i.jsx)(n.code,{children:"v1-npm-deps-"}),". If you would like to invalidate your cache manually, you can bump v1 to v2 in your .circleci/config.yml file. In this case, you would now have a new cache key v2-npm-deps, which triggers the storing of a new cache."]}),"\n",(0,i.jsx)(n.p,{children:"A full example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'#...\n      - restore_cache:\n          name: Restore NPM Package Cache\n          keys:\n            - npm-packages-{{ checksum "package-lock.lock" }}\n      - run:\n          name: Install Dependencies\n          command: npm install\n      - save_cache:\n          name: Save Npm Package Cache\n          key: yarn-packages-{{ checksum "package-lock.lock" }}\n          paths:\n            - .npm/cache\n            - .npm/unplugged\n#...\n'})}),"\n",(0,i.jsx)(n.p,{children:"Or..."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'restore_cache_and_install:\n\xa0   steps:\n\xa0   - run:\n\xa0 \xa0     name: "Step 1: enable corepack"\n\xa0 \xa0 \xa0 \xa0 command: sudo corepack enable\n\xa0 \xa0 - restore_cache:\n\xa0 \xa0 \xa0 \xa0 name: Restore pnpm cache folders\n\xa0 \xa0 \xa0 \xa0 keys:\n\xa0 \xa0 \xa0 \xa0 \xa0 - node-v2-{{ .Branch }}-{{ checksum "pnpm-lock.yaml" }}\n\xa0 \xa0 \xa0 \xa0 \xa0 - node-v2-{{ .Branch }}-\n\xa0 \xa0 \xa0 \xa0 \xa0 - node-v2-main-\n\xa0 \xa0 - run:\n\xa0 \xa0 \xa0 \xa0 name: "Step 2: Remove prepare script"\n\xa0 \xa0 \xa0 \xa0 command: npm pkg delete scripts.prepare\n\xa0 \xa0 - run:\n\xa0 \xa0 \xa0 \xa0 name: "Step 3: Install project dependencies"\n\xa0 \xa0 \xa0 \xa0 command: pnpm install --shamefully-hoist\n\n\xa0 save_cache_node_modules:\n\xa0 \xa0 steps:\n\xa0 \xa0 - save_cache:\n\xa0 \xa0 \xa0 \xa0 \xa0 name: "Step X: save cache folders"\n\xa0 \xa0 \xa0 \xa0 \xa0 key: node-v2-{{ .Branch }}-{{ checksum "pnpm-lock.yaml" }}\n\xa0 \xa0 \xa0 \xa0 \xa0 paths:\n\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 - ./node_modules\n\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 - ./projects/e2e/node_modules\n\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 - ./packages/api-server/node_modules\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"18-multi-line-run-command",children:"18. Multi-Line Run Command"}),"\n",(0,i.jsxs)(n.p,{children:["Each ",(0,i.jsx)(n.code,{children:"run"})," declaration represents a new shell. It is possible to specify a multi-line command, each line of which will be run in the same shell:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"- run:\n    command: |\n      echo Running test\n      mkdir -p /tmp/test-results\n      make test\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"19-the-when-attribute",children:"19. The When Attribute"}),"\n",(0,i.jsx)(n.p,{children:"By default, CircleCI will execute job steps one at a time, in the order that they are defined in config.yml, until a step fails (returns a non-zero exit code). After a command fails, no further job steps will be executed."}),"\n",(0,i.jsx)(n.p,{children:"Adding the when attribute to a job step allows you to override this default behavior, and selectively run or skip steps depending on the status of the job."}),"\n",(0,i.jsx)(n.h3,{id:"-value-1-on_success",children:"\u2022 Value 1: on_success"}),"\n",(0,i.jsx)(n.p,{children:"The default value of on_success means that the step will run only if all of the previous steps have been successful (returned exit code 0)."}),"\n",(0,i.jsx)(n.h3,{id:"-value-2-always",children:"\u2022 Value 2: always"}),"\n",(0,i.jsx)(n.p,{children:"A value of always means that the step will run regardless of the exit status of previous steps. This is useful if you have a task that you want to run regardless of whether the previous steps are successful or not. For example, you might have a job step that needs to upload logs or code-coverage data somewhere."}),"\n",(0,i.jsx)(n.h3,{id:"-value-3-on_fail",children:"\u2022 Value 3: on_fail"}),"\n",(0,i.jsx)(n.p,{children:"A value of on_fail means that the step will run only if one of the preceding steps has failed (returns a non-zero exit code). It is common to use on_fail if you want to store some diagnostic data to help debug test failures, or to run custom notifications about the failure, such as sending emails or triggering alerts in chat-rooms."}),"\n",(0,i.jsx)(n.h3,{id:"-specials-on_store_artifacts--store_test_results",children:"\u2022 Specials: on_store_artifacts & store_test_results"}),"\n",(0,i.jsx)(n.p,{children:"Note: Some steps, such as store_artifacts and store_test_results will always run, even if a step has failed (returned a non-zero exit code) previously. The when attribute, store_artifacts and store_test_results are not run if the job has been killed by a cancel request or has reached the runtime timeout limit."}),"\n",(0,i.jsx)(n.h2,{id:"20-the-when-step",children:"20. The When Step"}),"\n",(0,i.jsx)(n.p,{children:"Entirely different thing from the when attribute!!"}),"\n",(0,i.jsx)(n.p,{children:"Look at the structure:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'version: 2.1\n\njobs: # conditional steps may also be defined in `commands:`\n  job_with_optional_custom_checkout:\n    parameters:\n      custom_checkout:\n        type: string\n        default: ""\n    machine:\n      image: ubuntu-2004:202107-02\n    steps:\n      - when:\n          condition: <<parameters.custom_checkout>>\n          steps:\n            - run: echo "my custom checkout"\n      - unless:\n          condition: <<parameters.custom_checkout>>\n          steps:\n            - checkout\nworkflows:\n  build-test-deploy:\n    jobs:\n      - job_with_optional_custom_checkout:\n          custom_checkout: "any non-empty string is truthy"\n      - job_with_optional_custom_checkout\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"when"})," step is a conditional step which consists of a step with the key ",(0,i.jsx)(n.code,{children:"when"})," or ",(0,i.jsx)(n.code,{children:"unless"}),". Under the ",(0,i.jsx)(n.code,{children:"when"})," key are the (required!) sub-keys ",(0,i.jsx)(n.code,{children:"condition"})," and ",(0,i.jsx)(n.code,{children:"steps"}),". The purpose of the when step is customizing commands and job configuration to run on custom conditions (determined at config-compile time) that are checked before a workflow runs."]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},3546:(e,n,o)=>{o.d(n,{R:()=>a,x:()=>c});var s=o(9729);const i={},t=s.createContext(i);function a(e){const n=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);