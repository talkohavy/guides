"use strict";(self.webpackChunkdocusaurus_guides=self.webpackChunkdocusaurus_guides||[]).push([[1413],{3803:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"programming/tests/jest","title":"Jest","description":"1. Installation","source":"@site/docs/programming/tests/jest.md","sourceDirName":"programming/tests","slug":"/programming/tests/jest","permalink":"/guides/he/docs/programming/tests/jest","draft":false,"unlisted":false,"editUrl":"https://github.com/talkohavy/guides/docs/programming/tests/jest.md","tags":[],"version":"current","frontMatter":{},"sidebar":"mySidebar","previous":{"title":"- Tests","permalink":"/guides/he/docs/tests"},"next":{"title":"- Databases","permalink":"/guides/he/docs/db"}}');var o=t(6070),r=t(7010);const a={},i="Jest",c={},l=[{value:"1. Installation",id:"1-installation",level:2},{value:"2. Important to know CLI options",id:"2-important-to-know-cli-options",level:2},{value:"<code>--listTests</code>",id:"--listtests",level:3},{value:"<code>--config=&lt;path&gt;</code>",id:"--configpath",level:3},{value:"<code>--showConfig</code>",id:"--showconfig",level:3},{value:"<code>--passWithNoTests</code>",id:"--passwithnotests",level:3},{value:"<code>--runTestsByPath</code>",id:"--runtestsbypath",level:3},{value:"<code>--silent</code>",id:"--silent",level:3},{value:"<code>--verbose</code>",id:"--verbose",level:3},{value:"3. Catch a thrown Error",id:"3-catch-a-thrown-error",level:2},{value:"4. Testing Asynchronous Code",id:"4-testing-asynchronous-code",level:2},{value:"<code>resolves</code> &amp; <code>rejects</code>",id:"resolves--rejects",level:3},{value:"5. Mock Functions",id:"5-mock-functions",level:2},{value:"Scenario 1: Mock callback fn as argument using <code>jest.fn()</code>",id:"scenario-1-mock-callback-fn-as-argument-using-jestfn",level:3},{value:"Scenario 2: Mocking Modules with <code>jest.mock(...)</code>",id:"scenario-2-mocking-modules-with-jestmock",level:2},{value:"Why we need so many things?",id:"why-we-need-so-many-things",level:3},{value:"Scenario 3: Mocking Modules Partially",id:"scenario-3-mocking-modules-partially",level:2},{value:"Example 1: a named export",id:"example-1-a-named-export",level:3},{value:"Example 2: a default export",id:"example-2-a-default-export",level:3},{value:"Scenario 4: Mock Return Values Multiple Times",id:"scenario-4-mock-return-values-multiple-times",level:2}];function d(e){const n={admonition:"admonition",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"jest",children:"Jest"})}),"\n",(0,o.jsx)(n.h2,{id:"1-installation",children:"1. Installation"}),"\n",(0,o.jsx)(n.p,{children:"Add a script:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-json",children:'{\n  "scripts": {\n    "test": "jest"\n  }\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"Install these:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"pnpm add -D @testing-library/dom @testing-library/jest-dom @testing-library/react jest jest-environment-jsdom ts-jest\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Create a ",(0,o.jsx)(n.code,{children:"jest.config.js"})," file:",(0,o.jsx)(n.br,{}),"\n","(this file was generated using ",(0,o.jsx)(n.code,{children:"jest --init"}),")"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",metastring:"title=jest.config.js",children:'import requireJSON from \'json-easy-strip\';\nimport { createDefaultPreset } from \'ts-jest\';\nimport { pathsToModuleNameMapper } from \'ts-jest\';\nconst tsconfig = requireJSON(\'./tsconfig.json\');\n\n/**\n * @type {import(\'ts-jest\').JestConfigWithTsJest}\n */\nconst config = {\n  ...createDefaultPreset(),\n\n  // A preset that is used as a base for Jest\'s configuration\n  preset: \'ts-jest\',\n\n  // The test environment that will be used for testing\n  testEnvironment: \'jsdom\', // <--- IMPORTANT! must be \'jsdom\'. Option are: \'jsdom\' | \'node\'.\n\n  // A list of paths to modules that run some code to configure or set up the testing framework before each test\n  setupFilesAfterEnv: [\'<rootDir>/src/tests/setup.tsx\'],\n\n  // A map from regular expressions to module names or to arrays of module names that allow to stub out resources with a single module\n  moduleNameMapper: pathsToModuleNameMapper(tsconfig.compilerOptions.paths, {\n    prefix: \'<rootDir>/\',\n  }),\n\n  // A map from regular expressions to paths to transformers\n  transform: {\n    \'^.+.tsx?$\': [\'ts-jest\', {}],\n  },\n\n  // All imported modules in your tests should be mocked automatically\n  // automock: false,\n\n  // Stop running tests after `n` failures\n  // bail: 0,\n\n  // The directory where Jest should store its cached dependency information\n  // cacheDirectory: "/private/var/folders/yv/tfvrv22n3rn8g7_2dzx2n8lc0000gn/T/jest_dx",\n\n  // Automatically clear mock calls, instances, contexts and results before every test\n  // clearMocks: false,\n\n  // Indicates whether the coverage information should be collected while executing the test\n  // collectCoverage: false,\n\n  // An array of glob patterns indicating a set of files for which coverage information should be collected\n  // collectCoverageFrom: undefined,\n\n  // The directory where Jest should output its coverage files\n  // coverageDirectory: undefined,\n\n  // An array of regexp pattern strings used to skip coverage collection\n  // coveragePathIgnorePatterns: [\n  //   "/node_modules/"\n  // ],\n\n  // Indicates which provider should be used to instrument code for coverage\n  // coverageProvider: "babel",\n\n  // A list of reporter names that Jest uses when writing coverage reports\n  // coverageReporters: [\n  //   "json",\n  //   "text",\n  //   "lcov",\n  //   "clover"\n  // ],\n\n  // An object that configures minimum threshold enforcement for coverage results\n  // coverageThreshold: undefined,\n\n  // A path to a custom dependency extractor\n  // dependencyExtractor: undefined,\n\n  // Make calling deprecated APIs throw helpful error messages\n  // errorOnDeprecated: false,\n\n  // The default configuration for fake timers\n  // fakeTimers: {\n  //   "enableGlobally": false\n  // },\n\n  // Force coverage collection from ignored files using an array of glob patterns\n  // forceCoverageMatch: [],\n\n  // A path to a module which exports an async function that is triggered once before all test suites\n  // globalSetup: undefined,\n\n  // A path to a module which exports an async function that is triggered once after all test suites\n  // globalTeardown: undefined,\n\n  // A set of global variables that need to be available in all test environments\n  // globals: {},\n\n  // The maximum amount of workers used to run your tests. Can be specified as % or a number. E.g. maxWorkers: 10% will use 10% of your CPU amount + 1 as the maximum worker number. maxWorkers: 2 will use a maximum of 2 workers.\n  // maxWorkers: "50%",\n\n  // An array of directory names to be searched recursively up from the requiring module\'s location\n  // moduleDirectories: [\n  //   "node_modules"\n  // ],\n\n  // An array of file extensions your modules use\n  // moduleFileExtensions: [\n  //   "js",\n  //   "mjs",\n  //   "cjs",\n  //   "jsx",\n  //   "ts",\n  //   "tsx",\n  //   "json",\n  //   "node"\n  // ],\n\n  // An array of regexp pattern strings, matched against all module paths before considered \'visible\' to the module loader\n  // modulePathIgnorePatterns: [],\n\n  // Activates notifications for test results\n  // notify: false,\n\n  // An enum that specifies notification mode. Requires { notify: true }\n  // notifyMode: "failure-change",\n\n  // Run tests from one or more projects\n  // projects: undefined,\n\n  // Use this configuration option to add custom reporters to Jest\n  // reporters: undefined,\n\n  // Automatically reset mock state before every test\n  // resetMocks: false,\n\n  // Reset the module registry before running each individual test\n  // resetModules: false,\n\n  // A path to a custom resolver\n  // resolver: undefined,\n\n  // Automatically restore mock state and implementation before every test\n  // restoreMocks: false,\n\n  // The root directory that Jest should scan for tests and modules within\n  // rootDir: undefined,\n\n  // A list of paths to directories that Jest should use to search for files in\n  // roots: [\n  //   "<rootDir>"\n  // ],\n\n  // Allows you to use a custom runner instead of Jest\'s default test runner\n  // runner: "jest-runner",\n\n  // The paths to modules that run some code to configure or set up the testing environment before each test\n  // setupFiles: [],\n\n  // The number of seconds after which a test is considered as slow and reported as such in the results.\n  // slowTestThreshold: 5,\n\n  // A list of paths to snapshot serializer modules Jest should use for snapshot testing\n  // snapshotSerializers: [],\n\n  // Options that will be passed to the testEnvironment\n  // testEnvironmentOptions: {},\n\n  // Adds a location field to test results\n  // testLocationInResults: false,\n\n  // The glob patterns Jest uses to detect test files\n  // testMatch: [\n  //   "**/__tests__/**/*.[jt]s?(x)",\n  //   "**/?(*.)+(spec|test).[tj]s?(x)"\n  // ],\n\n  // An array of regexp pattern strings that are matched against all test paths, matched tests are skipped\n  // testPathIgnorePatterns: [\n  //   "/node_modules/"\n  // ],\n\n  // The regexp pattern or array of patterns that Jest uses to detect test files\n  // testRegex: [],\n\n  // This option allows the use of a custom results processor\n  // testResultsProcessor: undefined,\n\n  // This option allows use of a custom test runner\n  // testRunner: "jest-circus/runner",\n\n  // An array of regexp pattern strings that are matched against all source file paths, matched files will skip transformation\n  // transformIgnorePatterns: [\n  //   "/node_modules/",\n  //   "\\\\.pnp\\\\.[^\\\\/]+$"\n  // ],\n\n  // An array of regexp pattern strings that are matched against all modules before the module loader will automatically return a mock for them\n  // unmockedModulePathPatterns: undefined,\n\n  // Indicates whether each individual test should be reported during the run\n  // verbose: undefined,\n\n  // An array of regexp patterns that are matched against all source file paths before re-running tests in watch mode\n  // watchPathIgnorePatterns: [],\n\n  // Whether to use watchman for file crawling\n  // watchman: true,\n};\n\nexport default config;\n'})}),"\n",(0,o.jsxs)(n.p,{children:["There are many ways to configure jest, ",(0,o.jsxs)(n.strong,{children:["we are using ",(0,o.jsx)(n.code,{children:"ts-jest"})]}),"."]}),"\n",(0,o.jsx)(n.p,{children:"Other ways are:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Babel"}),"\n",(0,o.jsx)(n.li,{children:"webpack"}),"\n",(0,o.jsx)(n.li,{children:"Vite (Jest is not fully supported by vite)"}),"\n",(0,o.jsx)(n.li,{children:"Parcel"}),"\n",(0,o.jsxs)(n.li,{children:["TypeScript (through ",(0,o.jsx)(n.code,{children:"ts-jest"}),")"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"2-important-to-know-cli-options",children:"2. Important to know CLI options"}),"\n",(0,o.jsx)(n.h3,{id:"--listtests",children:(0,o.jsx)(n.code,{children:"--listTests"})}),"\n",(0,o.jsx)(n.p,{children:"Lists all test files that Jest will run given the arguments, and exits."}),"\n",(0,o.jsx)(n.h3,{id:"--configpath",children:(0,o.jsx)(n.code,{children:"--config=<path>"})}),"\n",(0,o.jsxs)(n.p,{children:["Alias: ",(0,o.jsx)(n.code,{children:"-c"}),". The path to a Jest config file specifying how to find and execute tests. If no ",(0,o.jsx)(n.code,{children:"rootDir"})," is set in the config, the directory containing the config file is assumed to be the ",(0,o.jsx)(n.code,{children:"rootDir"})," for the project. This can also be a JSON-encoded value which Jest will use as configuration."]}),"\n",(0,o.jsx)(n.h3,{id:"--showconfig",children:(0,o.jsx)(n.code,{children:"--showConfig"})}),"\n",(0,o.jsx)(n.p,{children:"Print your Jest config and then exits."}),"\n",(0,o.jsx)(n.h3,{id:"--passwithnotests",children:(0,o.jsx)(n.code,{children:"--passWithNoTests"})}),"\n",(0,o.jsx)(n.p,{children:"Allows the test suite to pass when no files are found."}),"\n",(0,o.jsx)(n.h3,{id:"--runtestsbypath",children:(0,o.jsx)(n.code,{children:"--runTestsByPath"})}),"\n",(0,o.jsx)(n.p,{children:"Run only the tests that were specified with their exact paths. This avoids converting them into a regular expression and matching it against every single file."}),"\n",(0,o.jsx)(n.p,{children:"For example, given the following file structure:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"__tests__\n\u2514\u2500\u2500 t1.test.js # test\n\u2514\u2500\u2500 t2.test.js # test\n"})}),"\n",(0,o.jsx)(n.p,{children:"When ran with a pattern, no test is found:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"jest --runTestsByPath __tests__/t\n"})}),"\n",(0,o.jsx)(n.p,{children:"Output:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"No tests found\n"})}),"\n",(0,o.jsx)(n.p,{children:"However, passing an exact path will execute only the given test:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"jest --runTestsByPath __tests__/t1.test.js\n"})}),"\n",(0,o.jsx)(n.h3,{id:"--silent",children:(0,o.jsx)(n.code,{children:"--silent"})}),"\n",(0,o.jsx)(n.p,{children:"Prevent tests from printing messages through the console."}),"\n",(0,o.jsx)(n.h3,{id:"--verbose",children:(0,o.jsx)(n.code,{children:"--verbose"})}),"\n",(0,o.jsx)(n.p,{children:"Display individual test results with the test suite hierarchy."}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"3-catch-a-thrown-error",children:"3. Catch a thrown Error"}),"\n",(0,o.jsxs)(n.p,{children:["If you want to test whether a particular function throws an error when it's called, use ",(0,o.jsx)(n.code,{children:"toThrow"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"function compileAndroidCode() {\n  throw new Error('you are using the wrong JDK!');\n}\n\ntest('compiling android goes as expected', () => {\n  expect(() => compileAndroidCode()).toThrow();\n  expect(() => compileAndroidCode()).toThrow(Error);\n\n  // You can also use a string that must be contained in the error message or a regexp\n  expect(() => compileAndroidCode()).toThrow('you are using the wrong JDK');\n  expect(() => compileAndroidCode()).toThrow(/JDK/);\n\n  // Or you can match an exact error message using a regexp like below\n  expect(() => compileAndroidCode()).toThrow(/^you are using the wrong JDK$/); // Test fails\n  expect(() => compileAndroidCode()).toThrow(/^you are using the wrong JDK!$/); // Test pass\n});\n"})}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"4-testing-asynchronous-code",children:"4. Testing Asynchronous Code"}),"\n",(0,o.jsx)(n.p,{children:"Jest needs to know when the code it is testing has completed before it can move on to another test. Jest has several ways to handle this."}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Promises"}),": Return a promise from your test, and Jest will wait for that promise to resolve. If the promise is rejected, the test will fail."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Async/Await"}),": Make your test ",(0,o.jsx)(n.code,{children:"async"})," and use the ",(0,o.jsx)(n.code,{children:"await"})," keyword inside."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"These two tests are equal:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"test('the data is peanut butter', async () => {\n  const data = await fetchData();\n  expect(data).toBe('peanut butter');\n});\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"test('the data is peanut butter', () => {\n  return fetchData().then(data => {\n    expect(data).toBe('peanut butter');\n  });\n});\n"})}),"\n",(0,o.jsxs)(n.h3,{id:"resolves--rejects",children:[(0,o.jsx)(n.code,{children:"resolves"})," & ",(0,o.jsx)(n.code,{children:"rejects"})]}),"\n",(0,o.jsxs)(n.p,{children:["You can combine async and await with ",(0,o.jsx)(n.code,{children:".resolves"})," or ",(0,o.jsx)(n.code,{children:".rejects"}),".\nFor that to work ",(0,o.jsx)(n.strong,{children:"you need to pass a promise"})," to the ",(0,o.jsx)(n.code,{children:"expect"}),", and add an await keyword before the ",(0,o.jsx)(n.code,{children:"expect"}),". Jest will wait for that promise to either resolve or reject (depending)and if the promise is rejected when it should be resolved, or vice versa, the test will fail."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"test('the data is peanut butter', async () => {\n  await expect(fetchData()).resolves.toBe('peanut butter');\n});\n\ntest('the fetch fails with an error', async () => {\n  await expect(fetchData()).rejects.toMatch('error');\n});\n"})}),"\n",(0,o.jsxs)(n.admonition,{type:"danger",children:[(0,o.jsxs)(n.p,{children:["Be sure to return (or ",(0,o.jsx)(n.code,{children:"await"}),") the promise - if you omit the ",(0,o.jsx)(n.code,{children:"return"}),"/",(0,o.jsx)(n.code,{children:"await"})," statement, your test will complete before the promise returned from ",(0,o.jsx)(n.code,{children:"fetchData"})," resolves or rejects."]}),(0,o.jsx)(n.p,{children:"For example,"}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"async function fetchData() {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(1);\n    }, 1000);\n  });\n}\n\ntest('1 equals 2', () => {\n  fetchData().then((data) => {\n    expect(data).toBe(2);\n  });\n});\n"})}),(0,o.jsxs)(n.p,{children:["The above test will PASS, but ",(0,o.jsx)(n.strong,{children:"it should NOT PASS"}),"!"]})]}),"\n",(0,o.jsx)(n.h2,{id:"5-mock-functions",children:"5. Mock Functions"}),"\n",(0,o.jsx)(n.p,{children:"Here are all the possible scenarios you might have:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["You wanna test function A. Function A ",(0,o.jsx)(n.strong,{children:"accepts"})," callback function as one of its parameters."]}),"\n",(0,o.jsxs)(n.li,{children:["You wanna test function A. Function A ",(0,o.jsx)(n.strong,{children:"uses"})," another function B. Function A ",(0,o.jsx)(n.strong,{children:"imports"})," function B from a different file."]}),"\n",(0,o.jsxs)(n.li,{children:["You wanna test function A. Function A ",(0,o.jsx)(n.strong,{children:"uses"})," another function B. Functions A and B both live on the same file."]}),"\n",(0,o.jsxs)(n.li,{children:["You wanna test function A. Function A ",(0,o.jsx)(n.strong,{children:"uses"})," another function B. You need to mock the returned value with different values at each time."]}),"\n"]}),"\n",(0,o.jsxs)(n.h3,{id:"scenario-1-mock-callback-fn-as-argument-using-jestfn",children:["Scenario 1: Mock callback fn as argument using ",(0,o.jsx)(n.code,{children:"jest.fn()"})]}),"\n",(0,o.jsxs)(n.p,{children:["You wanna test function A. Function A ",(0,o.jsx)(n.strong,{children:"accepts"})," callback function as one of its parameters."]}),"\n",(0,o.jsxs)(n.p,{children:["Below we will see a function called ",(0,o.jsx)(n.code,{children:"forEach"})," that we want to test.",(0,o.jsx)(n.br,{}),"\n",(0,o.jsx)(n.code,{children:"forEach"})," accepts ",(0,o.jsx)(n.code,{children:"callback"})," as a parameter, ad calls it inside for each item under the items array."]}),"\n",(0,o.jsx)(n.p,{children:"Let's say that our goal is to write a test that:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["checks how many times ",(0,o.jsx)(n.code,{children:"mockCallback"})," has been called."]}),"\n",(0,o.jsx)(n.li,{children:"checks the first argument of the first and second calls were as expected."}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"What are the steps to achieve this goal?"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["We will use ",(0,o.jsx)(n.code,{children:"jest.fn()"})," to create a ",(0,o.jsx)(n.code,{children:"mockCallback"})," const."]}),"\n",(0,o.jsxs)(n.li,{children:["We will pass ",(0,o.jsx)(n.code,{children:"mockCallback"})," as the argument to our tested function (forEach)."]}),"\n",(0,o.jsxs)(n.li,{children:["We will inspect the ",(0,o.jsx)(n.code,{children:"mock"})," property of ",(0,o.jsx)(n.code,{children:"mockCallback"})," (more specifically the ",(0,o.jsx)(n.code,{children:"mockCallback.mock.calls"})," sub-property)."]}),"\n",(0,o.jsxs)(n.li,{children:["Use plain matchers such as ",(0,o.jsx)(n.code,{children:"toBe"})," or ",(0,o.jsx)(n.code,{children:"toHaveLength"}),"."]}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"export function forEach(items, callback) {\n  for (const item of items) {\n    callback(item);\n  }\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"We will write the test as such:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import { forEach } from './forEach';\n\nconst mockCallback = jest.fn();\n\ntest('forEach mock function', () => {\n  const items = [0, 1];\n  forEach(items, mockCallback);\n\n  // The mock function was called al least once\n  expect(mockCallback.mock.calls.length).toBeGreaterThan(0);\n\n  // The mock function was called exactly twice\n  expect(mockCallback.mock.calls).toHaveLength(2);\n\n  // The first argument of the first call to the function was 0\n  expect(mockCallback.mock.calls[0][0]).toBe(0);\n\n  // The first argument of the second call to the function was 1\n  expect(mockCallback.mock.calls[1][0]).toBe(1);\n});\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Instead of using the ",(0,o.jsx)(n.code,{children:".mock"})," property directly, jest had created a syntactic sugar around it for every operation and check we might need. So we will not be writing test as above."]}),"\n",(0,o.jsx)(n.p,{children:"A better way to write it is:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import { forEach } from './forEach';\n\nconst mockCallback = jest.fn();\n\ntest('forEach mock function', () => {\n  const items = [0, 1];\n  forEach(items, mockCallback);\n\n  // The mock function was called al least once\n  // diff-remove-next-line\n  expect(mockCallback.mock.calls.length).toBeGreaterThan(0);\n  // diff-add-next-line\n  expect(mockCallback).toHaveBeenCalled();\n\n  // The mock function was called exactly twice\n  // diff-remove-next-line\n  expect(mockCallback.mock.calls).toHaveLength(2);\n  // diff-add-next-line\n  expect(mockCallback).toHaveBeenCalledTimes(2);\n\n  // The first argument of the first call to the function was 0\n  // diff-remove-next-line\n  expect(mockCallback.mock.calls[0][0]).toBe(0);\n  // diff-add-next-line\n  expect(mockCallback).toHaveBeenNthCalledWith(1, 0);\n\n  // The first argument of the second call to the function was 1\n  // diff-remove-next-line\n  expect(mockCallback.mock.calls[1][0]).toBe(1);\n  // diff-add-next-line\n  expect(mockCallback).toHaveBeenNthCalledWith(2, 1);\n});\n"})}),"\n",(0,o.jsx)("br",{}),"\n",(0,o.jsxs)(n.h2,{id:"scenario-2-mocking-modules-with-jestmock",children:["Scenario 2: Mocking Modules with ",(0,o.jsx)(n.code,{children:"jest.mock(...)"})]}),"\n",(0,o.jsxs)(n.p,{children:["You wanna test function A. Function A ",(0,o.jsx)(n.strong,{children:"uses"})," another function B. Function A ",(0,o.jsx)(n.strong,{children:"imports"})," function B from a different file."]}),"\n",(0,o.jsxs)(n.p,{children:["Below we will see a class called ",(0,o.jsx)(n.code,{children:"Users"})," with a method called ",(0,o.jsx)(n.code,{children:"findMany"})," which we want to test.",(0,o.jsx)(n.br,{}),"\n",(0,o.jsx)(n.code,{children:"Users"})," calls ",(0,o.jsx)(n.code,{children:"axios"}),", an imported module, under the hood to send all of its async api requests. The ",(0,o.jsx)(n.code,{children:"findMany"})," method specifically calls ",(0,o.jsx)(n.code,{children:"axios.get"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"Let's say that our goal is to write a test that:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["checks that ",(0,o.jsx)(n.code,{children:"axios.get"})," had been called at least once."]}),"\n",(0,o.jsx)(n.li,{children:"checks that the headers (a property under the second argument) were created as expected."}),"\n",(0,o.jsx)(n.li,{children:"mock the response value so that the test won't crash"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"What are the steps to achieve this goal?"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["We will use ",(0,o.jsx)(n.code,{children:"jest.mock()"})," to tell just which module to mock."]}),"\n",(0,o.jsx)(n.li,{children:"Import the real module into our test. This will give us 100% control (we'll see what it means soon)."}),"\n",(0,o.jsxs)(n.li,{children:["We will mock wanted methods on axios (i.e. ",(0,o.jsx)(n.code,{children:"get"}),")."]}),"\n",(0,o.jsxs)(n.li,{children:["We would use matchers like ",(0,o.jsx)(n.code,{children:".haveBeenCalledOnce"})," and such on those mocked methods."]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["Here is the ",(0,o.jsx)(n.code,{children:"Users"})," class, which we want to test:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import axios from 'axios';\n\ntype Filters = {\n  nameStartsWith: string;\n  ageGreaterThan: number;\n};\n\nexport class Users {\n  static async findMany(filters?: Filters) {\n    const updatedFilters: Filters = {\n      ageGreaterThan: filters?.ageGreaterThan ?? 0,\n      nameStartsWith: filters?.nameStartsWith ?? 't',\n    };\n\n    const response = await axios.get('/users.json', {\n      headers: {\n        'x-filter-name': updatedFilters.nameStartsWith,\n        'x-filter-age': updatedFilters.ageGreaterThan,\n      },\n    });\n\n    const { data } = response;\n\n    return data;\n  }\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"why-we-need-so-many-things",children:"Why we need so many things?"}),"\n",(0,o.jsxs)(n.p,{children:["First, let's explain why we need so many things. Like, why we need to write ",(0,o.jsx)(n.code,{children:"jest.mock"}),", but also import the actual module to be mocked."]}),"\n",(0,o.jsx)(n.p,{children:"Here's a test template:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import Users from './users';\n\ntest('should fetch users', async () => {\n  const data = await Users.findMany();\n\n  // ???\n});\n"})}),"\n",(0,o.jsxs)(n.p,{children:["We are calling ",(0,o.jsx)(n.code,{children:"Users.findMany()"}),", which under the hood calls ",(0,o.jsx)(n.code,{children:"axios"}),".",(0,o.jsx)(n.br,{}),"\n",(0,o.jsx)(n.code,{children:"axios"})," needs to be mocked."]}),"\n",(0,o.jsxs)(n.p,{children:["We start by adding ",(0,o.jsx)(n.code,{children:"jest.mock"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import Users from './users';\n\njest.mock('axios');\n\n// ...\n"})}),"\n",(0,o.jsxs)(n.p,{children:["What this will do is ",(0,o.jsx)(n.strong,{children:"it will mock any import of the axios module"}),", and wrap it around some ",(0,o.jsx)(n.code,{children:"jest"})," function."]}),"\n",(0,o.jsxs)(n.p,{children:["The problem with the code above is the return value. ",(0,o.jsx)(n.code,{children:"Users.findMany()"})," calls ",(0,o.jsx)(n.code,{children:"axios.get()"}),", and expects it to return some data. If it won't return the same data structure, ",(0,o.jsx)(n.strong,{children:"the code will crash"}),". We now need a way to alter the return value of ",(0,o.jsx)(n.code,{children:"axios.get()"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["What we can do is this (",(0,o.jsx)(n.em,{children:"not recommended"}),"):"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import { Users } from './users';\n\njest.mock('axios', () => {\n  return {\n    get: jest.fn(() => ({ data: { age: 5 } })),\n  };\n});\n\ntest('should fetch users', async () => {\n  const data = await Users.findMany();\n\n  expect(data.age).toBe(5);\n});\n"})}),"\n",(0,o.jsxs)(n.p,{children:["While this works, we are still missing something.",(0,o.jsx)(n.br,{}),"\n","What we wanna do is be able to ask questions like:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["How many times it has ",(0,o.jsx)(n.code,{children:"get"})," been called?"]}),"\n",(0,o.jsxs)(n.li,{children:["What were the arguments ",(0,o.jsx)(n.code,{children:"get"})," was called with?"]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["We don't have access to the ",(0,o.jsx)(n.code,{children:"get"})," function (yet!). To get it, we need to import axios ",(0,o.jsx)(n.strong,{children:"INSIDE"})," our test!"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",metastring:"showLineNumbers",children:"import axios from 'axios';\nimport { Users } from './users';\n\nconsole.log('axios is:', axios);\n\njest.mock('axios', () => {\n  return {\n    get: jest.fn(() => ({ data: { age: 5 } })),\n  };\n});\n"})}),"\n",(0,o.jsxs)(n.p,{children:["In the above code, if we were to put breakpoints in lines 4 and 6, line 6 would be hit first! ",(0,o.jsx)(n.code,{children:"jest.mock()"})," is hoisted all the way to the top! Before any of the imports occur. This guarantees that the import of ",(0,o.jsx)(n.code,{children:"axios"})," inside our test will be of the ",(0,o.jsx)(n.strong,{children:"mocked axios"}),", and not the ",(0,o.jsx)(n.strong,{children:"real axios"}),". This now gives us the ability to ask questions about ",(0,o.jsx)(n.code,{children:"axios.get"})," inside of tests:"]}),"\n",(0,o.jsxs)(n.p,{children:["With adding the import ",(0,o.jsx)(n.code,{children:"axios"})," statement, the test file will look like this:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import axios from 'axios';\nimport { Users } from './users';\n\njest.mock('axios', () => {\n  return {\n    get: jest.fn(() => ({ data: { age: 5 } })),\n  };\n});\n\ntest('should fetch users', async () => {\n  const data = await Users.findMany();\n\n  expect(axios.get).toHaveBeenCalled();\n  expect(axios.get).toHaveBeenCalledWith('/users.json', {\n    headers: { 'x-filter-name': 't', 'x-filter-age': 0 },\n  });\n  expect(data.age).toBe(5);\n});\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The above code is great, but there's one thing to note about it - the implementation mock that is provided as the second argument to ",(0,o.jsx)(n.code,{children:"jest.mock"})," will ",(0,o.jsx)(n.strong,{children:"stay the same for every test in that file"}),". Well, but what if we want to have flexibility over different test?"]}),"\n",(0,o.jsx)(n.p,{children:"What we can do is to not provide a mock implementation as the second argument, and have each test define it on the fly for its own use."}),"\n",(0,o.jsx)(n.p,{children:"Like so:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import axios from 'axios';\nimport { Users } from './users';\n\njest.mock('axios');\n\ntest('should fetch users', async () => {\n  const data = await Users.findMany();\n\n  expect(axios.get).toHaveBeenCalled();\n  expect(axios.get).toHaveBeenCalledWith('/users.json', {\n    headers: { 'x-filter-name': 't', 'x-filter-age': 0 },\n  });\n  expect(data.age).toBe(5);\n});\n"})}),"\n",(0,o.jsxs)(n.p,{children:["You're probably seeing that ",(0,o.jsx)(n.strong,{children:"typescript error"})," under ",(0,o.jsx)(n.code,{children:"mockResolvedValue"}),". Your IDE thinks it's the real ",(0,o.jsx)(n.code,{children:"axios"}),", and that ",(0,o.jsx)(n.code,{children:"axios.get"})," has no property of ",(0,o.jsx)(n.code,{children:"mockResolvedValue"})," on it. We need to tell it that ",(0,o.jsx)(n.code,{children:"axios.get"})," is a ",(0,o.jsx)(n.code,{children:"jest.fn"})," type:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import axios from 'axios';\nimport { Users } from './users';\n\njest.mock('axios');\n\ntest('should fetch users', async () => {\n  (axios.get as jest.Mock).mockResolvedValue({ data: { age: 5 } });\n  // Would also work: (axios.get as jest.Mock).mockReturnValue({ data: { age: 5 } });\n\n  const data = await Users.findMany();\n\n  expect(axios.get).toHaveBeenCalled();\n  expect(axios.get).toHaveBeenCalledWith('/users.json', {\n    headers: { 'x-filter-name': 't', 'x-filter-age': 0 },\n  });\n  expect(data.age).toBe(5);\n});\n"})}),"\n",(0,o.jsx)("br",{}),"\n",(0,o.jsx)(n.h2,{id:"scenario-3-mocking-modules-partially",children:"Scenario 3: Mocking Modules Partially"}),"\n",(0,o.jsxs)(n.p,{children:["You wanna test function A. Function A ",(0,o.jsx)(n.strong,{children:"uses"})," another function B. Functions A and B both live on the same file."]}),"\n",(0,o.jsx)(n.p,{children:"Steps to achieve this goal:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["We will again use ",(0,o.jsx)(n.code,{children:"jest.mock"})]}),"\n",(0,o.jsxs)(n.li,{children:["We will pass it a ",(0,o.jsx)(n.strong,{children:"mock implementation"})," of the module as the seconds argument"]}),"\n",(0,o.jsxs)(n.li,{children:["Inside the mock implementation:","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["We will use ",(0,o.jsx)(n.code,{children:"jest.requireActual('path')"}),", which is a special jest function that allows us to import the real module."]}),"\n",(0,o.jsxs)(n.li,{children:["We will return an object, where inside it:","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["We will spread ",(0,o.jsx)(n.code,{children:"jest.requireActual('path')"}),". Those will be all the parts of the module we want as unmocked."]}),"\n",(0,o.jsx)(n.li,{children:"Below the spread, we will override the parts we want to mock."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["If you need to import the module as ",(0,o.jsx)(n.strong,{children:"default"}),", the return object of the mock implementation MUST contain the special key of ",(0,o.jsx)(n.code,{children:"__esModule: true,"}),"."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"example-1-a-named-export",children:"Example 1: a named export"}),"\n",(0,o.jsx)(n.p,{children:"We have this file:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"export const namedExportVariable = 'named export variable';\nexport function namedExportFunction() {\n  return 'named export function';\n};\n\nexport default () => 'export default function';\n"})}),"\n",(0,o.jsxs)(n.p,{children:["If we only want to mock ",(0,o.jsx)(n.code,{children:"namedExportFunction"}),", then our test file should be:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import { namedExportFunction, namedExportVariable } from './foo-bar-baz';\n\njest.mock('./foo-bar-baz', () => {\n  const originalModule = jest.requireActual('./foo-bar-baz');\n\n  return {\n    ...originalModule,\n    namedExportFunction: jest.fn(() => 'mocked named export function'),\n  };\n});\n\ntest('should do a partial mock', () => {\n  // The mocked parts:\n  const namedExportFunctionResult = namedExportFunction();\n  expect(namedExportFunction).toHaveBeenCalled();\n  expect(namedExportFunctionResult).toBe('mocked named export function');\n\n  // The unmocked parts:\n  expect(namedExportVariable).toBe('named export variable');\n});\n"})}),"\n",(0,o.jsx)(n.h3,{id:"example-2-a-default-export",children:"Example 2: a default export"}),"\n",(0,o.jsxs)(n.p,{children:["If you need to either ",(0,o.jsx)(n.strong,{children:"mock a default export"})," object, or ",(0,o.jsx)(n.strong,{children:"import a default export"})," object, you'll need to use the special keyword of ",(0,o.jsx)(n.code,{children:"__esModule: true,"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["For example, here's the test file when mocking the ",(0,o.jsx)(n.code,{children:"export default"})," object:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import defaultExportFunction, { namedExportVariable } from './foo-bar-baz';\n\njest.mock('./foo-bar-baz', () => {\n  const originalModule = jest.requireActual('./foo-bar-baz');\n\n  return {\n    __esModule: true,\n    ...originalModule,\n    default: jest.fn(() => 'mocked export default function'),\n  };\n});\n\ntest('should do a partial mock', () => {\n  // The mocked parts:\n  const defaultExportFunctionResult = defaultExportFunction();\n  expect(defaultExportFunction).toHaveBeenCalled();\n  expect(defaultExportFunctionResult).toBe('mocked export default function');\n\n  // The unmocked parts:\n  expect(namedExportVariable).toBe('named export variable');\n});\n"})}),"\n",(0,o.jsxs)(n.p,{children:["And here's the test file when only using the ",(0,o.jsx)(n.code,{children:"export default"})," object, and mocking another named part of the module:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import defaultExportFunction, { namedExportVariable } from './foo-bar-baz';\n\njest.mock('./foo-bar-baz', () => {\n  const originalModule = jest.requireActual('./foo-bar-baz');\n\n  return {\n    __esModule: true,\n    ...originalModule,\n    namedExportVariable: 'mocked named export variable',\n  };\n});\n\ntest('should do a partial mock', () => {\n  // The mocked parts:\n  expect(namedExportVariable).toBe('mocked named export variable');\n\n  // The unmocked parts:\n  const defaultExportFunctionResult = defaultExportFunction();\n  expect(defaultExportFunctionResult).toBe('export default function');\n});\n"})}),"\n",(0,o.jsxs)(n.p,{children:["In both cases, omitting the ",(0,o.jsx)(n.code,{children:"__esModule: true"})," would cause the tests to fail."]}),"\n",(0,o.jsx)("br",{}),"\n",(0,o.jsx)(n.h2,{id:"scenario-4-mock-return-values-multiple-times",children:"Scenario 4: Mock Return Values Multiple Times"}),"\n",(0,o.jsxs)(n.p,{children:["You wanna test function A. Function A ",(0,o.jsx)(n.strong,{children:"uses"})," another function B. You need to mock the returned value with different values at each time."]}),"\n",(0,o.jsxs)(n.p,{children:["When you need to recreate a complex behavior of a mock function such that multiple function calls produce different results, use the ",(0,o.jsx)(n.code,{children:"mockImplementationOnce"})," method. When the mocked function runs out of implementations defined with ",(0,o.jsx)(n.code,{children:"mockImplementationOnce"}),", it will execute the default implementation set with:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"mockImplementation"})," - first priority! (if defined)"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"jest.fn"})," - second priority (if defined)"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Look at the following example:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"test('should do a partial mock', () => {\n  const myMockFn = jest\n    .fn(() => 1)\n    .mockImplementation(() => 3);\n    .mockImplementationOnce(() => 10)\n    .mockImplementationOnce(() => 42)\n\n  console.log(myMockFn()); // 10\n  console.log(myMockFn()); // 42\n  console.log(myMockFn()); // 3\n  console.log(myMockFn()); // 3\n  console.log(myMockFn()); // 3\n\n  expect(1).toBe(1);\n});\n"})}),"\n",(0,o.jsx)(n.p,{children:"The output would be:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"10\n42\n3\n3\n3\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Notice how ",(0,o.jsx)(n.code,{children:"1"})," is never printed."]}),"\n",(0,o.jsxs)(n.p,{children:["It's worth noting that the order of appearance of ",(0,o.jsx)(n.code,{children:"mockImplementationOnce"})," matters, but when ",(0,o.jsx)(n.code,{children:"mockImplementation"})," appears doesn't matter.",(0,o.jsx)(n.br,{}),"\n","For example:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"// This:\nconst myMockFn = jest\n  .fn()\n  .mockImplementation(() => 3);\n  .mockImplementationOnce(() => 10)\n  .mockImplementationOnce(() => 42)\n\n// is exactly the same as this:\nconst myMockFn = jest\n  .fn()\n  .mockImplementationOnce(() => 10)\n  .mockImplementationOnce(() => 42)\n  .mockImplementation(() => 3);\n\n// and also the same as this:\nconst myMockFn = jest\n  .fn(() => 3)\n  .mockImplementationOnce(() => 10)\n  .mockImplementationOnce(() => 42);\n"})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},7010:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>i});var s=t(758);const o={},r=s.createContext(o);function a(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);