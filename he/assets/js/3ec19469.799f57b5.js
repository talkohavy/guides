"use strict";(self.webpackChunkdocusaurus_guides=self.webpackChunkdocusaurus_guides||[]).push([[1647],{5693:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"programming/socket-io/connection-state-recovery","title":"Connection state recovery","description":"Connection state recovery is a feature which allows restoring a client\'s state after a temporary disconnection, including any missed packets.","source":"@site/docs/programming/socket-io/connection-state-recovery.md","sourceDirName":"programming/socket-io","slug":"/programming/socket-io/connection-state-recovery","permalink":"/guides/he/docs/programming/socket-io/connection-state-recovery","draft":false,"unlisted":false,"editUrl":"https://github.com/talkohavy/guides/docs/programming/socket-io/connection-state-recovery.md","tags":[],"version":"current","frontMatter":{},"sidebar":"mySidebar","previous":{"title":"- Handle Disconnects","permalink":"/guides/he/docs/programming/socket-io/handle-disconnects"},"next":{"title":"- Rooms","permalink":"/guides/he/docs/programming/socket-io/rooms"}}');var i=t(5813),o=t(3546);const r={},c="Connection state recovery",d={},a=[{value:"Disclaimer",id:"disclaimer",level:2},{value:"Usage",id:"usage",level:2},{value:"Compatibility with existing adapters",id:"compatibility-with-existing-adapters",level:2},{value:"How it works under the hood",id:"how-it-works-under-the-hood",level:2}];function l(e){const n={admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"connection-state-recovery",children:"Connection state recovery"})}),"\n",(0,i.jsx)(n.p,{children:"Connection state recovery is a feature which allows restoring a client's state after a temporary disconnection, including any missed packets."}),"\n",(0,i.jsx)(n.h2,{id:"disclaimer",children:"Disclaimer"}),"\n",(0,i.jsx)(n.p,{children:"Under real conditions, a Socket.IO client will inevitably experience temporary disconnections, regardless of the quality of the connection."}),"\n",(0,i.jsxs)(n.p,{children:["This feature will help you cope with such disconnections, but unless you want to store the packets and the sessions forever (by setting ",(0,i.jsx)(n.code,{children:"maxDisconnectionDuration"})," to ",(0,i.jsx)(n.code,{children:"Infinity"}),"), you can't be assured that the recovery will always be successful."]}),"\n",(0,i.jsx)(n.p,{children:"That's why you will still need to handle the case where the states of the client and the server must be synchronized."}),"\n",(0,i.jsx)(n.h2,{id:"usage",children:"Usage"}),"\n",(0,i.jsxs)(n.p,{children:["Connection state recovery ",(0,i.jsx)(n.strong,{children:"must be enabled by the server"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"const io = new Server(httpServer, {\n  connectionStateRecovery: {\n    // the backup duration of the sessions and the packets\n    maxDisconnectionDuration: 2 * 60 * 1000,\n    // whether to skip middlewares upon successful recovery\n    skipMiddlewares: true,\n  }\n});\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Upon an unexpected disconnection (i.e. no manual disconnection with ",(0,i.jsx)(n.code,{children:"socket.disconnect()"}),"), the server will store the ",(0,i.jsx)(n.code,{children:"id"}),", the rooms and the ",(0,i.jsx)(n.code,{children:"data"})," attribute of the socket."]}),"\n",(0,i.jsxs)(n.p,{children:["Then upon reconnection, the server will try to restore the state of the client. The ",(0,i.jsx)(n.code,{children:"recovered"})," attribute indicates whether this recovery was successful:"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"Server"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'io.on("connection", (socket) => {\n  if (socket.recovered) {\n    // recovery was successful: socket.id, socket.rooms and socket.data were restored\n  } else {\n    // new or unrecoverable session\n  }\n});\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"Client"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'socket.on("connect", () => {\n  if (socket.recovered) {\n    // any event missed during the disconnection period will be received now\n  } else {\n    // new or unrecoverable session\n  }\n});\n'})}),"\n",(0,i.jsx)(n.p,{children:"You can check that the recovery is working by forcefully closing the underlying engine:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'import { io } from "socket.io-client";\n\nconst socket = io({\n  reconnectionDelay: 10000, // defaults to 1000\n  reconnectionDelayMax: 10000 // defaults to 5000\n});\n\nsocket.on("connect", () => {\n  console.log("recovered?", socket.recovered);\n\n  setTimeout(() => {\n    if (socket.io.engine) {\n      // close the low-level connection and trigger a reconnection\n      socket.io.engine.close();\n    }\n  }, 10000);\n});\n'})}),"\n",(0,i.jsx)(n.h2,{id:"compatibility-with-existing-adapters",children:"Compatibility with existing adapters"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Adapter"}),(0,i.jsx)(n.th,{children:"Support?"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Built-in adapter (in memory)"}),(0,i.jsx)(n.td,{children:"YES \u2705"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Redis adapter"}),(0,i.jsx)(n.td,{children:"NO"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Redis Streams adapter"}),(0,i.jsx)(n.td,{children:"YES \u2705"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"MongoDB adapter"}),(0,i.jsxs)(n.td,{children:["YES \u2705 (since version ",(0,i.jsx)(n.code,{children:"0.3.0"}),")"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Postgres adapter"}),(0,i.jsx)(n.td,{children:"WIP"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Cluster adapter"}),(0,i.jsx)(n.td,{children:"WIP"})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"how-it-works-under-the-hood",children:"How it works under the hood"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["the server sends a session ID ",(0,i.jsx)(n.code,{children:"during the handshake"})," (which is different from the current id attribute, which is public and can be freely shared)"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'40{"sid":"GNpWD7LbGCBNCr8GAAAB","pid":"YHcX2sdAF1z452-HAAAW"}\n\nwhere\n\n4         => the Engine.IO message type\n0         => the Socket.IO CONNECT type\nGN...AB   => the public id of the session\nYH...AW   => the private id of the session\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["the server also includes an offset in ",(0,i.jsx)(n.em,{children:"each packet"})," (added at the end of the data array, for backward compatibility)"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'42["foo","MzUPkW0"]\n\nwhere\n\n4         => the Engine.IO message type\n2         => the Socket.IO EVENT type\nfoo       => the event name (socket.emit("foo"))\nMzUPkW0   => the offset\n'})}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsx)(n.p,{children:"For the recovery to succeed, the server must send at least one event, in order to initialize the offset on the client side."})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"upon temporary disconnection, the server stores the client state for a given delay (implemented at the adapter level)"}),"\n",(0,i.jsx)(n.li,{children:"upon reconnection, the client sends both the session ID and the last offset it has processed, and the server tries to restore the state"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'40{"pid":"YHcX2sdAF1z452-HAAAW","offset":"MzUPkW0"}\n\nwhere\n\n4         => the Engine.IO message type\n0         => the Socket.IO CONNECT type\nYH...AW   => the private id of the session\nMzUPkW0   => the last processed offset\n'})})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},3546:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>c});var s=t(9729);const i={},o=s.createContext(i);function r(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);