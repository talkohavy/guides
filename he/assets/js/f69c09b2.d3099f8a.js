"use strict";(self.webpackChunkdocusaurus_guides=self.webpackChunkdocusaurus_guides||[]).push([[8874],{2996:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>m,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"programming/devops/helm/helm-strategies","title":"Helm Strategies","description":"1. Automatically Roll Deployments","source":"@site/docs/programming/devops/helm/helm-strategies.md","sourceDirName":"programming/devops/helm","slug":"/programming/devops/helm/helm-strategies","permalink":"/guides/he/docs/programming/devops/helm/helm-strategies","draft":false,"unlisted":false,"editUrl":"https://github.com/talkohavy/guides/docs/programming/devops/helm/helm-strategies.md","tags":[],"version":"current","frontMatter":{},"sidebar":"mySidebar","previous":{"title":"- Maintain a Chart","permalink":"/guides/he/docs/programming/devops/helm/maintain-a-chart"},"next":{"title":"- Daily Workflow","permalink":"/guides/he/docs/programming/devops/helm/daily-workflow"}}');var i=n(5813),o=n(3546);const a={},r="Helm Strategies",l={},c=[{value:"1. Automatically Roll Deployments",id:"1-automatically-roll-deployments",level:2}];function d(e){const t={admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"helm-strategies",children:"Helm Strategies"})}),"\n",(0,i.jsx)(t.h2,{id:"1-automatically-roll-deployments",children:"1. Automatically Roll Deployments"}),"\n",(0,i.jsxs)(t.p,{children:["Often times ConfigMaps or Secrets are injected as configuration files in containers or there are other external dependency changes that require rolling pods. Depending on the application a restart may be required should those be updated with a subsequent ",(0,i.jsx)(t.code,{children:"helm upgrade"}),", but if the deployment spec itself didn't change the application keeps running with the old configuration resulting in an inconsistent deployment."]}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"sha256sum"})," function can be used to ensure a deployment's annotation section is updated if another file changes:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-yaml",children:'kind: Deployment\nspec:\n  template:\n    metadata:\n      annotations:\n        checksum/config: {{ include (print $.Template.BasePath "/configmap.yaml") . | sha256sum }}\n[...]\n'})}),"\n",(0,i.jsx)(t.admonition,{type:"info",children:(0,i.jsxs)(t.p,{children:["If you're adding this to a library chart you won't be able to access your file in ",(0,i.jsx)(t.code,{children:"$.Template.BasePath"}),". Instead you can reference your definition with ",(0,i.jsx)(t.code,{children:'{{ include ("mylibchart.configmap") . | sha256sum }}'}),"."]})})]})}function m(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},3546:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>r});var s=n(9729);const i={},o=s.createContext(i);function a(e){const t=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(o.Provider,{value:t},e.children)}}}]);