"use strict";(self.webpackChunkdocusaurus_guides=self.webpackChunkdocusaurus_guides||[]).push([[1413],{2171:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"programming/tests/jest","title":"Jest","description":"1. Installation","source":"@site/docs/programming/tests/jest.md","sourceDirName":"programming/tests","slug":"/programming/tests/jest","permalink":"/guides/he/docs/programming/tests/jest","draft":false,"unlisted":false,"editUrl":"https://github.com/talkohavy/guides/docs/programming/tests/jest.md","tags":[],"version":"current","frontMatter":{},"sidebar":"mySidebar","previous":{"title":"- Tests","permalink":"/guides/he/docs/tests"},"next":{"title":"- React Testing Library","permalink":"/guides/he/docs/programming/tests/react-testing-library"}}');var o=t(5813),a=t(3546);const i={},r="Jest",l={},c=[{value:"1. Installation",id:"1-installation",level:2},{value:"Import css/scss modules",id:"import-cssscss-modules",level:3},{value:"Extra",id:"extra",level:3},{value:"2. Important CLI options to know",id:"2-important-cli-options-to-know",level:2},{value:"<code>--listTests</code>",id:"--listtests",level:3},{value:"<code>--config=&lt;path&gt;</code>",id:"--configpath",level:3},{value:"<code>--showConfig</code>",id:"--showconfig",level:3},{value:"<code>--passWithNoTests</code>",id:"--passwithnotests",level:3},{value:"<code>--runTestsByPath</code>",id:"--runtestsbypath",level:3},{value:"<code>--silent</code>",id:"--silent",level:3},{value:"<code>--verbose</code>",id:"--verbose",level:3},{value:"3. Catch a thrown Error",id:"3-catch-a-thrown-error",level:2},{value:"4. Testing Asynchronous Code",id:"4-testing-asynchronous-code",level:2},{value:"<code>resolves</code> &amp; <code>rejects</code>",id:"resolves--rejects",level:3},{value:"5. Mock Functions",id:"5-mock-functions",level:2},{value:"Scenario 1: Mock callback fn as argument using <code>jest.fn()</code>",id:"scenario-1-mock-callback-fn-as-argument-using-jestfn",level:3},{value:"A. Goal Explanation",id:"a-goal-explanation",level:4},{value:"B. Example code to test",id:"b-example-code-to-test",level:4},{value:"C. Case Description",id:"c-case-description",level:4},{value:"D. How to test",id:"d-how-to-test",level:4},{value:"Scenario 2: Mocking Modules with <code>jest.mock(...)</code>",id:"scenario-2-mocking-modules-with-jestmock",level:3},{value:"A. Goal Explanation",id:"a-goal-explanation-1",level:4},{value:"B. Example code to test",id:"b-example-code-to-test-1",level:4},{value:"C. Case Description",id:"c-case-description-1",level:4},{value:"D. How to test",id:"d-how-to-test-1",level:4},{value:"Scenario 3: Mocking Modules Partially",id:"scenario-3-mocking-modules-partially",level:3},{value:"A. Goal Explanation",id:"a-goal-explanation-2",level:4},{value:"B. Example code to test",id:"b-example-code-to-test-2",level:4},{value:"C. Case Description",id:"c-case-description-2",level:4},{value:"D. How to test",id:"d-how-to-test-2",level:4},{value:"Example 1: a named export",id:"example-1-a-named-export",level:5},{value:"Example 2: a default export",id:"example-2-a-default-export",level:5},{value:"Scenario 4: Mock Return Values Multiple Times",id:"scenario-4-mock-return-values-multiple-times",level:3},{value:"A. Goal Explanation",id:"a-goal-explanation-3",level:4},{value:"B. Example code to test",id:"b-example-code-to-test-3",level:4},{value:"C. Case Description",id:"c-case-description-3",level:4},{value:"D. How to test",id:"d-how-to-test-3",level:4},{value:"Scenario 5: Mock a return <code>this</code> method",id:"scenario-5-mock-a-return-this-method",level:3},{value:"A. Goal Explanation",id:"a-goal-explanation-4",level:4},{value:"B. Example code to test",id:"b-example-code-to-test-4",level:4},{value:"C. Case Description",id:"c-case-description-4",level:4},{value:"D. How to test",id:"d-how-to-test-4",level:4},{value:"6. Prefer using <code>spyOn</code> over <code>mock</code>",id:"6-prefer-using-spyon-over-mock",level:2},{value:"Scenario 1: callback function passed as argument",id:"scenario-1-callback-function-passed-as-argument",level:3},{value:"Scenario 2: mocking <code>axios.get</code>",id:"scenario-2-mocking-axiosget",level:3},{value:"Scenario 3: mock only 1 function/constant from a file.",id:"scenario-3-mock-only-1-functionconstant-from-a-file",level:3},{value:"Scenario 4: Multiple return values using <code>mockImplementationOnce</code>",id:"scenario-4-multiple-return-values-using-mockimplementationonce",level:3},{value:"Scenario 5: mock 1 method on 1 exported object from a file",id:"scenario-5-mock-1-method-on-1-exported-object-from-a-file",level:3},{value:"Scenario 6: Just pure spying",id:"scenario-6-just-pure-spying",level:3},{value:"Summary",id:"summary",level:3},{value:"<code>jest.mock()</code>",id:"jestmock",level:4},{value:"<code>jest.spyOn()</code>",id:"jestspyon",level:4},{value:"7. Timer Mocks",id:"7-timer-mocks",level:2},{value:"A. Introduction",id:"a-introduction",level:3},{value:"B. Example code to test",id:"b-example-code-to-test-5",level:3},{value:"C. How to test",id:"c-how-to-test",level:3},{value:"D. Run Pending Timers",id:"d-run-pending-timers",level:3}];function d(e){const n={admonition:"admonition",blockquote:"blockquote",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"jest",children:"Jest"})}),"\n",(0,o.jsx)(n.h2,{id:"1-installation",children:"1. Installation"}),"\n",(0,o.jsx)(n.p,{children:"Add a script:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-json",children:'{\n  "scripts": {\n    "test": "jest"\n  }\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"Install these:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"pnpm add -D jest jest-environment-jsdom ts-jest json-easy-strip @types/jest @testing-library/dom @testing-library/jest-dom @testing-library/react @testing-library/user-event\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Create a ",(0,o.jsx)(n.code,{children:"jest.config.js"})," file:",(0,o.jsx)(n.br,{}),"\n","(this file was generated using ",(0,o.jsx)(n.code,{children:"jest --init"}),")"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",metastring:"title=jest.config.js",children:'import requireJSON from \'json-easy-strip\';\nimport { createDefaultPreset } from \'ts-jest\';\nimport { pathsToModuleNameMapper } from \'ts-jest\';\nconst tsconfig = requireJSON(\'./tsconfig.json\');\n\n/**\n * @type {import(\'ts-jest\').JestConfigWithTsJest}\n */\nconst config = {\n  ...createDefaultPreset(),\n\n  // A preset that is used as a base for Jest\'s configuration\n  preset: \'ts-jest\',\n\n  // The test environment that will be used for testing\n  testEnvironment: \'jsdom\', // <--- IMPORTANT! must be \'jsdom\'. Option are: \'jsdom\' | \'node\'.\n\n  // A list of paths to modules that run some code to configure or set up the testing framework before each test\n  setupFilesAfterEnv: [\'<rootDir>/src/tests/setup.tsx\'],\n\n  // A map from regular expressions to module names or to arrays of module names that allow to stub out resources with a single module\n  moduleNameMapper: pathsToModuleNameMapper(tsconfig.compilerOptions.paths, {\n    prefix: \'<rootDir>/\',\n  }),\n\n  // A map from regular expressions to paths to transformers\n  transform: {\n    \'^.+.tsx?$\': [\'ts-jest\', {}],\n  },\n\n  // All imported modules in your tests should be mocked automatically\n  // automock: false,\n\n  // Stop running tests after `n` failures\n  // bail: 0,\n\n  // The directory where Jest should store its cached dependency information\n  // cacheDirectory: "/private/var/folders/yv/tfvrv22n3rn8g7_2dzx2n8lc0000gn/T/jest_dx",\n\n  // Automatically clear mock calls, instances, contexts and results before every test\n  // clearMocks: false,\n\n  // Indicates whether the coverage information should be collected while executing the test\n  // collectCoverage: false,\n\n  // An array of glob patterns indicating a set of files for which coverage information should be collected\n  // collectCoverageFrom: undefined,\n\n  // The directory where Jest should output its coverage files\n  // coverageDirectory: undefined,\n\n  // An array of regexp pattern strings used to skip coverage collection\n  // coveragePathIgnorePatterns: [\n  //   "/node_modules/"\n  // ],\n\n  // Indicates which provider should be used to instrument code for coverage\n  // coverageProvider: "babel",\n\n  // A list of reporter names that Jest uses when writing coverage reports\n  // coverageReporters: [\n  //   "json",\n  //   "text",\n  //   "lcov",\n  //   "clover"\n  // ],\n\n  // An object that configures minimum threshold enforcement for coverage results\n  // coverageThreshold: undefined,\n\n  // A path to a custom dependency extractor\n  // dependencyExtractor: undefined,\n\n  // Make calling deprecated APIs throw helpful error messages\n  // errorOnDeprecated: false,\n\n  // The default configuration for fake timers\n  // fakeTimers: {\n  //   "enableGlobally": false\n  // },\n\n  // Force coverage collection from ignored files using an array of glob patterns\n  // forceCoverageMatch: [],\n\n  // A path to a module which exports an async function that is triggered once before all test suites\n  // globalSetup: undefined,\n\n  // A path to a module which exports an async function that is triggered once after all test suites\n  // globalTeardown: undefined,\n\n  // A set of global variables that need to be available in all test environments\n  // globals: {},\n\n  // The maximum amount of workers used to run your tests. Can be specified as % or a number. E.g. maxWorkers: 10% will use 10% of your CPU amount + 1 as the maximum worker number. maxWorkers: 2 will use a maximum of 2 workers.\n  // maxWorkers: "50%",\n\n  // An array of directory names to be searched recursively up from the requiring module\'s location\n  // moduleDirectories: [\n  //   "node_modules"\n  // ],\n\n  // An array of file extensions your modules use\n  // moduleFileExtensions: [\n  //   "js",\n  //   "mjs",\n  //   "cjs",\n  //   "jsx",\n  //   "ts",\n  //   "tsx",\n  //   "json",\n  //   "node"\n  // ],\n\n  // An array of regexp pattern strings, matched against all module paths before considered \'visible\' to the module loader\n  // modulePathIgnorePatterns: [],\n\n  // Activates notifications for test results\n  // notify: false,\n\n  // An enum that specifies notification mode. Requires { notify: true }\n  // notifyMode: "failure-change",\n\n  // Run tests from one or more projects\n  // projects: undefined,\n\n  // Use this configuration option to add custom reporters to Jest\n  // reporters: undefined,\n\n  // Automatically reset mock state before every test\n  // resetMocks: false,\n\n  // Reset the module registry before running each individual test\n  // resetModules: false,\n\n  // A path to a custom resolver\n  // resolver: undefined,\n\n  // Automatically restore mock state and implementation before every test\n  // restoreMocks: false,\n\n  // The root directory that Jest should scan for tests and modules within\n  // rootDir: undefined,\n\n  // A list of paths to directories that Jest should use to search for files in\n  // roots: [\n  //   "<rootDir>"\n  // ],\n\n  // Allows you to use a custom runner instead of Jest\'s default test runner\n  // runner: "jest-runner",\n\n  // The paths to modules that run some code to configure or set up the testing environment before each test\n  // setupFiles: [],\n\n  // The number of seconds after which a test is considered as slow and reported as such in the results.\n  // slowTestThreshold: 5,\n\n  // A list of paths to snapshot serializer modules Jest should use for snapshot testing\n  // snapshotSerializers: [],\n\n  // Options that will be passed to the testEnvironment\n  // testEnvironmentOptions: {},\n\n  // Adds a location field to test results\n  // testLocationInResults: false,\n\n  // The glob patterns Jest uses to detect test files\n  // testMatch: [\n  //   "**/__tests__/**/*.[jt]s?(x)",\n  //   "**/?(*.)+(spec|test).[tj]s?(x)"\n  // ],\n\n  // An array of regexp pattern strings that are matched against all test paths, matched tests are skipped\n  // testPathIgnorePatterns: [\n  //   "/node_modules/"\n  // ],\n\n  // The regexp pattern or array of patterns that Jest uses to detect test files\n  // testRegex: [],\n\n  // This option allows the use of a custom results processor\n  // testResultsProcessor: undefined,\n\n  // This option allows use of a custom test runner\n  // testRunner: "jest-circus/runner",\n\n  // An array of regexp pattern strings that are matched against all source file paths, matched files will skip transformation\n  // transformIgnorePatterns: [\n  //   "/node_modules/",\n  //   "\\\\.pnp\\\\.[^\\\\/]+$"\n  // ],\n\n  // An array of regexp pattern strings that are matched against all modules before the module loader will automatically return a mock for them\n  // unmockedModulePathPatterns: undefined,\n\n  // Indicates whether each individual test should be reported during the run\n  // verbose: undefined,\n\n  // An array of regexp patterns that are matched against all source file paths before re-running tests in watch mode\n  // watchPathIgnorePatterns: [],\n\n  // Whether to use watchman for file crawling\n  // watchman: true,\n};\n\nexport default config;\n'})}),"\n",(0,o.jsxs)(n.p,{children:["Create a ",(0,o.jsx)(n.code,{children:"setup.tsx"})," file:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",metastring:"title=src/tests/setup.tsx",children:"// --- Write here any Code you need as a setup! ---\n"})}),"\n",(0,o.jsx)(n.h3,{id:"import-cssscss-modules",children:"Import css/scss modules"}),"\n",(0,o.jsxs)(n.p,{children:["Running a ",(0,o.jsx)(n.strong,{children:"Component Test"})," on a component that imports a css/scss module file ",(0,o.jsx)(n.strong,{children:"would fail"}),".",(0,o.jsx)(n.br,{}),"\n","You'll see an error like so:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"\u25cf Test suite failed to run\n\n    Jest encountered an unexpected token\n    Jest failed to parse a file. This happens ...\n\n  1 | import clsx from 'clsx';\n> 2 | import styles from './Textarea.module.scss';\n    | ^\n"})}),"\n",(0,o.jsxs)(n.p,{children:["To solve that, you'll need to configure the ",(0,o.jsx)(n.code,{children:"moduleNameMapper"})," option in your ",(0,o.jsx)(n.code,{children:"jest.config.js"})," file."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"const config = {\n// A map from regular expressions to module names or to arrays of module names that allow to stub out resources with a single module\n  moduleNameMapper: {\n    ...pathsToModuleNameMapper(tsconfig.compilerOptions.paths, {\n      prefix: '<rootDir>/',\n    }),\n    '\\\\.(css|less|scss|sass)$': 'identity-obj-proxy',\n  },\n}\n"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"identity-obj-proxy"})," - If you are using CSS Modules then it's better to mock a proxy to enable className lookups."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"You of course need to install it as a devDependency:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"pnpm add -D identity-obj-proxy\n"})}),"\n",(0,o.jsx)(n.h3,{id:"extra",children:"Extra"}),"\n",(0,o.jsxs)(n.p,{children:["There are many ways to configure jest, ",(0,o.jsxs)(n.strong,{children:["we are using ",(0,o.jsx)(n.code,{children:"ts-jest"})]}),"."]}),"\n",(0,o.jsx)(n.p,{children:"Other ways are:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Babel"}),"\n",(0,o.jsx)(n.li,{children:"webpack"}),"\n",(0,o.jsx)(n.li,{children:"Vite (Jest is not fully supported by vite)"}),"\n",(0,o.jsx)(n.li,{children:"Parcel"}),"\n",(0,o.jsxs)(n.li,{children:["TypeScript (through ",(0,o.jsx)(n.code,{children:"ts-jest"}),")"]}),"\n"]}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"2-important-cli-options-to-know",children:"2. Important CLI options to know"}),"\n",(0,o.jsx)(n.h3,{id:"--listtests",children:(0,o.jsx)(n.code,{children:"--listTests"})}),"\n",(0,o.jsx)(n.p,{children:"Lists all test files that Jest will run given the arguments, and exits."}),"\n",(0,o.jsx)(n.h3,{id:"--configpath",children:(0,o.jsx)(n.code,{children:"--config=<path>"})}),"\n",(0,o.jsxs)(n.p,{children:["Alias: ",(0,o.jsx)(n.code,{children:"-c"}),". The path to a Jest config file specifying how to find and execute tests. If no ",(0,o.jsx)(n.code,{children:"rootDir"})," is set in the config, the directory containing the config file is assumed to be the ",(0,o.jsx)(n.code,{children:"rootDir"})," for the project. This can also be a JSON-encoded value which Jest will use as configuration."]}),"\n",(0,o.jsx)(n.h3,{id:"--showconfig",children:(0,o.jsx)(n.code,{children:"--showConfig"})}),"\n",(0,o.jsx)(n.p,{children:"Print your Jest config and then exits."}),"\n",(0,o.jsx)(n.h3,{id:"--passwithnotests",children:(0,o.jsx)(n.code,{children:"--passWithNoTests"})}),"\n",(0,o.jsx)(n.p,{children:"Allows the test suite to pass when no files are found."}),"\n",(0,o.jsx)(n.h3,{id:"--runtestsbypath",children:(0,o.jsx)(n.code,{children:"--runTestsByPath"})}),"\n",(0,o.jsx)(n.p,{children:"Run only the tests that were specified with their exact paths. This avoids converting them into a regular expression and matching it against every single file."}),"\n",(0,o.jsx)(n.p,{children:"For example, given the following file structure:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"__tests__\n\u2514\u2500\u2500 t1.test.js # test\n\u2514\u2500\u2500 t2.test.js # test\n"})}),"\n",(0,o.jsx)(n.p,{children:"When ran with a pattern, no test is found:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"jest --runTestsByPath __tests__/t\n"})}),"\n",(0,o.jsx)(n.p,{children:"Output:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"No tests found\n"})}),"\n",(0,o.jsx)(n.p,{children:"However, passing an exact path will execute only the given test:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"jest --runTestsByPath __tests__/t1.test.js\n"})}),"\n",(0,o.jsx)(n.h3,{id:"--silent",children:(0,o.jsx)(n.code,{children:"--silent"})}),"\n",(0,o.jsx)(n.p,{children:"Prevent tests from printing messages through the console."}),"\n",(0,o.jsx)(n.h3,{id:"--verbose",children:(0,o.jsx)(n.code,{children:"--verbose"})}),"\n",(0,o.jsx)(n.p,{children:"Display individual test results with the test suite hierarchy."}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"3-catch-a-thrown-error",children:"3. Catch a thrown Error"}),"\n",(0,o.jsxs)(n.p,{children:["If you want to test whether a particular function throws an error when it's called, use ",(0,o.jsx)(n.code,{children:"toThrow"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"function compileAndroidCode() {\n  throw new Error('you are using the wrong JDK!');\n}\n\ntest('compiling android goes as expected', () => {\n  expect(() => compileAndroidCode()).toThrow();\n  expect(() => compileAndroidCode()).toThrow(Error);\n\n  // You can also use a string that must be contained in the error message or a regexp\n  expect(() => compileAndroidCode()).toThrow('you are using the wrong JDK');\n  expect(() => compileAndroidCode()).toThrow(/JDK/);\n\n  // Or you can match an exact error message using a regexp like below\n  expect(() => compileAndroidCode()).toThrow(/^you are using the wrong JDK$/); // Test fails\n  expect(() => compileAndroidCode()).toThrow(/^you are using the wrong JDK!$/); // Test pass\n});\n"})}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"4-testing-asynchronous-code",children:"4. Testing Asynchronous Code"}),"\n",(0,o.jsx)(n.p,{children:"Jest needs to know when the code it is testing has completed before it can move on to another test. Jest has several ways to handle this."}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Promises"}),": Return a promise from your test, and Jest will wait for that promise to resolve. If the promise is rejected, the test will fail."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Async/Await"}),": Make your test ",(0,o.jsx)(n.code,{children:"async"})," and use the ",(0,o.jsx)(n.code,{children:"await"})," keyword inside."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"These two tests are equal:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"test('the data is peanut butter', async () => {\n  const data = await fetchData();\n  expect(data).toBe('peanut butter');\n});\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"test('the data is peanut butter', () => {\n  return fetchData().then(data => {\n    expect(data).toBe('peanut butter');\n  });\n});\n"})}),"\n",(0,o.jsxs)(n.h3,{id:"resolves--rejects",children:[(0,o.jsx)(n.code,{children:"resolves"})," & ",(0,o.jsx)(n.code,{children:"rejects"})]}),"\n",(0,o.jsxs)(n.p,{children:["You can combine async and await with ",(0,o.jsx)(n.code,{children:".resolves"})," or ",(0,o.jsx)(n.code,{children:".rejects"}),".\nFor that to work ",(0,o.jsx)(n.strong,{children:"you need to pass a promise"})," to the ",(0,o.jsx)(n.code,{children:"expect"}),", and add an await keyword before the ",(0,o.jsx)(n.code,{children:"expect"}),". Jest will wait for that promise to either resolve or reject (depending)and if the promise is rejected when it should be resolved, or vice versa, the test will fail."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"test('the data is peanut butter', async () => {\n  await expect(fetchData()).resolves.toBe('peanut butter');\n});\n\ntest('the fetch fails with an error', async () => {\n  await expect(fetchData()).rejects.toMatch('error');\n});\n"})}),"\n",(0,o.jsxs)(n.admonition,{type:"danger",children:[(0,o.jsxs)(n.p,{children:["Be sure to return (or ",(0,o.jsx)(n.code,{children:"await"}),") the promise - if you omit the ",(0,o.jsx)(n.code,{children:"return"}),"/",(0,o.jsx)(n.code,{children:"await"})," statement, your test will complete before the promise returned from ",(0,o.jsx)(n.code,{children:"fetchData"})," resolves or rejects."]}),(0,o.jsx)(n.p,{children:"For example,"}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"async function fetchData() {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(1);\n    }, 1000);\n  });\n}\n\ntest('1 equals 2', () => {\n  fetchData().then((data) => {\n    expect(data).toBe(2);\n  });\n});\n"})}),(0,o.jsxs)(n.p,{children:["The above test will PASS, but ",(0,o.jsx)(n.strong,{children:"it should NOT PASS"}),"!"]})]}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"5-mock-functions",children:"5. Mock Functions"}),"\n",(0,o.jsx)(n.p,{children:"Here are all the possible scenarios you might have:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["You wanna test function A. Function A ",(0,o.jsx)(n.strong,{children:"accepts"})," callback function as one of its parameters."]}),"\n",(0,o.jsxs)(n.li,{children:["You wanna test function A. Function A ",(0,o.jsx)(n.strong,{children:"uses"})," another function B. Function A ",(0,o.jsx)(n.strong,{children:"imports"})," function B from a different file/module."]}),"\n",(0,o.jsxs)(n.li,{children:["You wanna test function A. Function A ",(0,o.jsx)(n.strong,{children:"uses"})," another function B. Functions A and B both live on the same file."]}),"\n",(0,o.jsxs)(n.li,{children:["You wanna test function A. Function A ",(0,o.jsx)(n.strong,{children:"uses"})," another function B. You need to mock the returned value with different values at each time."]}),"\n",(0,o.jsxs)(n.li,{children:["You wanna test Class A. Class A ",(0,o.jsx)(n.strong,{children:"has"})," method B which returns ",(0,o.jsx)(n.code,{children:"this"}),"."]}),"\n"]}),"\n",(0,o.jsxs)(n.h3,{id:"scenario-1-mock-callback-fn-as-argument-using-jestfn",children:["Scenario 1: Mock callback fn as argument using ",(0,o.jsx)(n.code,{children:"jest.fn()"})]}),"\n",(0,o.jsx)(n.h4,{id:"a-goal-explanation",children:"A. Goal Explanation"}),"\n",(0,o.jsxs)(n.p,{children:["You wanna test function A. Function A ",(0,o.jsx)(n.strong,{children:"accepts"})," callback function as one of its parameters."]}),"\n",(0,o.jsx)(n.h4,{id:"b-example-code-to-test",children:"B. Example code to test"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"export function forEach(items, callback) {\n  for (const item of items) {\n    callback(item);\n  }\n}\n"})}),"\n",(0,o.jsx)(n.h4,{id:"c-case-description",children:"C. Case Description"}),"\n",(0,o.jsxs)(n.p,{children:["Above we have a function called ",(0,o.jsx)(n.code,{children:"forEach"})," that we want to test. ",(0,o.jsx)(n.code,{children:"forEach"})," accepts ",(0,o.jsx)(n.code,{children:"callback"})," as a parameter, ad calls it inside for each item under the items array."]}),"\n",(0,o.jsx)(n.p,{children:"Our goal is to write a test that:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["checks how many times ",(0,o.jsx)(n.code,{children:"mockCallback"})," has been called."]}),"\n",(0,o.jsx)(n.li,{children:"checks the first argument of the first and second calls were as expected."}),"\n"]}),"\n",(0,o.jsx)(n.h4,{id:"d-how-to-test",children:"D. How to test"}),"\n",(0,o.jsx)(n.p,{children:"What are the steps to achieve this goal?"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["We will use ",(0,o.jsx)(n.code,{children:"jest.fn()"})," to create a ",(0,o.jsx)(n.code,{children:"mockCallback"})," const."]}),"\n",(0,o.jsxs)(n.li,{children:["We will pass ",(0,o.jsx)(n.code,{children:"mockCallback"})," as the argument to our tested function (forEach)."]}),"\n",(0,o.jsxs)(n.li,{children:["We will inspect the ",(0,o.jsx)(n.code,{children:"mock"})," property of ",(0,o.jsx)(n.code,{children:"mockCallback"})," (more specifically the ",(0,o.jsx)(n.code,{children:"mockCallback.mock.calls"})," sub-property)."]}),"\n",(0,o.jsxs)(n.li,{children:["Use plain matchers such as ",(0,o.jsx)(n.code,{children:"toBe"})," or ",(0,o.jsx)(n.code,{children:"toHaveLength"}),"."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"We will write the test as such:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import { forEach } from './forEach';\n\nconst mockCallback = jest.fn();\n\ntest('forEach mock function', () => {\n  const items = [0, 1];\n  forEach(items, mockCallback);\n\n  // The mock function was called al least once\n  expect(mockCallback.mock.calls.length).toBeGreaterThan(0);\n\n  // The mock function was called exactly twice\n  expect(mockCallback.mock.calls).toHaveLength(2);\n\n  // The first argument of the first call to the function was 0\n  expect(mockCallback.mock.calls[0][0]).toBe(0);\n\n  // The first argument of the second call to the function was 1\n  expect(mockCallback.mock.calls[1][0]).toBe(1);\n});\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Instead of using the ",(0,o.jsx)(n.code,{children:".mock"})," property directly, jest had created a syntactic sugar around it for every operation and check we might need. So we will not be writing test as above."]}),"\n",(0,o.jsx)(n.p,{children:"A better way to write it is:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import { forEach } from './forEach';\n\nconst mockCallback = jest.fn();\n\ntest('forEach mock function', () => {\n  const items = [0, 1];\n  forEach(items, mockCallback);\n\n  // The mock function was called al least once\n  // diff-remove-next-line\n  expect(mockCallback.mock.calls.length).toBeGreaterThan(0);\n  // diff-add-next-line\n  expect(mockCallback).toHaveBeenCalled();\n\n  // The mock function was called exactly twice\n  // diff-remove-next-line\n  expect(mockCallback.mock.calls).toHaveLength(2);\n  // diff-add-next-line\n  expect(mockCallback).toHaveBeenCalledTimes(2);\n\n  // The first argument of the first call to the function was 0\n  // diff-remove-next-line\n  expect(mockCallback.mock.calls[0][0]).toBe(0);\n  // diff-add-next-line\n  expect(mockCallback).toHaveBeenNthCalledWith(1, 0);\n\n  // The first argument of the second call to the function was 1\n  // diff-remove-next-line\n  expect(mockCallback.mock.calls[1][0]).toBe(1);\n  // diff-add-next-line\n  expect(mockCallback).toHaveBeenNthCalledWith(2, 1);\n});\n"})}),"\n",(0,o.jsx)("br",{}),"\n",(0,o.jsxs)(n.h3,{id:"scenario-2-mocking-modules-with-jestmock",children:["Scenario 2: Mocking Modules with ",(0,o.jsx)(n.code,{children:"jest.mock(...)"})]}),"\n",(0,o.jsx)(n.h4,{id:"a-goal-explanation-1",children:"A. Goal Explanation"}),"\n",(0,o.jsxs)(n.p,{children:["You wanna test function A. Function A ",(0,o.jsx)(n.strong,{children:"uses"})," another function B. Function A ",(0,o.jsx)(n.strong,{children:"imports"})," function B from a different file/module."]}),"\n",(0,o.jsx)(n.h4,{id:"b-example-code-to-test-1",children:"B. Example code to test"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import axios from 'axios';\n\ntype Filters = {\n  nameStartsWith: string;\n  ageGreaterThan: number;\n};\n\nexport class Users {\n  static async findMany(filters?: Filters) {\n    const updatedFilters: Filters = {\n      ageGreaterThan: filters?.ageGreaterThan ?? 0,\n      nameStartsWith: filters?.nameStartsWith ?? 't',\n    };\n\n    const response = await axios.get('/users.json', {\n      headers: {\n        'x-filter-name': updatedFilters.nameStartsWith,\n        'x-filter-age': updatedFilters.ageGreaterThan,\n      },\n    });\n\n    const { data } = response;\n\n    return data;\n  }\n}\n"})}),"\n",(0,o.jsx)(n.h4,{id:"c-case-description-1",children:"C. Case Description"}),"\n",(0,o.jsxs)(n.p,{children:["Above we have a class called ",(0,o.jsx)(n.code,{children:"Users"})," with a method called ",(0,o.jsx)(n.code,{children:"findMany"})," which we want to test. ",(0,o.jsx)(n.code,{children:"Users"})," calls ",(0,o.jsx)(n.code,{children:"axios"}),", an imported ",(0,o.jsx)(n.strong,{children:"module"}),", under the hood to send all of its async api requests. The ",(0,o.jsx)(n.code,{children:"findMany"})," method specifically calls ",(0,o.jsx)(n.code,{children:"axios.get"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"Let's say that our goal is to write a test that:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["checks that ",(0,o.jsx)(n.code,{children:"axios.get"})," had been called at least once."]}),"\n",(0,o.jsx)(n.li,{children:"checks that the headers (a property under the second argument) were created as expected."}),"\n",(0,o.jsx)(n.li,{children:"mock the response value so that the test won't crash"}),"\n"]}),"\n",(0,o.jsx)(n.h4,{id:"d-how-to-test-1",children:"D. How to test"}),"\n",(0,o.jsx)(n.p,{children:"What are the steps to achieve this goal?"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["We will use ",(0,o.jsx)(n.code,{children:"jest.mock('module-name')"})," to specify just which module to mock."]}),"\n",(0,o.jsx)(n.li,{children:"Import the module into our test. This will give us 100% control (we'll see what it means soon)."}),"\n",(0,o.jsxs)(n.li,{children:["We will mock wanted methods on axios (i.e. ",(0,o.jsx)(n.code,{children:"get"}),")."]}),"\n",(0,o.jsxs)(n.li,{children:["We would use matchers like ",(0,o.jsx)(n.code,{children:".haveBeenCalledOnce"})," and such on those mocked methods."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"\u2022 Why we need so many things?"})}),"\n",(0,o.jsxs)(n.p,{children:["First, let's explain why we need so many things. Like, why we need to write ",(0,o.jsx)(n.code,{children:"jest.mock"}),", but also import the actual module to be mocked."]}),"\n",(0,o.jsx)(n.p,{children:"Here's a test template:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import Users from './users';\n\ntest('should fetch users', async () => {\n  const data = await Users.findMany();\n\n  // ???\n});\n"})}),"\n",(0,o.jsxs)(n.p,{children:["We are calling ",(0,o.jsx)(n.code,{children:"Users.findMany()"}),", which under the hood calls ",(0,o.jsx)(n.code,{children:"axios"}),".",(0,o.jsx)(n.br,{}),"\n",(0,o.jsx)(n.code,{children:"axios"})," needs to be mocked."]}),"\n",(0,o.jsxs)(n.p,{children:["We start by adding ",(0,o.jsx)(n.code,{children:"jest.mock"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import Users from './users';\n\njest.mock('axios');\n\n// ...\n"})}),"\n",(0,o.jsxs)(n.p,{children:["What this will do is ",(0,o.jsx)(n.strong,{children:"it will mock any import of the axios module"}),", and wrap it around some ",(0,o.jsx)(n.code,{children:"jest"})," function."]}),"\n",(0,o.jsxs)(n.p,{children:["The problem with the code above is the return value. ",(0,o.jsx)(n.code,{children:"Users.findMany()"})," calls ",(0,o.jsx)(n.code,{children:"axios.get()"}),", and expects it to return some data. If it won't return the same data structure, ",(0,o.jsx)(n.strong,{children:"the code will crash"}),". We now need a way to alter the return value of ",(0,o.jsx)(n.code,{children:"axios.get()"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["What we can do is this (",(0,o.jsx)(n.em,{children:"not recommended"}),"):"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import { Users } from './users';\n\njest.mock('axios', () => {\n  return {\n    get: jest.fn(() => ({ data: { age: 5 } })),\n  };\n});\n\ntest('should fetch users', async () => {\n  const data = await Users.findMany();\n\n  expect(data.age).toBe(5);\n});\n"})}),"\n",(0,o.jsxs)(n.p,{children:["While this works, we are still missing something.",(0,o.jsx)(n.br,{}),"\n","What we wanna do is be able to ask questions like:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["How many times it has ",(0,o.jsx)(n.code,{children:"get"})," been called?"]}),"\n",(0,o.jsxs)(n.li,{children:["What were the arguments ",(0,o.jsx)(n.code,{children:"get"})," was called with?"]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["We don't have access to the ",(0,o.jsx)(n.code,{children:"get"})," function (yet!). To get it, we need to import axios ",(0,o.jsx)(n.strong,{children:"INSIDE"})," our test!"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",metastring:"showLineNumbers",children:"import axios from 'axios';\nimport { Users } from './users';\n\nconsole.log('axios is:', axios);\n\njest.mock('axios', () => {\n  return {\n    get: jest.fn(() => ({ data: { age: 5 } })),\n  };\n});\n"})}),"\n",(0,o.jsxs)(n.p,{children:["In the above code, if we were to put breakpoints in lines 4 and 6, line 6 would be hit first! ",(0,o.jsx)(n.code,{children:"jest.mock()"})," is hoisted all the way to the top! Before any of the imports occur. This guarantees that the import of ",(0,o.jsx)(n.code,{children:"axios"})," inside our test will be of the ",(0,o.jsx)(n.strong,{children:"mocked axios"}),", and not the ",(0,o.jsx)(n.strong,{children:"real axios"}),". This now gives us the ability to ask questions about ",(0,o.jsx)(n.code,{children:"axios.get"})," inside of tests:"]}),"\n",(0,o.jsxs)(n.p,{children:["With adding the import ",(0,o.jsx)(n.code,{children:"axios"})," statement, the test file will look like this:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import axios from 'axios';\nimport { Users } from './users';\n\njest.mock('axios', () => {\n  return {\n    get: jest.fn(() => ({ data: { age: 5 } })),\n  };\n});\n\ntest('should fetch users', async () => {\n  const data = await Users.findMany();\n\n  expect(axios.get).toHaveBeenCalled();\n  expect(axios.get).toHaveBeenCalledWith('/users.json', {\n    headers: { 'x-filter-name': 't', 'x-filter-age': 0 },\n  });\n  expect(data.age).toBe(5);\n});\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The above code is great, but there's one thing to note about it - the implementation mock that is provided as the second argument to ",(0,o.jsx)(n.code,{children:"jest.mock"})," will ",(0,o.jsx)(n.strong,{children:"stay the same for every test in that file"}),". Well, but what if we want to have flexibility over different test?"]}),"\n",(0,o.jsx)(n.p,{children:"What we can do is to not provide a mock implementation as the second argument, and have each test define it on the fly for its own use."}),"\n",(0,o.jsx)(n.p,{children:"Like so:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import axios from 'axios';\nimport { Users } from './users';\n\njest.mock('axios');\n\ntest('should fetch users', async () => {\n  const data = await Users.findMany();\n\n  expect(axios.get).toHaveBeenCalled();\n  expect(axios.get).toHaveBeenCalledWith('/users.json', {\n    headers: { 'x-filter-name': 't', 'x-filter-age': 0 },\n  });\n  expect(data.age).toBe(5);\n});\n"})}),"\n",(0,o.jsxs)(n.p,{children:["You're probably seeing that ",(0,o.jsx)(n.strong,{children:"typescript error"})," under ",(0,o.jsx)(n.code,{children:"mockResolvedValue"}),". Your IDE thinks it's the real ",(0,o.jsx)(n.code,{children:"axios"}),", and that ",(0,o.jsx)(n.code,{children:"axios.get"})," has no property of ",(0,o.jsx)(n.code,{children:"mockResolvedValue"})," on it. We need to tell it that ",(0,o.jsx)(n.code,{children:"axios.get"})," is a ",(0,o.jsx)(n.code,{children:"jest.fn"})," type:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import axios from 'axios';\nimport { Users } from './users';\n\njest.mock('axios');\n\ntest('should fetch users', async () => {\n  (axios.get as jest.Mock).mockResolvedValue({ data: { age: 5 } });\n  // Would also work: (axios.get as jest.Mock).mockReturnValue({ data: { age: 5 } });\n\n  const data = await Users.findMany();\n\n  expect(axios.get).toHaveBeenCalled();\n  expect(axios.get).toHaveBeenCalledWith('/users.json', {\n    headers: { 'x-filter-name': 't', 'x-filter-age': 0 },\n  });\n  expect(data.age).toBe(5);\n});\n"})}),"\n",(0,o.jsx)("br",{}),"\n",(0,o.jsx)(n.h3,{id:"scenario-3-mocking-modules-partially",children:"Scenario 3: Mocking Modules Partially"}),"\n",(0,o.jsx)(n.h4,{id:"a-goal-explanation-2",children:"A. Goal Explanation"}),"\n",(0,o.jsxs)(n.p,{children:["You wanna test function A. Function A ",(0,o.jsx)(n.strong,{children:"uses"})," another function B. Functions A and B both live on the same file."]}),"\n",(0,o.jsx)(n.h4,{id:"b-example-code-to-test-2",children:"B. Example code to test"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"export const namedExportVariable = 'named export variable';\nexport function namedExportFunction() {\n  return 'named export function';\n};\n\nexport default () => 'export default function';\n"})}),"\n",(0,o.jsx)(n.h4,{id:"c-case-description-2",children:"C. Case Description"}),"\n",(0,o.jsx)(n.p,{children:"Steps to achieve this goal:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["We will again use ",(0,o.jsx)(n.code,{children:"jest.mock"})]}),"\n",(0,o.jsxs)(n.li,{children:["We will pass it a ",(0,o.jsx)(n.strong,{children:"mock implementation"})," of the module as the seconds argument"]}),"\n",(0,o.jsxs)(n.li,{children:["Inside the mock implementation:","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["We will use ",(0,o.jsx)(n.code,{children:"jest.requireActual('path')"}),", which is a special jest function that allows us to import the real module."]}),"\n",(0,o.jsxs)(n.li,{children:["We will return an object, where inside it:","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["We will spread ",(0,o.jsx)(n.code,{children:"jest.requireActual('path')"}),". Those will be all the parts of the module we want as unmocked."]}),"\n",(0,o.jsx)(n.li,{children:"Below the spread, we will override the parts we want to mock."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["If you need to import the module as ",(0,o.jsx)(n.strong,{children:"default"}),", the return object of the mock implementation MUST contain the special key of ",(0,o.jsx)(n.code,{children:"__esModule: true,"}),"."]}),"\n"]}),"\n",(0,o.jsx)(n.h4,{id:"d-how-to-test-2",children:"D. How to test"}),"\n",(0,o.jsx)(n.h5,{id:"example-1-a-named-export",children:"Example 1: a named export"}),"\n",(0,o.jsxs)(n.p,{children:["If we only want to mock ",(0,o.jsx)(n.code,{children:"namedExportFunction"}),", then our test file should be:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import { namedExportFunction, namedExportVariable } from './foo-bar-baz';\n\njest.mock('./foo-bar-baz', () => {\n  const originalModule = jest.requireActual('./foo-bar-baz');\n\n  return {\n    ...originalModule,\n    namedExportFunction: jest.fn(() => 'mocked named export function'),\n  };\n});\n\ntest('should do a partial mock', () => {\n  // The mocked parts:\n  const namedExportFunctionResult = namedExportFunction();\n  expect(namedExportFunction).toHaveBeenCalled();\n  expect(namedExportFunctionResult).toBe('mocked named export function');\n\n  // The unmocked parts:\n  expect(namedExportVariable).toBe('named export variable');\n});\n"})}),"\n",(0,o.jsx)(n.h5,{id:"example-2-a-default-export",children:"Example 2: a default export"}),"\n",(0,o.jsxs)(n.p,{children:["If you need to either ",(0,o.jsx)(n.strong,{children:"mock a default export"})," object, or ",(0,o.jsx)(n.strong,{children:"import a default export"})," object, you'll need to use the special keyword of ",(0,o.jsx)(n.code,{children:"__esModule: true,"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["For example, here's the test file when mocking the ",(0,o.jsx)(n.code,{children:"export default"})," object:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import defaultExportFunction, { namedExportVariable } from './foo-bar-baz';\n\njest.mock('./foo-bar-baz', () => {\n  const originalModule = jest.requireActual('./foo-bar-baz');\n\n  return {\n    __esModule: true,\n    ...originalModule,\n    default: jest.fn(() => 'mocked export default function'),\n  };\n});\n\ntest('should do a partial mock', () => {\n  // The mocked parts:\n  const defaultExportFunctionResult = defaultExportFunction();\n  expect(defaultExportFunction).toHaveBeenCalled();\n  expect(defaultExportFunctionResult).toBe('mocked export default function');\n\n  // The unmocked parts:\n  expect(namedExportVariable).toBe('named export variable');\n});\n"})}),"\n",(0,o.jsxs)(n.p,{children:["And here's the test file when only using the ",(0,o.jsx)(n.code,{children:"export default"})," object, and mocking another named part of the module:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import defaultExportFunction, { namedExportVariable } from './foo-bar-baz';\n\njest.mock('./foo-bar-baz', () => {\n  const originalModule = jest.requireActual('./foo-bar-baz');\n\n  return {\n    __esModule: true,\n    ...originalModule,\n    namedExportVariable: 'mocked named export variable',\n  };\n});\n\ntest('should do a partial mock', () => {\n  // The mocked parts:\n  expect(namedExportVariable).toBe('mocked named export variable');\n\n  // The unmocked parts:\n  const defaultExportFunctionResult = defaultExportFunction();\n  expect(defaultExportFunctionResult).toBe('export default function');\n});\n"})}),"\n",(0,o.jsxs)(n.p,{children:["In both cases, omitting the ",(0,o.jsx)(n.code,{children:"__esModule: true"})," would cause the tests to fail."]}),"\n",(0,o.jsx)("br",{}),"\n",(0,o.jsx)(n.h3,{id:"scenario-4-mock-return-values-multiple-times",children:"Scenario 4: Mock Return Values Multiple Times"}),"\n",(0,o.jsx)(n.h4,{id:"a-goal-explanation-3",children:"A. Goal Explanation"}),"\n",(0,o.jsxs)(n.p,{children:["You wanna test function A. Function A ",(0,o.jsx)(n.strong,{children:"uses"})," another function B. You need to mock the returned value with different values at each time."]}),"\n",(0,o.jsx)(n.h4,{id:"b-example-code-to-test-3",children:"B. Example code to test"}),"\n",(0,o.jsx)(n.p,{children:"None. This is just about the test itself."}),"\n",(0,o.jsx)(n.h4,{id:"c-case-description-3",children:"C. Case Description"}),"\n",(0,o.jsxs)(n.p,{children:["We can control the ",(0,o.jsx)(n.strong,{children:"implementation"})," of the mock function depending of the amount of calls made to it so far (index-based)."]}),"\n",(0,o.jsx)(n.h4,{id:"d-how-to-test-3",children:"D. How to test"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"test('should do a partial mock', () => {\n  const myMockFn = jest\n    .fn(() => 1)\n    .mockImplementation(() => 3);\n    .mockImplementationOnce(() => 10)\n    .mockImplementationOnce(() => 42)\n\n  console.log(myMockFn()); // 10\n  console.log(myMockFn()); // 42\n  console.log(myMockFn()); // 3\n  console.log(myMockFn()); // 3\n  console.log(myMockFn()); // 3\n\n  expect(1).toBe(1);\n});\n"})}),"\n",(0,o.jsxs)(n.p,{children:["When you need to recreate a complex behavior of a mock function such that multiple function calls produce different results, use the ",(0,o.jsx)(n.code,{children:"mockImplementationOnce"})," method. When the mocked function runs out of implementations defined with ",(0,o.jsx)(n.code,{children:"mockImplementationOnce"}),", it will execute the default implementation set with:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"mockImplementation"})," - first priority! (if defined)"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"jest.fn"})," - second priority (if defined)"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"The output of the code above would be:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"10\n42\n3\n3\n3\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Notice how ",(0,o.jsx)(n.code,{children:"1"})," is never printed."]}),"\n",(0,o.jsxs)(n.p,{children:["It's worth noting that the order of appearance of ",(0,o.jsx)(n.code,{children:"mockImplementationOnce"})," matters, but when ",(0,o.jsx)(n.code,{children:"mockImplementation"})," appears doesn't matter.",(0,o.jsx)(n.br,{}),"\n","For example:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"// This:\nconst myMockFn = jest\n  .fn()\n  .mockImplementation(() => 3);\n  .mockImplementationOnce(() => 10)\n  .mockImplementationOnce(() => 42)\n\n// is exactly the same as this:\nconst myMockFn = jest\n  .fn()\n  .mockImplementationOnce(() => 10)\n  .mockImplementationOnce(() => 42)\n  .mockImplementation(() => 3);\n\n// and also the same as this:\nconst myMockFn = jest\n  .fn(() => 3)\n  .mockImplementationOnce(() => 10)\n  .mockImplementationOnce(() => 42);\n"})}),"\n",(0,o.jsx)("br",{}),"\n",(0,o.jsxs)(n.h3,{id:"scenario-5-mock-a-return-this-method",children:["Scenario 5: Mock a return ",(0,o.jsx)(n.code,{children:"this"})," method"]}),"\n",(0,o.jsx)(n.h4,{id:"a-goal-explanation-4",children:"A. Goal Explanation"}),"\n",(0,o.jsxs)(n.p,{children:["You wanna test Class A. Class A ",(0,o.jsx)(n.strong,{children:"has"})," method B which returns ",(0,o.jsx)(n.code,{children:"this"}),"."]}),"\n",(0,o.jsx)(n.h4,{id:"b-example-code-to-test-4",children:"B. Example code to test"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"export class MyClass {\n  private name: string = '';\n  private age: number = 0;\n\n  setName(name?: string): this {\n    if (typeof name === 'string') this.name = name;\n\n    return this;\n  }\n\n  setAge(age?: number) {\n    if (typeof age === 'number') this.age = age;\n\n    return this;\n  }\n\n  logCreated() {\n    fetch('http://localhost:8000').then((response) => {\n      console.log('data is:', response);\n    });\n\n    return this;\n  }\n\n  toJSON(): { name: string; age: number } {\n    return { name: this.name, age: this.age };\n  }\n}\n\ntype InitProps = {\n  name?: string;\n  age?: number;\n};\n\nexport function init(props?: InitProps) {\n  const { name, age } = props ?? {};\n\n  const instance = new MyClass().setName(name).setAge(age).logCreated();\n\n  return instance;\n}\n"})}),"\n",(0,o.jsx)(n.h4,{id:"c-case-description-4",children:"C. Case Description"}),"\n",(0,o.jsxs)(n.p,{children:["Above we have a function called ",(0,o.jsx)(n.code,{children:"init"})," that we want to test. ",(0,o.jsx)(n.code,{children:"init"})," creates an instance of ",(0,o.jsx)(n.code,{children:"MyClass"}),", and calls a few of its methods. The problem is that one of the methods (",(0,o.jsx)(n.code,{children:"logCreated"})," in this case) is making an API request, which we want to avoid."]}),"\n",(0,o.jsx)(n.p,{children:"Our goal is:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["to write a test that tests the ",(0,o.jsx)(n.code,{children:"init"})," function."]}),"\n",(0,o.jsx)(n.li,{children:"avoid the request call (do not send an API request)."}),"\n"]}),"\n",(0,o.jsx)(n.h4,{id:"d-how-to-test-4",children:"D. How to test"}),"\n",(0,o.jsxs)(n.p,{children:["We start off by mocking the module of ",(0,o.jsx)(n.code,{children:"MyClass"})," using ",(0,o.jsx)(n.code,{children:"jest.mock"}),".",(0,o.jsx)(n.br,{}),"\n","We only want to mock ",(0,o.jsx)(n.code,{children:"MyClass.prototype.logCreated"}),", and for the rest of the stuff from the module to remain as the actual implementation, so we'll use ",(0,o.jsx)(n.code,{children:"jest.requireActual()"}),". Then, we'll mock just the ",(0,o.jsx)(n.code,{children:"logCreated"})," method, and since we need it to return a pointer to ",(0,o.jsx)(n.code,{children:"this"}),", we'll use jest's ",(0,o.jsx)(n.code,{children:"mockReturnThis"}),". We will import ",(0,o.jsx)(n.code,{children:"MyClass"}),", which will be the mocked version (since we used ",(0,o.jsx)(n.code,{children:"jest.mock"}),"), and we'll ask questions about ",(0,o.jsx)(n.code,{children:"MyClass.prototype.logCreated"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import { MyClass, init } from './MyClass';\n\njest.mock('./MyClass', () => {\n  const actualModule = jest.requireActual('./MyClass');\n\n  actualModule.MyClass.prototype.logCreated = jest.fn().mockReturnThis();\n\n  return actualModule;\n});\n\ndescribe('init function', () => {\n  it('should create an instance of MyClass and use real methods except logCreated', async () => {\n    const instance = init({ name: 'Alice', age: 30 });\n\n    // Ensure that the object is an instance of MyClass\n    expect(instance).toBeInstanceOf(MyClass);\n\n    // Check that the real setName and setAge methods worked\n    expect(instance.toJSON()).toEqual({ name: 'Alice', age: 30 });\n\n    // Ensure that logCreated was called\n    expect(MyClass.prototype.logCreated).toHaveBeenCalledTimes(1);\n  });\n});\n"})}),"\n",(0,o.jsxs)(n.h2,{id:"6-prefer-using-spyon-over-mock",children:["6. Prefer using ",(0,o.jsx)(n.code,{children:"spyOn"})," over ",(0,o.jsx)(n.code,{children:"mock"})]}),"\n",(0,o.jsxs)(n.p,{children:["When possible, always prefer using ",(0,o.jsx)(n.code,{children:"spyOn"})," instead of ",(0,o.jsx)(n.code,{children:"mock"}),"."]}),"\n",(0,o.jsx)(n.h3,{id:"scenario-1-callback-function-passed-as-argument",children:"Scenario 1: callback function passed as argument"}),"\n",(0,o.jsx)(n.p,{children:"The example code:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"export function forEach(items, callback) {\n  for (const item of items) {\n    callback(item);\n  }\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"The test we wrote:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import { forEach } from './forEach';\n\nconst mockCallback = jest.fn();\n\ntest('forEach mock function', () => {\n  const items = [0, 1];\n  forEach(items, mockCallback);\n\n  expect(mockCallback).toHaveBeenCalled();\n  expect(mockCallback).toHaveBeenCalledTimes(2);\n  expect(mockCallback).toHaveBeenNthCalledWith(1, 0);\n  expect(mockCallback).toHaveBeenNthCalledWith(2, 1);\n});\n"})}),"\n",(0,o.jsx)(n.p,{children:"The conclusion:"}),"\n",(0,o.jsxs)(n.p,{children:["We had used ",(0,o.jsx)(n.code,{children:"jest.fn()"})," to create a function that does not exist (and named it ",(0,o.jsx)(n.code,{children:"mockCallback"}),"). We use ",(0,o.jsx)(n.code,{children:"spyOn"})," on functions that do exist, and because ",(0,o.jsx)(n.code,{children:"mockCallback"})," did not exists, it's not right to use ",(0,o.jsx)(n.code,{children:"spyOn"})," in this case."]}),"\n",(0,o.jsx)("br",{}),"\n",(0,o.jsxs)(n.h3,{id:"scenario-2-mocking-axiosget",children:["Scenario 2: mocking ",(0,o.jsx)(n.code,{children:"axios.get"})]}),"\n",(0,o.jsx)(n.p,{children:"The example code:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import axios from 'axios';\n\ntype Filters = {\n  nameStartsWith: string;\n  ageGreaterThan: number;\n};\n\nexport class Users {\n  static async findMany(filters?: Filters) {\n    const updatedFilters: Filters = {\n      ageGreaterThan: filters?.ageGreaterThan ?? 0,\n      nameStartsWith: filters?.nameStartsWith ?? 't',\n    };\n\n    const response = await axios.get('/users.json', {\n      headers: {\n        'x-filter-name': updatedFilters.nameStartsWith,\n        'x-filter-age': updatedFilters.ageGreaterThan,\n      },\n    });\n\n    const { data } = response;\n\n    return data;\n  }\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"The test we wrote:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import axios from 'axios';\nimport { Users } from './users';\n\njest.mock('axios');\n\ntest('should fetch users', async () => {\n  (axios.get as jest.Mock).mockResolvedValue({ data: { age: 5 } });\n  // Would also work: (axios.get as jest.Mock).mockReturnValue({ data: { age: 5 } });\n\n  const data = await Users.findMany();\n\n  expect(axios.get).toHaveBeenCalled();\n  expect(axios.get).toHaveBeenCalledWith('/users.json', {\n    headers: { 'x-filter-name': 't', 'x-filter-age': 0 },\n  });\n  expect(data.age).toBe(5);\n});\n"})}),"\n",(0,o.jsx)(n.p,{children:"The conclusion:"}),"\n",(0,o.jsxs)(n.p,{children:["This is a perfect example of when to prefer using ",(0,o.jsx)(n.code,{children:"jest.spyOn"}),".",(0,o.jsx)(n.br,{}),"\n","We see above tht we're mocking the entire ",(0,o.jsx)(n.code,{children:"axios"})," module, when in fact all we want to do is mock the ",(0,o.jsx)(n.code,{children:"get"})," method."]}),"\n",(0,o.jsx)(n.p,{children:"A better approach is:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import axios from 'axios';\nimport { Users } from './users';\n\n// diff-remove-next-line\njest.mock('axios');\n\ntest('should fetch users', async () => {\n  // diff-remove-next-line\n  (axios.get as jest.Mock).mockResolvedValue({ data: { age: 5 } });\n  // diff-add-next-line\n  const axiosGetSpy = jest.spyOn(axios, 'get').mockResolvedValue({ data: { age: 5 } });\n\n  const data = await Users.findMany();\n\n  expect(axiosGetSpy).toHaveBeenCalled();\n  expect(axiosGetSpy).toHaveBeenCalledWith('/users.json', {\n    headers: { 'x-filter-name': 't', 'x-filter-age': 0 },\n  });\n\n  expect(data.age).toBe(5);\n});\n"})}),"\n",(0,o.jsx)(n.p,{children:"While the difference may seem mild, it is quite large:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"We no longer need the type coercion."}),"\n",(0,o.jsxs)(n.li,{children:["We no longer mock the ",(0,o.jsx)(n.em,{children:"entire"})," module."]}),"\n",(0,o.jsxs)(n.li,{children:["The ",(0,o.jsx)(n.code,{children:"axios"})," instance is different (mocked v.s. real)."]}),"\n",(0,o.jsxs)(n.li,{children:["We no longer ",(0,o.jsx)(n.strong,{children:"affect non-related parts"})," (for example, ",(0,o.jsx)(n.code,{children:"axios.post"}),")."]}),"\n"]}),"\n",(0,o.jsx)("br",{}),"\n",(0,o.jsx)(n.h3,{id:"scenario-3-mock-only-1-functionconstant-from-a-file",children:"Scenario 3: mock only 1 function/constant from a file."}),"\n",(0,o.jsx)(n.p,{children:"The example code:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"export const namedExportVariable = 'named export variable';\nexport function namedExportFunction() {\n  return 'named export function';\n};\n\nexport default () => 'export default function';\n"})}),"\n",(0,o.jsx)(n.p,{children:"The test we wrote:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import { namedExportFunction, namedExportVariable } from './foo-bar-baz';\n\njest.mock('./foo-bar-baz', () => {\n  const originalModule = jest.requireActual('./foo-bar-baz');\n\n  return {\n    ...originalModule,\n    namedExportFunction: jest.fn(() => 'mocked named export function'),\n  };\n});\n\ntest('should do a partial mock', () => {\n  // The mocked parts:\n  const namedExportFunctionResult = namedExportFunction();\n  expect(namedExportFunction).toHaveBeenCalled();\n  expect(namedExportFunctionResult).toBe('mocked named export function');\n\n  // The unmocked parts:\n  expect(namedExportVariable).toBe('named export variable');\n});\n"})}),"\n",(0,o.jsx)(n.p,{children:"The conclusion:"}),"\n",(0,o.jsxs)(n.p,{children:["Another great example of using ",(0,o.jsx)(n.code,{children:"spyOn"}),".",(0,o.jsx)(n.br,{}),"\n","All this boilerplate of ",(0,o.jsx)(n.code,{children:"jest.mock"})," could be spared, by just using ",(0,o.jsx)(n.code,{children:"spyOn"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import { namedExportFunction, namedExportVariable } from './foo-bar-baz';\n\ntest('should do a partial mock', () => {\n  const namedExportFunctionSpy = jest\n    .spyOn(require('./foo-bar-baz'), 'namedExportFunction')\n    .mockReturnValue('mocked named export function');\n\n  const namedExportFunctionResult = namedExportFunction();\n\n  expect(namedExportFunctionSpy).toHaveBeenCalled();\n  expect(namedExportFunctionResult).toBe('mocked named export function');\n  expect(namedExportVariable).toBe('named export variable');\n});\n"})}),"\n",(0,o.jsx)(n.p,{children:"See how much cleaner this is? \u2705"}),"\n",(0,o.jsxs)(n.p,{children:["We didn't need to mock the entire module, and just mocked the parts we needed.",(0,o.jsx)(n.br,{}),"\n","Also, ",(0,o.jsx)(n.code,{children:"spy"})," functions are similar to ",(0,o.jsx)(n.code,{children:"jest.fn"})," functions in the sense that their implementation can be mocked, so it's not ",(0,o.jsx)(n.em,{children:"just"})," spying."]}),"\n",(0,o.jsx)("br",{}),"\n",(0,o.jsxs)(n.h3,{id:"scenario-4-multiple-return-values-using-mockimplementationonce",children:["Scenario 4: Multiple return values using ",(0,o.jsx)(n.code,{children:"mockImplementationOnce"})]}),"\n",(0,o.jsxs)(n.p,{children:["Scenario 4 talked about ",(0,o.jsx)(n.code,{children:"mockImplementationOnce"}),", so there's nothing here to actually compare with ",(0,o.jsx)(n.code,{children:"spyOn"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"const myMockFn = jest\n  .fn()\n  .mockImplementation(() => 3);\n  .mockImplementationOnce(() => 10)\n  .mockImplementationOnce(() => 42)\n"})}),"\n",(0,o.jsxs)(n.p,{children:["We will say though that ",(0,o.jsx)(n.code,{children:"jest.spyOn"})," also supports ",(0,o.jsx)(n.code,{children:"mockImplementationOnce"}),", since it is similar to ",(0,o.jsx)(n.code,{children:"jest.fn"})]}),"\n",(0,o.jsx)("br",{}),"\n",(0,o.jsx)(n.h3,{id:"scenario-5-mock-1-method-on-1-exported-object-from-a-file",children:"Scenario 5: mock 1 method on 1 exported object from a file"}),"\n",(0,o.jsx)(n.p,{children:"The example code:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"export class MyClass {\n  private name: string = '';\n  private age: number = 0;\n\n  setName(name?: string): this {\n    if (typeof name === 'string') this.name = name;\n\n    return this;\n  }\n\n  setAge(age?: number) {\n    if (typeof age === 'number') this.age = age;\n\n    return this;\n  }\n\n  logCreated() {\n    fetch('http://localhost:8000').then((response) => {\n      console.log('data is:', response);\n    });\n\n    return this;\n  }\n\n  toJSON(): { name: string; age: number } {\n    return { name: this.name, age: this.age };\n  }\n}\n\ntype InitProps = { name?: string; age?: number; };\n\nexport function init(props?: InitProps) {\n  const { name, age } = props ?? {};\n\n  const instance = new MyClass().setName(name).setAge(age).logCreated();\n\n  return instance;\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"The test we wrote:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import { MyClass, init } from './MyClass';\n\njest.mock('./MyClass', () => {\n  const actualModule = jest.requireActual('./MyClass');\n  actualModule.MyClass.prototype.logCreated = jest.fn().mockReturnThis();\n  return actualModule;\n});\n\ndescribe('init function', () => {\n  it('should create an instance of MyClass and use real methods except logCreated', async () => {\n    const instance = init({ name: 'Alice', age: 30 });\n\n    expect(instance).toBeInstanceOf(MyClass);\n    expect(instance.toJSON()).toEqual({ name: 'Alice', age: 30 });\n    expect(MyClass.prototype.logCreated).toHaveBeenCalledTimes(1);\n  });\n});\n"})}),"\n",(0,o.jsx)(n.p,{children:"The conclusion:"}),"\n",(0,o.jsxs)(n.p,{children:["Another great example of when to prefer ",(0,o.jsx)(n.code,{children:"spyOn"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"Look at the following test:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import { MyClass, init } from './MyClass';\n\ndescribe('init function', () => {\n  it('should create an instance of MyClass and use real methods except logCreated', async () => {\n    const logCreatedSpy = jest.spyOn(MyClass.prototype, 'logCreated').mockReturnThis();\n\n    const instance = init({ name: 'Alice', age: 30 });\n\n    expect(instance).toBeInstanceOf(MyClass);\n    expect(instance.toJSON()).toEqual({ name: 'Alice', age: 30 });\n    expect(logCreatedSpy).toHaveBeenCalledTimes(1);\n  });\n});\n"})}),"\n",(0,o.jsxs)(n.p,{children:["We removed all the boilerplate of ",(0,o.jsx)(n.code,{children:"jest.mock"}),", and only added the spy on what we wanted, which is the ",(0,o.jsx)(n.code,{children:"logCreated"})," method."]}),"\n",(0,o.jsx)("br",{}),"\n",(0,o.jsx)(n.h3,{id:"scenario-6-just-pure-spying",children:"Scenario 6: Just pure spying"}),"\n",(0,o.jsxs)(n.p,{children:["This is a new scenario only possible with ",(0,o.jsx)(n.code,{children:"spyOn"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["What if we just want to spy on a function? We don't want to affect the function's implementation. We simply want to run assertions on it, such as: ",(0,o.jsx)(n.code,{children:"toHaveBeenCalled"})," or ",(0,o.jsx)(n.code,{children:"toHaveBeenCalledWith"}),". For that purpose, ",(0,o.jsx)(n.code,{children:"spyOn"})," is our ",(0,o.jsx)(n.strong,{children:"ONLY"})," option."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",metastring:"title=makeFood.ts",children:"export function makeFood(){\n  return 'dinner'\n}\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",metastring:"title=makeFood.test.ts",children:"import { makeFood } from './makeFood';\n\ntest('makeFood', () => {\n  const makeFoodModule = require('./makeFood');\n  const makeFoodSpy = jest.spyOn(makeFoodModule, 'makeFood');\n\n  const food = makeFood();\n\n  expect(food).toBe('dinner');\n  expect(makeFoodSpy).toHaveBeenCalled();\n});\n"})}),"\n",(0,o.jsx)("br",{}),"\n",(0,o.jsx)(n.h3,{id:"summary",children:"Summary"}),"\n",(0,o.jsx)(n.h4,{id:"jestmock",children:(0,o.jsx)(n.code,{children:"jest.mock()"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Automatically ",(0,o.jsx)(n.strong,{children:"mocks an entire module"}),"."]}),"\n",(0,o.jsx)(n.li,{children:"Used to replace all exports of a module with mock functions."}),"\n",(0,o.jsx)(n.li,{children:"If no implementation is provided, all the mocked functions return undefined by default."}),"\n"]}),"\n",(0,o.jsx)(n.h4,{id:"jestspyon",children:(0,o.jsx)(n.code,{children:"jest.spyOn()"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Spies on an existing method"})," of an object."]}),"\n",(0,o.jsxs)(n.li,{children:["A ",(0,o.jsx)(n.strong,{children:"required module"})," can be considered as an object."]}),"\n",(0,o.jsxs)(n.li,{children:["Allows you to track calls ",(0,o.jsx)(n.strong,{children:"while still calling the original implementation"}),", unless overridden."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Less code is required"})," in order to spy 1 function inside a module with multiple exports."]}),"\n",(0,o.jsxs)(n.li,{children:["THE ",(0,o.jsx)(n.code,{children:"global"})," object can also be considered as an object. i.e.: ",(0,o.jsx)(n.code,{children:"jest.spyOn(global, 'setTimeout');"}),". But don't mock ",(0,o.jsx)(n.code,{children:"setTimeout"}),", since you have ",(0,o.jsx)(n.code,{children:"jest.useFakeTimers()"})," already built-in."]}),"\n"]}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"7-timer-mocks",children:"7. Timer Mocks"}),"\n",(0,o.jsx)(n.h3,{id:"a-introduction",children:"A. Introduction"}),"\n",(0,o.jsxs)(n.p,{children:["The native timer functions, ",(0,o.jsx)(n.code,{children:"setTimeout()"}),", ",(0,o.jsx)(n.code,{children:"setInterval()"}),", ",(0,o.jsx)(n.code,{children:"clearTimeout()"}),", and ",(0,o.jsx)(n.code,{children:"clearInterval()"})," have a ",(0,o.jsx)(n.strong,{children:"NEGATIVE"})," effect on a testing since they rely on real time to elapse, making tests slow and unreliable."]}),"\n",(0,o.jsxs)(n.p,{children:["As a solution, jest has 2 functions: ",(0,o.jsx)(n.code,{children:"jest.useFakeTimers()"})," & ",(0,o.jsx)(n.code,{children:"jest.useRealTimers()"}),". The ",(0,o.jsx)(n.code,{children:"useFakeTimers"})," is replacing the original implementation of ",(0,o.jsx)(n.code,{children:"setTimeout()"})," and other timer functions, and ",(0,o.jsx)(n.code,{children:"useRealTimers"})," restores them to their normal behavior."]}),"\n",(0,o.jsx)(n.p,{children:"jest also has the very useful functions:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"jest.runAllTimers()"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"jest.runOnlyPendingTimers()"})}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"b-example-code-to-test-5",children:"B. Example code to test"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",metastring:'title="timerGame.ts"',children:"export function timerGame(callback) {\n  console.log('Ready....go!');\n\n  setTimeout(() => {\n    console.log(\"Time's up -- stop!\");\n    callback && callback();\n  }, 1000);\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"c-how-to-test",children:"C. How to test"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",metastring:'title="timerGame.test.ts"',children:"jest.useFakeTimers();\ntest('calls the callback after 1 second', () => {\n  const timerGame = require('../timerGame');\n  const callback = jest.fn();\n\n  timerGame(callback);\n\n  // At this point in time, the callback should not have been called yet\n  expect(callback).not.toHaveBeenCalled();\n\n  // Fast-forward until all timers have been executed\n  jest.runAllTimers();\n\n  // Now our callback should have been called!\n  expect(callback).toHaveBeenCalled();\n  expect(callback).toHaveBeenCalledTimes(1);\n});\n"})}),"\n",(0,o.jsx)(n.h3,{id:"d-run-pending-timers",children:"D. Run Pending Timers"}),"\n",(0,o.jsx)(n.p,{children:'There are also scenarios where you might have a recursive timer \u2013 that is a timer that sets a new timer in its own callback. For these, running all the timers would be an endless loop, throwing the following error: "Aborting after running 100000 timers, assuming an infinite loop!"'}),"\n",(0,o.jsx)(n.p,{children:"If that is your case, using jest.runOnlyPendingTimers() will solve the problem."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"export function infiniteTimerGame(callback) {\n  console.log('Ready....go!');\n\n  setTimeout(() => {\n    console.log(\"Time's up! 10 seconds before the next game starts...\");\n    callback && callback();\n\n    // Schedule the next game in 10 seconds\n    setTimeout(() => {\n      infiniteTimerGame(callback);\n    }, 10000);\n  }, 1000);\n}\n"})}),"\n",(0,o.jsxs)(n.admonition,{type:"info",children:[(0,o.jsx)(n.p,{children:"For debugging or any other reason you can change the limit of timers (which is by default 100000 as we said) that will be run before throwing an error:"}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"jest.useFakeTimers({timerLimit: 100});\n"})})]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},3546:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>r});var s=t(9729);const o={},a=s.createContext(o);function i(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);