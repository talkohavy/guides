"use strict";(self.webpackChunkdocusaurus_guides=self.webpackChunkdocusaurus_guides||[]).push([[5371],{525:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>d,frontMatter:()=>i,metadata:()=>t,toc:()=>h});const t=JSON.parse('{"id":"programming/crypto","title":"Crypto","description":"1. Introduction","source":"@site/docs/programming/crypto.md","sourceDirName":"programming","slug":"/programming/crypto","permalink":"/guides/he/docs/programming/crypto","draft":false,"unlisted":false,"editUrl":"https://github.com/talkohavy/guides/docs/programming/crypto.md","tags":[],"version":"current","frontMatter":{},"sidebar":"mySidebar","previous":{"title":"- AWS Kubernetes","permalink":"/guides/he/docs/programming/aws-kubernetes"},"next":{"title":"- Certificates","permalink":"/guides/he/docs/programming/certificates"}}');var a=s(6070),r=s(7010);const i={},c="Crypto",o={},h=[{value:"1. Introduction",id:"1-introduction",level:2},{value:"2. Cryptography Concepts",id:"2-cryptography-concepts",level:2},{value:"- Concept 1: HASH",id:"--concept-1-hash",level:3},{value:"- Concept 2: SALT",id:"--concept-2-salt",level:3},{value:"- Concept 3: HMAC",id:"--concept-3-hmac",level:3},{value:"- Concept 4: SYMETRIC ENCRYPTION",id:"--concept-4-symetric-encryption",level:3},{value:"- Concept 5: KEYPAIRS",id:"--concept-5-keypairs",level:3},{value:"- Concept 6: ASYMMETRIC ENCRYPTION",id:"--concept-6-asymmetric-encryption",level:3},{value:"- Concept 7: SIGNING",id:"--concept-7-signing",level:3},{value:"3. Summary",id:"3-summary",level:2},{value:"- A. Create Hash",id:"--a-create-hash",level:3},{value:"\u2022 Algorithm:",id:"-algorithm",level:4},{value:"\u2022 Encoding:",id:"-encoding",level:4},{value:"- B. Create Salt",id:"--b-create-salt",level:3}];function l(e){const n={br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"crypto",children:"Crypto"})}),"\n",(0,a.jsx)(n.h2,{id:"1-introduction",children:"1. Introduction"}),"\n",(0,a.jsxs)(n.p,{children:["Node comes with a built-in package called crypto.\nThe node",":crypto"," module provides cryptographic functionality that includes a set of wrappers for OpenSSL's hash, HMAC, cipher, decipher, sign, and verify functions.\nBefore talking about crypto, we need to discuss 7 cryptography concepts."]}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"2-cryptography-concepts",children:"2. Cryptography Concepts"}),"\n",(0,a.jsx)(n.h3,{id:"--concept-1-hash",children:"- Concept 1: HASH"}),"\n",(0,a.jsx)(n.p,{children:"A hash is simply applying a function on a certain content, and receiving back a mumbled string that looks like garbage, but if we apply the same hash function on the same content, we'd get the same mumbled string back."}),"\n",(0,a.jsx)(n.p,{children:"How can we use hash in node?"}),"\n",(0,a.jsxs)(n.p,{children:["We start off by importing the ",(0,a.jsx)(n.code,{children:"createHash"})," function from the crypto package:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const { createHash } = require('crypto');\n"})}),"\n",(0,a.jsx)(n.p,{children:'Next, we generate a custom function, which we\'d name as "myHash":'}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// This is an incomplete code!\nfunction myHash(input){\n  return createHash();\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The function above returns a hash string as the output.",(0,a.jsx)(n.br,{}),"\n","The first step, is to define the hashing algorithm you want to use:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// This is an incomplete code!\nfunction hash(input){\n  return createHash('sha256');\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The algorithm is dependent on the available algorithms supported by the version of OpenSSL on the platform. Examples are 'sha256', 'sha512', etc. On recent releases of OpenSSL, ",(0,a.jsx)(n.code,{children:"openssl list -digest-algorithms"})," will display the available digest algorithms."]}),"\n",(0,a.jsx)(n.p,{children:"Famous algorithm options:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"sha256"}),"\n",(0,a.jsx)(n.li,{children:"sha512"}),"\n",(0,a.jsx)(n.li,{children:"md5"}),"\n",(0,a.jsx)(n.li,{children:"argon2 (not built-in to node's crypto)"}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:['In the example above, I\'m using "sha256", which stands for "Security Hash Algorithm". This algorithm returns a hash value, which is also called a "digest", with 256 bits. The algorithm you choose is important! One of the algorithms to choose from is "md5". As computers have become faster, and the internet more vast, the md5 algorithm has become obsolete. Remember, cryptography is always evolving. "sha256" is a good option, but there are even better solutions like "argon2", although it\'s not built-in to node\'s crypto.',(0,a.jsx)(n.br,{}),"\n","Once we have our hashing algo, we can call ",(0,a.jsx)(n.code,{children:"update"})," and pass in input value:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// This is an incomplete code!\nfunction hash(value){\n  return createHash('sha256').update(value);\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["And then return an output with a call to ",(0,a.jsx)(n.code,{children:"digest"})," along with the format we want to return:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"function hash(value){\n  return createHash('sha256').update(value).digest('hex');\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["As the name suggests, the ",(0,a.jsx)(n.code,{children:"digest"})," function digests (calculates) all of the data passed, which you want to be hashed. If an encoding is provided, a ",(0,a.jsx)(n.em,{children:"string"})," will be returned; otherwise a ",(0,a.jsx)(n.em,{children:"Buffer"})," is returned."]}),"\n",(0,a.jsx)(n.p,{children:"Here is the list of all encoding options that digest accepts:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"hex (what we will use)"}),"\n",(0,a.jsx)(n.li,{children:"base64 (an option you'll commonly see)"}),"\n",(0,a.jsx)(n.li,{children:"utf8 (utf-8 is an alias)"}),"\n",(0,a.jsx)(n.li,{children:"utf16le (utf-16le is an alias)"}),"\n",(0,a.jsx)(n.li,{children:"latin1"}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["In this tutorial, we'll be using hexadecimal format ",(0,a.jsx)(n.code,{children:"hex"}),", but another option you'll most commonly see is ",(0,a.jsx)(n.code,{children:"base64"}),".\nNow that you have this function, you can pass in an input, like a password:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const password = 'hi-mom!';\nconst hash1 = hash(password);\n"})}),"\n",(0,a.jsx)(n.p,{children:"and if you'll console log it, you'll get a long string similar to this:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"console.log(hash1);\n// would print: 7a5d84e61a2234b450185fde58c237bb13e93d93d90f669b114d\n"})}),"\n",(0,a.jsx)(n.p,{children:"So you'll get this long string of numbers and letters, that hide its original meaning. Now, if we create another hash, and compare the two, we'll know that the original value is the same, if the two hashes match-up:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// compare two hashed passwords:\nconst password2 = 'hi-mom!';\nconst hash2 = hash(password);\nconst isMatch = hash1 === hash2\nconsole.log(isMatch)\n// would print out: true\n"})}),"\n",(0,a.jsxs)(n.p,{children:["That's super useful, but a hash by itself isn't actually sufficient for storing a password in a database. And that brings us to our next topic - ",(0,a.jsx)(n.strong,{children:"salt"}),"!"]}),"\n",(0,a.jsx)(n.h3,{id:"--concept-2-salt",children:"- Concept 2: SALT"}),"\n",(0,a.jsxs)(n.p,{children:["As I mentioned above, a hash is super useful, but by itself, a hash isn't actually sufficient for storing a password in a database. We need salt!",(0,a.jsx)(n.br,{}),"\n","The fact that a hashing function always returns the same value is also a problem when it comes to passwords. Especially when you let stupid humans come up with them (i.e. password123)."]}),"\n",(0,a.jsx)(n.p,{children:"@@@@@@\nHash Image Here\n@@@@@@"}),"\n",(0,a.jsxs)(n.p,{children:['If a hacker obtains the database, and the passwords are hashed, they can often just go to something like a "rainbow table", that has a bunch of pre-computed hashes and find a bunch of commonly used passwords.',(0,a.jsx)(n.br,{}),"\n","A \"salt\" is just a random value that's added to the password before it's hashed, and therefore making it much harder to guess."]}),"\n",(0,a.jsx)(n.p,{children:"@@@@@@\nSalt Image Here\n@@@@@@"}),"\n",(0,a.jsxs)(n.p,{children:["In node, we can hash a password with salt by importing ",(0,a.jsx)(n.code,{children:"scryptSync"})," & the ",(0,a.jsx)(n.code,{children:"randomBytes"})," function from within crypto:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const { scryptSync, randomBytes } = require('crypto');\n"})}),"\n",(0,a.jsx)(n.p,{children:"Then we'll define the functions signUp & login:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const { scryptSync, randomBytes } = require('crypto');\n\nfunction signUp(email,password){}\n\nfunction login(email,password){}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["They both take an email and a password as their arguments.",(0,a.jsx)(n.br,{}),"\n",'When a user signs up, we\'ll generate a "salt", using the ',(0,a.jsx)(n.code,{children:"randomBytes"})," function, which will basically just create a random set of characters for us:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const { scryptSync, randomBytes } = require('crypto');\n\nfunction signUp(email,password){\n  const salt = randomBytes(16).toString('hex');\n}\n\nfunction login(email,password){}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Then we will use ",(0,a.jsx)(n.code,{children:"scryptSync"})," to hash both the salt and the password:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const { scryptSync, randomBytes } = require('crypto');\n\nfunction signUp(email,password){\n  const salt = randomBytes(16).toString('hex');\n  const hashedPassword = scryptSync(password, salt, 64).toString('hex');\n}\n\nfunction login(email,password){}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["We provide ",(0,a.jsx)(n.code,{children:"scryptSync"})," with the ",(0,a.jsx)(n.em,{children:"original password and salt"}),", and provide a ",(0,a.jsx)(n.em,{children:"key length"})," which is ",(0,a.jsx)(n.em,{children:"recommended to be 64"}),".",(0,a.jsx)(n.br,{}),"\n","Without getting into more details, ",(0,a.jsx)(n.code,{children:"scryptSync"})," makes it more ",(0,a.jsx)(n.strong,{children:"computational intensive to crack using brute force"}),", and it's actually been used as ",(0,a.jsx)(n.strong,{children:"proof of work algorithms used in cryptocurrency mining"}),".",(0,a.jsx)(n.br,{}),"\n","So now that we have a hashed password, we also need to store the salt with it, and we can do that by just pre-pending it to the existing string, separated by a semi-colon:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const { scryptSync, randomBytes } = require('crypto');\n\nfunction signUp(email,password){\n  const salt = randomBytes(16).toString('hex');\n  const hashedPassword = scryptSync(password, salt, 64).toString('hex');\n\n  const user = { email, password: `${salt}:${hashedPassword}` }\n}\n\nfunction login(email,password){}\n"})}),"\n",(0,a.jsx)(n.p,{children:"Now, when the user goes to log in, we can grab the salt from the database, and recreate the original hash, like so:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const { scryptSync, randomBytes } = require('crypto');\n\nfunction signUp(email,password){\n  const salt = randomBytes(16).toString('hex');\n  const hashedPassword = scryptSync(password, salt, 64).toString('hex');\n\n  const user = { email, password: `${salt}:${hashedPassword}` };\n\n  users.push(user);\n\n  return user;\n}\n\nfunction login(email,password){\n  const user = users.find((item) => item.email === email);\n\n  const [salt,key] = user.password.split(':');\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"We have two ways of performing a user login."}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"- Way number 1:"})}),"\n",(0,a.jsx)(n.p,{children:'The client supplies an email & a password, right? So we would use ONLY the email to get the user from the database, split the "password" column to both the salt & the hashed password, use the salt and provided password to regenerate the hashed password. Compare between the two, and decide.'}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"- Way number 2:"}),"\nWe will use way number 2. As an extra added security attachment, I'm going to import the timingSafeEqual function from node crypto, which prevents timing attacks..."]}),"\n",(0,a.jsx)(n.p,{children:"@@@@@@\nTime Attack Picture\n@@@@@@"}),"\n",(0,a.jsx)(n.p,{children:"...where a hacker measures the amount of time it takes to perform an operation, to obtain information about the value. This function helps prevents that type of attack:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const { scryptSync, randomBytes, timingSafeEqual } = require('crypto');\n\nfunction signUp(email,password){ ... }\n\nfunction login(email,password){\n  const user = users.find((item) => item.email === email);\n\n  const [salt,hashedPassword] = user.password.split(':');\n  const rawHashedPasswordBuffer = scryptSync(rawPassword, salt, 64);\n\n  const hashedPasswordBuffer = Buffer.from(hashedPassword, 'hex');\n  const match = timingSafeEqual(rawHashedPasswordBuffer, hashedPasswordBuffer);\n  if(match){\n    return 'login success!';\n  }else{\n    return 'login failed...';\n  }\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The crypto.timingSafeEqual() function is used to determine whether two variables are equal without exposing timing information that may allow an attacker to guess one of the values. A constant-time algorithm underpins it. That's how basic email-password authentication works on the web, but a related topic you might come across is Hashed-based Message Authentication Code (",(0,a.jsx)(n.strong,{children:"HMAC"}),")."]}),"\n",(0,a.jsx)(n.h3,{id:"--concept-3-hmac",children:"- Concept 3: HMAC"}),"\n",(0,a.jsx)(n.p,{children:"The quick definition to HMAC is that it's a hash that also requires a password\u2026"}),"\n",(0,a.jsx)(n.p,{children:"@@@@@@\nHmac Picture here\n@@@@@@"}),"\n",(0,a.jsxs)(n.p,{children:["\u2026so that the only person that can create the same hash signature must also have the corresponding password or key. An example is a Json Web Token (JWT), used for authentication on the web. When a user logs in on a trusted server, the server generates a token using a special key chosen by the developer. Then, the client and server can pass that token back and forth, and the server can trust it because it knows that only someone with the exact same secret key could have generated that hash signature.",(0,a.jsx)(n.br,{}),"\n",'In node, we can import that "createHmac" function:']}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const { createHmac } = require('crypto');\n"})}),"\n",(0,a.jsx)(n.p,{children:"Then we'll define a secret key, along with the message that we want to hash:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const { createHmac } = require('crypto');\n\nconst key = 'super-secret!'; // Store it some-place safe! Like an env file\nconst message = 'boo!';\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Now we use the ",(0,a.jsx)(n.code,{children:"hmac"})," function to create a hash, similar to as we did before:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const { createHmac } = require('crypto');\n\nconst key = 'super-secret!';\nconst message = 'boo !';\n\nconst hmac = createHmac('sha256', key).update(message).digest('hex');\n"})}),"\n",(0,a.jsxs)(n.p,{children:['The only difference we notice here is that we also provide this "key" param to createHmac. The important thing to notice here, is that we would only get the same hash, if the same message AND key/password combination is used. If we had the same message, but with a different key, we would get a different hash as a result. That\'s pretty cool!',(0,a.jsx)(n.br,{}),"\n","But what happens when you want to share a secret with someone, and also allow them to read the original message? That's where encryption comes in!"]}),"\n",(0,a.jsx)(n.h3,{id:"--concept-4-symetric-encryption",children:"- Concept 4: SYMETRIC ENCRYPTION"}),"\n",(0,a.jsxs)(n.p,{children:["What is encryption exactly?",(0,a.jsx)(n.br,{}),"\n","With encryption, we take a message, scramble up the bytes to make it unreadable, that's called the ",(0,a.jsx)(n.strong,{children:"Cyphertext"})," - an encrypted text transformed from plaintext using an encryption algorithm."]}),"\n",(0,a.jsx)(n.p,{children:"@@@@@@\nCipher text image\n@@@@@@"}),"\n",(0,a.jsx)(n.p,{children:"Then we provide a key/password allowing somebody else to decrypt it:"}),"\n",(0,a.jsx)(n.p,{children:"@@@@@@\ncipher image 2\n@@@@@@"}),"\n",(0,a.jsx)(n.p,{children:"It's also typically randomized, so that each time you encrypt, you'd get an entirely different encrypted output, even if the key and message are the same. The first encryption example we'll look at is the Symmetric one, which means that there's a shared password between the two parties. Both the sender and the receiver of the message need to have the exact same key."}),"\n",(0,a.jsx)(n.p,{children:"To implement this in node, we're going to import:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"createCipheriv"}),'\nfor when encrypting a message (btw, iv stands for "initial vector").']}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"randomBytes"}),"\nfor randomness at each encryption (the SALT)."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"createDecipheriv"}),"\nfor when decrypting a message."]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const { createCipheriv, randomBytes, createDecipheriv } = require('crypto');\n"})}),"\n",(0,a.jsx)(n.p,{children:"So, first we have the message itself, the one that we're trying to encrypt:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const { createCipheriv, randomBytes, createDecipheriv } = require('crypto');\n\nconst message = 'I like turtles';\n"})}),"\n",(0,a.jsxs)(n.p,{children:['Then we\'ll define "key" as ',(0,a.jsx)(n.strong,{children:"32 randomBytes"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const { createCipheriv, randomBytes, createDecipheriv } = require('crypto');\n\nconst message = 'I like turtles';\nconst key = randomBytes(32);\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Next we'll create the initial vector as ",(0,a.jsx)(n.strong,{children:"16 randomBytes"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const { createCipheriv, randomBytes, createDecipheriv } = require('crypto');\n\nconst message = 'I like turtles';\nconst key = randomBytes(32);\nconst iv = randomBytes(16);\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The iv will ",(0,a.jsx)(n.strong,{children:"randomize"})," the output when its encrypted, so that when identical sequence attacks occur, they will never produce the same cyphertext, making it more difficult for a hacker to break the encryption. Now, we can use these values to create a ",(0,a.jsx)(n.code,{children:"cipher"}),". Like a hash, it is dependent upon an algorithm, although encryption algorithms are inherently different than hashing algorithms (Advanced Encryption Standard - AES), so you'll notice an entirely different set of options here:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const { createCipheriv, randomBytes, createDecipheriv } = require('crypto');\n\nconst message = 'I like turtles';\nconst key = randomBytes(32);\nconst iv = randomBytes(16);\n\nconst cipher = createCipheriv('aes256', key, iv);\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Now, you can ",(0,a.jsx)(n.em,{children:"use"})," the ",(0,a.jsx)(n.code,{children:"cipher"})," to ",(0,a.jsx)(n.em,{children:"encrypt a message"})," by calling ",(0,a.jsx)(n.code,{children:"cypher.update"}),", or even multiple messages if you want to, then finish it off by calling ",(0,a.jsx)(n.code,{children:"cipher.final"}),", and ",(0,a.jsx)(n.em,{children:"add that value to the end of the encrypted message"}),", and finalize the ",(0,a.jsx)(n.code,{children:"cipher"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const { createCipheriv, randomBytes, createDecipheriv } = require('crypto');\n\nconst message = 'I like turtles';\nconst key = randomBytes(32);\nconst iv = randomBytes(16);\n\nconst cipher = createCipheriv('aes256', key, iv);\n\n// Encrypt:\nconst encryptedMessage = cipher.update(message, 'utf8', 'hex') + cipher.final('hex');\n"})}),"\n",(0,a.jsxs)(n.p,{children:["At this point, the ",(0,a.jsx)(n.code,{children:"cipher"})," ",(0,a.jsx)(n.em,{children:"can no longer be used to encrypt data"}),"!\nNow, to decipher it, create a ",(0,a.jsx)(n.code,{children:"decipher"})," object using ",(0,a.jsx)(n.code,{children:"createDecipheriv"}),", with the same key and initial vector (iv). Use the same basic pattern of ",(0,a.jsx)(n.code,{children:"update"})," and ",(0,a.jsx)(n.code,{children:"final"})," to convert the encrypted message back into plain text:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const { createCipheriv, randomBytes, createDecipheriv } = require('crypto');\n\nconst message = 'I like turtles';\nconst key = randomBytes(32);\nconst iv = randomBytes(16);\n\nconst cipher = createCipheriv('aes256', key, iv);\n\n// Encrypt:\nconst encryptedMessage = cipher.update(message, 'utf8', 'hex') + cipher.final('hex');\n\nconst decipher = createDecipheriv('aes256', key, iv);\n\n// Decrypt:\nconst decryptedMessage = decipher.update(encryptedMessage, 'hex', 'utf-8') + decipher.final('utf8');\n"})}),"\n",(0,a.jsx)(n.p,{children:"And that's how you encrypt and decrypt a message in node."}),"\n",(0,a.jsx)(n.h3,{id:"--concept-5-keypairs",children:"- Concept 5: KEYPAIRS"}),"\n",(0,a.jsx)(n.p,{children:"There's a big limitation to symmetric encryption, and that's the fact that both the sender and receiver of the message, need to share a password. It's just not practical for two different parties to agree upon a shared password."}),"\n",(0,a.jsx)(n.p,{children:"@@@@@@\nshared key pair image\n@@@@@@"}),"\n",(0,a.jsxs)(n.p,{children:["Once again, math comes to the rescue, and this time in the form of a public-key crypto-system. Instead of one key, it uses two keys that are mathematically linked.\nA ",(0,a.jsx)(n.strong,{children:"public key"}),", and a ",(0,a.jsx)(n.strong,{children:"private key"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"@@@@@@\nprivate key & public key\n@@@@@@"}),"\n",(0,a.jsxs)(n.p,{children:["key can be shared with other people. In node, we can generate a private & public key pair using the ",(0,a.jsx)(n.code,{children:"generateKeyPair"})," function."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const { generateKeyPairSync } = require('crypto');\n"})}),"\n",(0,a.jsx)(n.p,{children:"The first argument is the crypto-system you wanna use:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const { generateKeyPairSync } = require('crypto');\n\nconst { privateKey, publicKey } = generateKeyPairSync('rsa');\n"})}),"\n",(0,a.jsxs)(n.p,{children:["which in our case will be 'rsa', and you're not gonna believe what the initials stand for:",(0,a.jsx)(n.br,{}),"\n",(0,a.jsx)(n.strong,{children:"rsa = Rivest + Shamir + Adleman"}),(0,a.jsx)(n.br,{}),"\n","Fucking names! Adi Shamir is an Israeli Jewish, born in 1952, B.sc. in computer science and Mathematics.",(0,a.jsx)(n.br,{}),"\n","Anyways,",(0,a.jsx)(n.br,{}),"\n","Within the ",(0,a.jsx)(n.em,{children:"options"})," of the function we can define a bunch of settings, like the length of the key in bits, and also the encoding of the public & private keys. We'll go with the recommended settings here, and have it return a format of 'pem' (which stands for Privacy Enhanced Mail) to show us the keys in base64 format:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const { generateKeyPairSync } = require('crypto');\n\nconst { privateKey, publicKey } = generateKeyPairSync('rsa', {\n  modulusLength: 2048, // the length of your key in bits,\n  publicKeyEncoding: {\n    type: 'spki', // recommended to be 'spki' by the Node.js docs\n    format: 'pem',\n  },\n  privateKeyEncoding: {\n    type: 'pkcs8', // recommended to be 'pkcs8' by the Node.js docs\n    format: 'pem',\n    // cipher: 'aes-256-cbc',\n    // passpharse: 'top secret',\n  },\n});\n\nconsole.log(publicKey);\nconsole.log(privateKey);\n\nmodule.exports = { privateKey, publicKey }\n"})}),"\n",(0,a.jsx)(n.p,{children:"You could also add a passphrase to your private key for added security (the cipher & passphrase options which are commented out above)."}),"\n",(0,a.jsx)(n.h3,{id:"--concept-6-asymmetric-encryption",children:"- Concept 6: ASYMMETRIC ENCRYPTION"}),"\n",(0,a.jsxs)(n.p,{children:["And that brings us to asymmetric encryption!",(0,a.jsx)(n.br,{}),"\n","You use asymmetric encryption any time you go to a website using an https. The browser will automatically find a public key of an SSL certificate installed on the website."]}),"\n",(0,a.jsx)(n.p,{children:"@@@@@@\nasymmetric encryption image\n@@@@@@"}),"\n",(0,a.jsx)(n.p,{children:"In git, when pushing to a git repository, your private key and the other party's public key are used to encrypt the data which you send over. That prevents hackers from gaining anything useful from it in transit."}),"\n",(0,a.jsx)(n.p,{children:"On websites, HTTPS uses asymmetric encryption to establish the identity of the parties and to exchange a symmetric key. Then symmetric encryption is used since it's faster."}),"\n",(0,a.jsxs)(n.p,{children:["The implementation in node is very simple. We import ",(0,a.jsx)(n.code,{children:"publicEncrypt"}),", and ",(0,a.jsx)(n.code,{children:"privateDecrypt"})," from node crypto, along with the ",(0,a.jsx)(n.em,{children:"public & private keys"})," that we generated previously:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const { privateEncrypt, publicDecrypt } = require('crypto');\nconst { publicKey, privateKey } = require('./keypair');\n"})}),"\n",(0,a.jsxs)(n.p,{children:["we can then encrypt a message or put it in a mailbox by combining the ",(0,a.jsx)(n.strong,{children:"publicKey"})," with the ",(0,a.jsx)(n.strong,{children:"message"})," itself."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// The Frontend:\nconst { publicDecrypt } = require('crypto');\nconst { publicKey } = require('./keypair'); // got back from the server! Like an SSL Cert!\n\nconst message = 'the british are coming!';\n\nconst encryptedData = publicEncrypt(publicKey, Buffer.from(message));\n\nconsole.log(encryptedData.toString('hex'));\n// Send the encrypted message to the server!\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Notice that we're not providing the message in its original format, rather use a buffer format. It needs to be that way. The ",(0,a.jsx)(n.code,{children:"publicEncrypt"})," function will ",(0,a.jsx)(n.em,{children:"encrypt the message"})," so that only the owner of the mailbox could read it. At some point in the future, the recipient may want to read the original message, which can be done by calling ",(0,a.jsx)(n.code,{children:"privateDecrypt"}),", along with the ",(0,a.jsx)(n.em,{children:"privateKey"})," and the ",(0,a.jsx)(n.code,{children:"encryptedData"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// The Backend:\nconst { privateDecrypt } = require('crypto');\nconst { privateKey } = require('./keypair');\n\nconst encryptedData = got it from the frontend\u2026.\n\nconst decryptedData = privateDecrypt(privateKey, encryptedData);\n\nconsole.log(decryptedData.toString('utf-8'));\n"})}),"\n",(0,a.jsx)(n.p,{children:'This is the "unlock mailbox" operation.'}),"\n",(0,a.jsx)(n.h3,{id:"--concept-7-signing",children:"- Concept 7: SIGNING"}),"\n",(0,a.jsx)(n.p,{children:"Now, encryption is fun, but in many cases you don't actually need to encrypt data, but rather validate that it came from a trusted party. That's where signing comes in."}),"\n",(0,a.jsx)(n.p,{children:"What is a digital signature?"}),"\n",(0,a.jsx)(n.p,{children:"Let's imagine you're expecting a letter in the mail, with some sensitive information. You need to be able to trust that that letter came from the right person. So you require them to sign it with blood. It also can't be tempered with, so they put a special seal on it..."}),"\n",(0,a.jsx)(n.p,{children:"@@@@@@\nenvelope signing image\n@@@@@@"}),"\n",(0,a.jsxs)(n.p,{children:["...that if broken, will indicate that it's been tempered with.",(0,a.jsx)(n.br,{}),"\n","Digital signatures work in the same basic way."]}),"\n",(0,a.jsx)(n.p,{children:"@@@@@@\nblood image\n@@@@@@"}),"\n",(0,a.jsx)(n.p,{children:"The sender of the message will use their private key to sign a hash of the original message. The private key guarantees authenticity, like blood, and the hash guarantees that the message can't be tempered with, because it would produce an entirely different signature. The recipient can then use the publicKey to validate the authenticity of the message."}),"\n",(0,a.jsx)(n.p,{children:"@@@@@@\nverify image\n@@@@@@"}),"\n",(0,a.jsx)(n.p,{children:"In node, we can create a signature with the createSign function:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const { createSign } = require('crypto');\n"})}),"\n",(0,a.jsx)(n.p,{children:"then pass in the algorithm that uses the rsa crypto-system sha256 for hashing:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const { createSign } = require('crypto');\n\n// SIGN:\nconst signer = createSign('rsa-sha256');\n"})}),"\n",(0,a.jsx)(n.p,{children:"We then update it with the message we want to sign, and create the actual signature with the private key."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const { createSign } = require('crypto');\nconst { privateKey } = require('./keypair');\n\n// SIGN:\nconst signer = createSign('rsa-sha256');\nsigner.update(message);\nconst signature = signer.sign(privateKey, 'hex');\n"})}),"\n",(0,a.jsx)(n.p,{children:'We can now attach the signature to the original message, and send it to someone. The message itself can remain un-encrypted, because what this use case is saying: "all I care about is you being who you say you are". When the other side gets it, he can create a verifier, update the original message, and then verify the signature with the sender\'s public key:'}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const { createSign, createVerify } = require('crypto');\nconst { privateKey, publicKey } = require('./keypair');\n\n// SIGN:\nconst signer = createSign('rsa-sha256');\nsigner.update(message);\nconst signature = signer.sign(privateKey, 'hex');\n\n// VERIFY:\nconst verifier = createVerify('rsa-sha256');\nverifier.update(message);\nconst isVerified = verifier.verify(publicKey, signature, 'hex');\n"})}),"\n",(0,a.jsx)(n.p,{children:"If the signature was forged, or the message got changed, the verifier will fail. And that gives us 7 cryptography concepts that every developer should know:"}),"\n",(0,a.jsx)(n.p,{children:"@@@@@@\nall concepts image\n@@@@@@"}),"\n",(0,a.jsx)(n.h2,{id:"3-summary",children:"3. Summary"}),"\n",(0,a.jsx)(n.h3,{id:"--a-create-hash",children:"- A. Create Hash"}),"\n",(0,a.jsx)(n.p,{children:"Command structure:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"function hash(value){\n  return createHash('sha256').update(value).digest('hex');\n}\n\nconst password = 'hi-mom!';\nconst hash1 = hash(password);\n\nconsole.log(hash1);\n// would print: 7a5d84e61a2234b450185fde58c237bb13e93d93d90f669b114d\n\n// compare two hashed passwords:\nconst password2 = 'hi-mom!';\nconst hash2 = hash(password);\nconst isMatch = hash1 === hash2;\nconsole.log(isMatch); // would print out: true\n"})}),"\n",(0,a.jsx)(n.h4,{id:"-algorithm",children:"\u2022 Algorithm:"}),"\n",(0,a.jsx)(n.p,{children:"The algorithm is dependent on the available algorithms supported by the version of OpenSSL on the platform. Examples are 'sha256', 'sha512', etc. On recent releases of OpenSSL, openssl list -digest-algorithms will display the available digest algorithms."}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"sha256"}),"\n",(0,a.jsx)(n.li,{children:"sha512"}),"\n",(0,a.jsx)(n.li,{children:"md5"}),"\n",(0,a.jsx)(n.li,{children:"argon2 (not built-in to node's crypto)"}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"-encoding",children:"\u2022 Encoding:"}),"\n",(0,a.jsx)(n.p,{children:"Here is the list of all encoding options that digest accepts:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"hex (what we will use)"}),"\n",(0,a.jsx)(n.li,{children:"base64 (an option you'll commonly see)"}),"\n",(0,a.jsx)(n.li,{children:"utf8 (utf-8 is an alias)"}),"\n",(0,a.jsx)(n.li,{children:"utf16le (utf-16le is an alias)"}),"\n",(0,a.jsx)(n.li,{children:"latin1"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"--b-create-salt",children:"- B. Create Salt"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const { scryptSync, randomBytes, timingSafeEqual } = require('crypto');\n\nasync function signUp( email, password ){\n  const salt = randomBytes(16).toString('hex');\n  const hashedPassword = scryptSync(password, salt, 64).toString('hex');\n\n  const user = { email, hashedPassword, salt };\n  const data = await Users.register(user);\n\n  return data;\n}\n\nasync function login(email,password){\n  const user = await Users.findUserByEmail(email);\n  const { salt, hashedPassword } = user;\n\n  const rawHashedPasswordBuffer = scryptSync(rawPassword, salt, 64);\n  const hashedPasswordBuffer = Buffer.from(hashedPassword, 'hex');\n  const match = timingSafeEqual(rawHashedPasswordBuffer, hashedPasswordBuffer);\n\n  return match ? 'login success!' : 'login failed...';\n}\n"})})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},7010:(e,n,s)=>{s.d(n,{R:()=>i,x:()=>c});var t=s(758);const a={},r=t.createContext(a);function i(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);